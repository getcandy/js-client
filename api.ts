// tslint:disable
/**
 * GetCandy
 * The GetCandy API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@getcandy.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountPasswordResetBody
 */
export interface AccountPasswordResetBody {
    /**
     * 
     * @type {string}
     * @memberof AccountPasswordResetBody
     */
    password_confirmation: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPasswordResetBody
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof AccountPasswordResetBody
     */
    current_password: string;
}
/**
 * 
 * @export
 * @interface ActivityLog
 */
export interface ActivityLog {
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    properties?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityLog
     */
    created_at?: string;
    /**
     * 
     * @type {UserResponse}
     * @memberof ActivityLog
     */
    user?: UserResponse;
}
/**
 * 
 * @export
 * @interface ActivityLogCollection
 */
export interface ActivityLogCollection {
    /**
     * 
     * @type {Array<ActivityLog>}
     * @memberof ActivityLogCollection
     */
    data?: Array<ActivityLog>;
}
/**
 * 
 * @export
 * @interface AddBasketMetaBody
 */
export interface AddBasketMetaBody {
    /**
     * 
     * @type {string}
     * @memberof AddBasketMetaBody
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof AddBasketMetaBody
     */
    key: string;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    firstname?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    lastname?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    address_two?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    address_three?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    state?: string;
    /**
     * 
     * @type {CountryResponse}
     * @memberof Address
     */
    country?: CountryResponse;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    postal_code?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    salutation?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Address
     */
    _default?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Address
     */
    shipping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Address
     */
    delivery?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    delivery_instructions?: string;
    /**
     * 
     * @type {object | Array<object>}
     * @memberof Address
     */
    meta?: object | Array<object>;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    last_used_at?: string;
}
/**
 * 
 * @export
 * @interface AddressResponse
 */
export interface AddressResponse {
    /**
     * 
     * @type {Address}
     * @memberof AddressResponse
     */
    data?: Address;
}
/**
 * 
 * @export
 * @interface Aggregation
 */
export interface Aggregation {
    /**
     * 
     * @type {string}
     * @memberof Aggregation
     */
    handle?: string;
    /**
     * 
     * @type {number}
     * @memberof Aggregation
     */
    doc_count?: number;
    /**
     * 
     * @type {object}
     * @memberof Aggregation
     */
    data?: object;
    /**
     * 
     * @type {Array<object>}
     * @memberof Aggregation
     */
    buckets?: Array<object>;
}
/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {ApiErrorError}
     * @memberof ApiError
     */
    error?: ApiErrorError;
}
/**
 * 
 * @export
 * @interface ApiErrorError
 */
export interface ApiErrorError {
    /**
     * 
     * @type {number}
     * @memberof ApiErrorError
     */
    http_code?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiErrorError
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    caption?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    kind?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Asset
     */
    external?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    position?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Asset
     */
    primary?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    sub_kind?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    extension?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    original_filename?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    size?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    width?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    height?: string;
    /**
     * 
     * @type {AssetTransformCollection}
     * @memberof Asset
     */
    transforms?: AssetTransformCollection;
    /**
     * 
     * @type {TagCollection}
     * @memberof Asset
     */
    tags?: TagCollection;
}
/**
 * 
 * @export
 * @interface AssetCollection
 */
export interface AssetCollection {
    /**
     * 
     * @type {Array<Asset>}
     * @memberof AssetCollection
     */
    data?: Array<Asset>;
}
/**
 * 
 * @export
 * @interface AssetDetachBody
 */
export interface AssetDetachBody {
    /**
     * attributeId => position
     * @type {Array<object>}
     * @memberof AssetDetachBody
     */
    attributes?: Array<object>;
}
/**
 * 
 * @export
 * @interface AssetResponse
 */
export interface AssetResponse {
    /**
     * 
     * @type {Asset}
     * @memberof AssetResponse
     */
    data?: Asset;
}
/**
 * 
 * @export
 * @interface AssetSimple
 */
export interface AssetSimple {
    /**
     * 
     * @type {string}
     * @memberof AssetSimple
     */
    thumbnail_url?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetSimple
     */
    thumbnail?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetSimple
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetSimple
     */
    filename?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetSimple
     */
    path?: string;
}
/**
 * 
 * @export
 * @interface AssetSimpleUploadBody
 */
export interface AssetSimpleUploadBody {
    /**
     * 
     * @type {object}
     * @memberof AssetSimpleUploadBody
     */
    file: object;
}
/**
 * 
 * @export
 * @interface AssetTransform
 */
export interface AssetTransform {
    /**
     * 
     * @type {string}
     * @memberof AssetTransform
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetTransform
     */
    handle?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetTransform
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface AssetTransformCollection
 */
export interface AssetTransformCollection {
    /**
     * 
     * @type {Array<AssetTransform>}
     * @memberof AssetTransformCollection
     */
    data?: Array<AssetTransform>;
    /**
     * 
     * @type {Pagination}
     * @memberof AssetTransformCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface AssetTransformCollectionAllOf
 */
export interface AssetTransformCollectionAllOf {
    /**
     * 
     * @type {Array<AssetTransform>}
     * @memberof AssetTransformCollectionAllOf
     */
    data?: Array<AssetTransform>;
}
/**
 * 
 * @export
 * @interface AssociationGroup
 */
export interface AssociationGroup {
    /**
     * 
     * @type {string}
     * @memberof AssociationGroup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AssociationGroup
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AssociationGroup
     */
    handle?: string;
}
/**
 * 
 * @export
 * @interface AssociationGroupCollection
 */
export interface AssociationGroupCollection {
    /**
     * 
     * @type {Array<AssociationGroup>}
     * @memberof AssociationGroupCollection
     */
    data?: Array<AssociationGroup>;
    /**
     * 
     * @type {Pagination}
     * @memberof AssociationGroupCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface AssociationGroupCollectionAllOf
 */
export interface AssociationGroupCollectionAllOf {
    /**
     * 
     * @type {Array<AssociationGroup>}
     * @memberof AssociationGroupCollectionAllOf
     */
    data?: Array<AssociationGroup>;
}
/**
 * 
 * @export
 * @interface AttachCategoryChannelsBody
 */
export interface AttachCategoryChannelsBody {
    /**
     * 
     * @type {Array<AttachCategoryChannelsBodyChannels>}
     * @memberof AttachCategoryChannelsBody
     */
    channels: Array<AttachCategoryChannelsBodyChannels>;
}
/**
 * 
 * @export
 * @interface AttachCategoryChannelsBodyChannels
 */
export interface AttachCategoryChannelsBodyChannels {
    /**
     * 
     * @type {string}
     * @memberof AttachCategoryChannelsBodyChannels
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AttachCategoryChannelsBodyChannels
     */
    published_at: string;
}
/**
 * 
 * @export
 * @interface AttachCategoryCustomerGroupsBody
 */
export interface AttachCategoryCustomerGroupsBody {
    /**
     * 
     * @type {Array<AttachCategoryCustomerGroupsBodyGroups>}
     * @memberof AttachCategoryCustomerGroupsBody
     */
    groups?: Array<AttachCategoryCustomerGroupsBodyGroups>;
}
/**
 * 
 * @export
 * @interface AttachCategoryCustomerGroupsBodyGroups
 */
export interface AttachCategoryCustomerGroupsBodyGroups {
    /**
     * 
     * @type {string}
     * @memberof AttachCategoryCustomerGroupsBodyGroups
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AttachCategoryCustomerGroupsBodyGroups
     */
    visible?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AttachCategoryCustomerGroupsBodyGroups
     */
    purchasable?: boolean;
}
/**
 * 
 * @export
 * @interface AttachCategoryProductsBody
 */
export interface AttachCategoryProductsBody {
    /**
     * 
     * @type {Array<AttachCategoryProductsBodyProducts>}
     * @memberof AttachCategoryProductsBody
     */
    products?: Array<AttachCategoryProductsBodyProducts>;
    /**
     * custom, min_price:asc, min_price:desc, sku:asc, sku:desc
     * @type {string}
     * @memberof AttachCategoryProductsBody
     */
    sort_type?: string;
}
/**
 * 
 * @export
 * @interface AttachCategoryProductsBodyProducts
 */
export interface AttachCategoryProductsBodyProducts {
    /**
     * 
     * @type {string}
     * @memberof AttachCategoryProductsBodyProducts
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachCategoryProductsBodyProducts
     */
    position?: number;
}
/**
 * 
 * @export
 * @interface AttachCategoryRoutesBody
 */
export interface AttachCategoryRoutesBody {
    /**
     * 
     * @type {boolean}
     * @memberof AttachCategoryRoutesBody
     */
    redirect?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AttachCategoryRoutesBody
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachCategoryRoutesBody
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachCategoryRoutesBody
     */
    locale?: string;
}
/**
 * 
 * @export
 * @interface AttachCustomerToGroupBody
 */
export interface AttachCustomerToGroupBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof AttachCustomerToGroupBody
     */
    customer_group_ids?: Array<string>;
}
/**
 * ### Available includes - group
 * @export
 * @interface Attribute
 */
export interface Attribute {
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    id?: string;
    /**
     * 
     * @type {object}
     * @memberof Attribute
     */
    name?: object;
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    handle?: string;
    /**
     * 
     * @type {number}
     * @memberof Attribute
     */
    position?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Attribute
     */
    filterable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Attribute
     */
    scopeable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Attribute
     */
    translatable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Attribute
     */
    variant?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Attribute
     */
    searchable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Attribute
     */
    localised?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Attribute
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Attribute
     */
    required?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof Attribute
     */
    lookups?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof Attribute
     */
    system?: boolean;
    /**
     * 
     * @type {AttributeGroupResponse}
     * @memberof Attribute
     */
    group?: AttributeGroupResponse;
}
/**
 * 
 * @export
 * @interface AttributeCollection
 */
export interface AttributeCollection {
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof AttributeCollection
     */
    data?: Array<Attribute>;
    /**
     * 
     * @type {Pagination}
     * @memberof AttributeCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface AttributeCollectionAllOf
 */
export interface AttributeCollectionAllOf {
    /**
     * 
     * @type {Array<Attribute>}
     * @memberof AttributeCollectionAllOf
     */
    data?: Array<Attribute>;
}
/**
 * 
 * @export
 * @interface AttributeData
 */
export interface AttributeData {
    /**
     * 
     * @type {object}
     * @memberof AttributeData
     */
    attribute_data?: object;
}
/**
 * ### Available includes - attributes
 * @export
 * @interface AttributeGroup
 */
export interface AttributeGroup {
    /**
     * 
     * @type {string}
     * @memberof AttributeGroup
     */
    id?: string;
    /**
     * 
     * @type {object}
     * @memberof AttributeGroup
     */
    name?: object;
    /**
     * 
     * @type {string}
     * @memberof AttributeGroup
     */
    handle?: string;
    /**
     * 
     * @type {number}
     * @memberof AttributeGroup
     */
    position?: number;
    /**
     * 
     * @type {AttributeCollection}
     * @memberof AttributeGroup
     */
    attributes?: AttributeCollection;
}
/**
 * 
 * @export
 * @interface AttributeGroupCollection
 */
export interface AttributeGroupCollection {
    /**
     * 
     * @type {Array<AttributeGroup>}
     * @memberof AttributeGroupCollection
     */
    data?: Array<AttributeGroup>;
    /**
     * 
     * @type {Pagination}
     * @memberof AttributeGroupCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface AttributeGroupCollectionAllOf
 */
export interface AttributeGroupCollectionAllOf {
    /**
     * 
     * @type {Array<AttributeGroup>}
     * @memberof AttributeGroupCollectionAllOf
     */
    data?: Array<AttributeGroup>;
}
/**
 * 
 * @export
 * @interface AttributeGroupOrderUnprocessableResponse
 */
export interface AttributeGroupOrderUnprocessableResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof AttributeGroupOrderUnprocessableResponse
     */
    attributes?: Array<string>;
}
/**
 * 
 * @export
 * @interface AttributeGroupReorderBody
 */
export interface AttributeGroupReorderBody {
    /**
     * 
     * @type {Array<AttributesReorderBodyGroups>}
     * @memberof AttributeGroupReorderBody
     */
    groups?: Array<AttributesReorderBodyGroups>;
}
/**
 * 
 * @export
 * @interface AttributeGroupResponse
 */
export interface AttributeGroupResponse {
    /**
     * 
     * @type {AttributeGroup}
     * @memberof AttributeGroupResponse
     */
    data?: AttributeGroup;
}
/**
 * 
 * @export
 * @interface AttributeResponse
 */
export interface AttributeResponse {
    /**
     * 
     * @type {Attribute}
     * @memberof AttributeResponse
     */
    data?: Attribute;
}
/**
 * 
 * @export
 * @interface AttributesLookups
 */
export interface AttributesLookups {
    /**
     * 
     * @type {string}
     * @memberof AttributesLookups
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesLookups
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface AttributesName
 */
export interface AttributesName {
    /**
     * 
     * @type {string}
     * @memberof AttributesName
     */
    locale: string;
}
/**
 * 
 * @export
 * @interface AttributesReorderBody
 */
export interface AttributesReorderBody {
    /**
     * 
     * @type {Array<AttributesReorderBodyGroups>}
     * @memberof AttributesReorderBody
     */
    groups?: Array<AttributesReorderBodyGroups>;
}
/**
 * 
 * @export
 * @interface AttributesReorderBodyGroups
 */
export interface AttributesReorderBodyGroups {
    /**
     * 
     * @type {number}
     * @memberof AttributesReorderBodyGroups
     */
    groupId?: number;
}
/**
 * 
 * @export
 * @interface Basket
 */
export interface Basket {
    /**
     * 
     * @type {string}
     * @memberof Basket
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof Basket
     */
    total?: number;
    /**
     * 
     * @type {number}
     * @memberof Basket
     */
    sub_total?: number;
    /**
     * 
     * @type {number}
     * @memberof Basket
     */
    tax_total?: number;
    /**
     * 
     * @type {number}
     * @memberof Basket
     */
    discount_total?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Basket
     */
    changed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Basket
     */
    has_exclusions?: boolean;
    /**
     * 
     * @type {object}
     * @memberof Basket
     */
    meta?: object;
    /**
     * 
     * @type {BasketLines}
     * @memberof Basket
     */
    lines?: BasketLines;
    /**
     * 
     * @type {OrderResponse}
     * @memberof Basket
     */
    order?: OrderResponse;
}
/**
 * 
 * @export
 * @interface BasketCollection
 */
export interface BasketCollection {
    /**
     * 
     * @type {Array<Basket>}
     * @memberof BasketCollection
     */
    data?: Array<Basket>;
    /**
     * 
     * @type {Pagination}
     * @memberof BasketCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface BasketCollectionAllOf
 */
export interface BasketCollectionAllOf {
    /**
     * 
     * @type {Array<Basket>}
     * @memberof BasketCollectionAllOf
     */
    data?: Array<Basket>;
}
/**
 * 
 * @export
 * @interface BasketLine
 */
export interface BasketLine {
    /**
     * 
     * @type {string}
     * @memberof BasketLine
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof BasketLine
     */
    quantity?: number;
    /**
     * 
     * @type {number}
     * @memberof BasketLine
     */
    line_total?: number;
    /**
     * 
     * @type {number}
     * @memberof BasketLine
     */
    unit_price?: number;
    /**
     * 
     * @type {number}
     * @memberof BasketLine
     */
    unit_tax?: number;
    /**
     * 
     * @type {number}
     * @memberof BasketLine
     */
    line_discount?: number;
    /**
     * 
     * @type {number}
     * @memberof BasketLine
     */
    tax?: number;
}
/**
 * 
 * @export
 * @interface BasketLineUpdateBody
 */
export interface BasketLineUpdateBody {
    /**
     * 
     * @type {number}
     * @memberof BasketLineUpdateBody
     */
    quantity?: number;
}
/**
 * 
 * @export
 * @interface BasketLines
 */
export interface BasketLines {
    /**
     * 
     * @type {Array<BasketLine>}
     * @memberof BasketLines
     */
    data?: Array<BasketLine>;
}
/**
 * 
 * @export
 * @interface BasketResponse
 */
export interface BasketResponse {
    /**
     * 
     * @type {Basket}
     * @memberof BasketResponse
     */
    data?: Basket;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    sort?: string;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    products_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    children_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    left_pos?: number;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    right_pos?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name?: string;
    /**
     * 
     * @type {object}
     * @memberof Category
     */
    attribute_data?: object;
    /**
     * 
     * @type {CategoryCollection}
     * @memberof Category
     */
    children?: CategoryCollection;
    /**
     * 
     * @type {ChannelCollection}
     * @memberof Category
     */
    channels?: ChannelCollection;
    /**
     * 
     * @type {CategoryCollection}
     * @memberof Category
     */
    ancestors?: CategoryCollection;
    /**
     * 
     * @type {RouteCollection}
     * @memberof Category
     */
    routes?: RouteCollection;
    /**
     * 
     * @type {LayoutResponse}
     * @memberof Category
     */
    layout?: LayoutResponse;
    /**
     * 
     * @type {AssetCollection}
     * @memberof Category
     */
    assets?: AssetCollection;
    /**
     * 
     * @type {AssetResponse}
     * @memberof Category
     */
    primary_asset?: AssetResponse;
    /**
     * 
     * @type {AttributeCollection}
     * @memberof Category
     */
    attributes?: AttributeCollection;
    /**
     * 
     * @type {CustomerGroupCollection}
     * @memberof Category
     */
    customer_groups?: CustomerGroupCollection;
    /**
     * 
     * @type {ProductCollection}
     * @memberof Category
     */
    products?: ProductCollection;
}
/**
 * 
 * @export
 * @interface CategoryAttachLayoutBody
 */
export interface CategoryAttachLayoutBody {
    /**
     * 
     * @type {string}
     * @memberof CategoryAttachLayoutBody
     */
    layout_id?: string;
}
/**
 * 
 * @export
 * @interface CategoryCollection
 */
export interface CategoryCollection {
    /**
     * 
     * @type {Array<Category>}
     * @memberof CategoryCollection
     */
    data?: Array<Category>;
    /**
     * 
     * @type {Pagination}
     * @memberof CategoryCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface CategoryCollectionAllOf
 */
export interface CategoryCollectionAllOf {
    /**
     * 
     * @type {Array<Category>}
     * @memberof CategoryCollectionAllOf
     */
    data?: Array<Category>;
}
/**
 * 
 * @export
 * @interface CategoryResponse
 */
export interface CategoryResponse {
    /**
     * 
     * @type {Category}
     * @memberof CategoryResponse
     */
    data?: Category;
}
/**
 * ## Available includes  - products - categories - collections - discounts - shippingMethods
 * @export
 * @interface Channel
 */
export interface Channel {
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    handle?: string;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Channel
     */
    _default?: boolean;
}
/**
 * 
 * @export
 * @interface ChannelCollection
 */
export interface ChannelCollection {
    /**
     * 
     * @type {Array<Channel>}
     * @memberof ChannelCollection
     */
    data?: Array<Channel>;
    /**
     * 
     * @type {Pagination}
     * @memberof ChannelCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface ChannelCollectionAllOf
 */
export interface ChannelCollectionAllOf {
    /**
     * 
     * @type {Array<Channel>}
     * @memberof ChannelCollectionAllOf
     */
    data?: Array<Channel>;
}
/**
 * 
 * @export
 * @interface ChannelCollectionAllOf1
 */
export interface ChannelCollectionAllOf1 {
    /**
     * 
     * @type {Pagination}
     * @memberof ChannelCollectionAllOf1
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface ChannelResponse
 */
export interface ChannelResponse {
    /**
     * 
     * @type {Channel}
     * @memberof ChannelResponse
     */
    data?: Channel;
}
/**
 * ### Available includes  - routes - layout - channels - assets - attributes - products - customerGroups
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    id?: string;
    /**
     * 
     * @type {object}
     * @memberof Collection
     */
    attribute_data?: object;
    /**
     * 
     * @type {RouteCollection}
     * @memberof Collection
     */
    routes?: RouteCollection;
    /**
     * 
     * @type {LayoutResponse}
     * @memberof Collection
     */
    layout?: LayoutResponse;
    /**
     * 
     * @type {ChannelCollection}
     * @memberof Collection
     */
    channels?: ChannelCollection;
    /**
     * 
     * @type {AssetCollection}
     * @memberof Collection
     */
    assets?: AssetCollection;
    /**
     * 
     * @type {AttributeCollection}
     * @memberof Collection
     */
    attributes?: AttributeCollection;
    /**
     * 
     * @type {ProductCollection}
     * @memberof Collection
     */
    products?: ProductCollection;
    /**
     * 
     * @type {CustomerGroupCollection}
     * @memberof Collection
     */
    customer_groups?: CustomerGroupCollection;
}
/**
 * 
 * @export
 * @interface CollectionCollection
 */
export interface CollectionCollection {
    /**
     * 
     * @type {Array<Collection>}
     * @memberof CollectionCollection
     */
    data?: Array<Collection>;
    /**
     * 
     * @type {Pagination}
     * @memberof CollectionCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface CollectionCollectionAllOf
 */
export interface CollectionCollectionAllOf {
    /**
     * 
     * @type {Array<Collection>}
     * @memberof CollectionCollectionAllOf
     */
    data?: Array<Collection>;
}
/**
 * 
 * @export
 * @interface CollectionResponse
 */
export interface CollectionResponse {
    /**
     * 
     * @type {Collection}
     * @memberof CollectionResponse
     */
    data?: Collection;
}
/**
 * 
 * @export
 * @interface CollectionsName
 */
export interface CollectionsName {
    /**
     * 
     * @type {string}
     * @memberof CollectionsName
     */
    en?: string;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    iso_a_2?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    iso_a_3?: string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    iso_numeric?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Country
     */
    preferred?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Country
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @interface CountryCollection
 */
export interface CountryCollection {
    /**
     * 
     * @type {Array<Country>}
     * @memberof CountryCollection
     */
    data?: Array<Country>;
    /**
     * 
     * @type {Pagination}
     * @memberof CountryCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface CountryCollectionAllOf
 */
export interface CountryCollectionAllOf {
    /**
     * 
     * @type {Array<Country>}
     * @memberof CountryCollectionAllOf
     */
    data?: Array<Country>;
}
/**
 * 
 * @export
 * @interface CountryResponse
 */
export interface CountryResponse {
    /**
     * 
     * @type {Country}
     * @memberof CountryResponse
     */
    data?: Country;
}
/**
 * 
 * @export
 * @interface CreateAddressBody
 */
export interface CreateAddressBody {
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    salutation?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    firstname: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    lastname: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    company_name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    address: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    address_two?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    address_three?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    postal_code: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    country_id: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAddressBody
     */
    shipping?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    user_id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAddressBody
     */
    billing?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAddressBody
     */
    _default?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    last_used_at?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAddressBody
     */
    delivery_instructions?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof CreateAddressBody
     */
    meta?: Array<object>;
}
/**
 * 
 * @export
 * @interface CreateAssetBody
 */
export interface CreateAssetBody {
    /**
     * Required when passing url
     * @type {string}
     * @memberof CreateAssetBody
     */
    mime_type?: string;
    /**
     * External URL to file to upload, required without file
     * @type {string}
     * @memberof CreateAssetBody
     */
    url?: string;
    /**
     * 
     * @type {object}
     * @memberof CreateAssetBody
     */
    file?: object;
}
/**
 * 
 * @export
 * @interface CreateAttributeGroupBody
 */
export interface CreateAttributeGroupBody {
    /**
     * 
     * @type {CreateAttributeGroupBodyName}
     * @memberof CreateAttributeGroupBody
     */
    name?: CreateAttributeGroupBodyName;
}
/**
 * 
 * @export
 * @interface CreateAttributeGroupBodyName
 */
export interface CreateAttributeGroupBodyName {
    /**
     * 
     * @type {CreateAttributeGroupBodyNameEn}
     * @memberof CreateAttributeGroupBodyName
     */
    en: CreateAttributeGroupBodyNameEn;
}
/**
 * 
 * @export
 * @interface CreateAttributeGroupBodyNameEn
 */
export interface CreateAttributeGroupBodyNameEn {
    /**
     * 
     * @type {string}
     * @memberof CreateAttributeGroupBodyNameEn
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CreateBasketLinesBody
 */
export interface CreateBasketLinesBody {
    /**
     * 
     * @type {Array<CreateBasketLinesBodyVariants>}
     * @memberof CreateBasketLinesBody
     */
    variants?: Array<CreateBasketLinesBodyVariants>;
    /**
     * 
     * @type {string}
     * @memberof CreateBasketLinesBody
     */
    basket_id?: string;
}
/**
 * 
 * @export
 * @interface CreateBasketLinesBodyVariants
 */
export interface CreateBasketLinesBodyVariants {
    /**
     * 
     * @type {string}
     * @memberof CreateBasketLinesBodyVariants
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateBasketLinesBodyVariants
     */
    quantity?: number;
    /**
     * 
     * @type {object}
     * @memberof CreateBasketLinesBodyVariants
     */
    meta?: object;
}
/**
 * 
 * @export
 * @interface CreateCategoryBody
 */
export interface CreateCategoryBody {
    /**
     * 
     * @type {string}
     * @memberof CreateCategoryBody
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCategoryBody
     */
    path: string;
    /**
     * 
     * @type {ShippingShippingMethodIdName}
     * @memberof CreateCategoryBody
     */
    name: ShippingShippingMethodIdName;
}
/**
 * 
 * @export
 * @interface CreateChannelBody
 */
export interface CreateChannelBody {
    /**
     * 
     * @type {string}
     * @memberof CreateChannelBody
     */
    handle?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateChannelBody
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateChannelBody
     */
    url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateChannelBody
     */
    _default?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateCustomerBody
 */
export interface CreateCustomerBody {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerBody
     */
    firstname?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerBody
     */
    lastname?: string | null;
    /**
     * 
     * @type {number}
     * @memberof CreateCustomerBody
     */
    contact_number?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CreateCustomerBody
     */
    alt_contact_number?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerBody
     */
    company_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerBody
     */
    vat_no?: string | null;
    /**
     * 
     * @type {object}
     * @memberof CreateCustomerBody
     */
    fields?: object | null;
}
/**
 * 
 * @export
 * @interface CreateCustomerGroupBody
 */
export interface CreateCustomerGroupBody {
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerGroupBody
     */
    handle?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomerGroupBody
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomerGroupBody
     */
    _default?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomerGroupBody
     */
    system?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateLanguageBody
 */
export interface CreateLanguageBody {
    /**
     * 
     * @type {string}
     * @memberof CreateLanguageBody
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateLanguageBody
     */
    lang: string;
    /**
     * Unique
     * @type {string}
     * @memberof CreateLanguageBody
     */
    iso: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateLanguageBody
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateLanguageBody
     */
    _default?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateLanguageBody
     */
    current?: boolean;
}
/**
 * 
 * @export
 * @interface CreateOrderBody
 */
export interface CreateOrderBody {
    /**
     * 
     * @type {string}
     * @memberof CreateOrderBody
     */
    basket_id: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrderBody
     */
    include?: string;
}
/**
 * 
 * @export
 * @interface CreateUserBody
 */
export interface CreateUserBody {
    /**
     * 
     * @type {string}
     * @memberof CreateUserBody
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserBody
     */
    firstname?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserBody
     */
    lastname?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserBody
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserBody
     */
    password_confirmation?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserBody
     */
    customer_id?: string;
}
/**
 * 
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    firstname?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    lastname?: string | null;
    /**
     * 
     * @type {string | number}
     * @memberof Customer
     */
    contact_number?: string | number | null;
    /**
     * 
     * @type {string | number}
     * @memberof Customer
     */
    alt_contact_number?: string | number | null;
    /**
     * 
     * @type {string}
     * @memberof Customer
     */
    company_name?: string | null;
    /**
     * 
     * @type {string | number}
     * @memberof Customer
     */
    vat_no?: string | number | null;
    /**
     * 
     * @type {object}
     * @memberof Customer
     */
    fields?: object | null;
}
/**
 * 
 * @export
 * @interface CustomerCollection
 */
export interface CustomerCollection {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomerCollection
     */
    data?: Array<Customer>;
    /**
     * 
     * @type {Pagination}
     * @memberof CustomerCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface CustomerCollectionAllOf
 */
export interface CustomerCollectionAllOf {
    /**
     * 
     * @type {Array<Customer>}
     * @memberof CustomerCollectionAllOf
     */
    data?: Array<Customer>;
}
/**
 * 
 * @export
 * @interface CustomerFields
 */
export interface CustomerFields {
    /**
     * 
     * @type {object}
     * @memberof CustomerFields
     */
    fields?: object;
}
/**
 * 
 * @export
 * @interface CustomerFieldsResponse
 */
export interface CustomerFieldsResponse {
    /**
     * 
     * @type {CustomerFields}
     * @memberof CustomerFieldsResponse
     */
    data?: CustomerFields;
}
/**
 * 
 * @export
 * @interface CustomerGroup
 */
export interface CustomerGroup {
    /**
     * 
     * @type {string}
     * @memberof CustomerGroup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerGroup
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerGroup
     */
    handle?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerGroup
     */
    _default?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerGroup
     */
    system?: boolean;
}
/**
 * 
 * @export
 * @interface CustomerGroupCollection
 */
export interface CustomerGroupCollection {
    /**
     * 
     * @type {Array<CustomerGroup>}
     * @memberof CustomerGroupCollection
     */
    data?: Array<CustomerGroup>;
    /**
     * 
     * @type {Pagination}
     * @memberof CustomerGroupCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface CustomerGroupCollectionAllOf
 */
export interface CustomerGroupCollectionAllOf {
    /**
     * 
     * @type {Array<CustomerGroup>}
     * @memberof CustomerGroupCollectionAllOf
     */
    data?: Array<CustomerGroup>;
}
/**
 * 
 * @export
 * @interface CustomerGroupResponse
 */
export interface CustomerGroupResponse {
    /**
     * 
     * @type {CustomerGroup}
     * @memberof CustomerGroupResponse
     */
    data?: CustomerGroup;
}
/**
 * 
 * @export
 * @interface CustomerPrice
 */
export interface CustomerPrice {
    /**
     * 
     * @type {string}
     * @memberof CustomerPrice
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerPrice
     */
    price?: number;
    /**
     * 
     * @type {TaxResponse}
     * @memberof CustomerPrice
     */
    tax?: TaxResponse;
    /**
     * 
     * @type {CustomerGroupResponse}
     * @memberof CustomerPrice
     */
    group?: CustomerGroupResponse;
}
/**
 * 
 * @export
 * @interface CustomerResponse
 */
export interface CustomerResponse {
    /**
     * 
     * @type {Customer}
     * @memberof CustomerResponse
     */
    data?: Customer;
}
/**
 * ###Â Available includes - sets - rewards - items
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    start_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    end_at?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Discount
     */
    priority?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Discount
     */
    status?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Discount
     */
    stop_rules?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Discount
     */
    uses?: number;
}
/**
 * 
 * @export
 * @interface DiscountCollection
 */
export interface DiscountCollection {
    /**
     * 
     * @type {Array<Discount>}
     * @memberof DiscountCollection
     */
    data?: Array<Discount>;
    /**
     * 
     * @type {Pagination}
     * @memberof DiscountCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface DiscountCollectionAllOf
 */
export interface DiscountCollectionAllOf {
    /**
     * 
     * @type {Array<Discount>}
     * @memberof DiscountCollectionAllOf
     */
    data?: Array<Discount>;
}
/**
 * 
 * @export
 * @interface DiscountResponse
 */
export interface DiscountResponse {
    /**
     * 
     * @type {Discount}
     * @memberof DiscountResponse
     */
    data?: Discount;
}
/**
 * 
 * @export
 * @interface DiscountsChannels
 */
export interface DiscountsChannels {
    /**
     * 
     * @type {string}
     * @memberof DiscountsChannels
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof DiscountsChannels
     */
    published_at?: string;
}
/**
 * 
 * @export
 * @interface DiscountsDiscountIdChannels
 */
export interface DiscountsDiscountIdChannels {
    /**
     * 
     * @type {DiscountsDiscountIdChannelsData}
     * @memberof DiscountsDiscountIdChannels
     */
    data?: DiscountsDiscountIdChannelsData;
}
/**
 * 
 * @export
 * @interface DiscountsDiscountIdChannelsData
 */
export interface DiscountsDiscountIdChannelsData {
    /**
     * 
     * @type {string}
     * @memberof DiscountsDiscountIdChannelsData
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DiscountsDiscountIdChannelsData
     */
    published_at?: string;
}
/**
 * 
 * @export
 * @interface DiscountsDiscountIdRewards
 */
export interface DiscountsDiscountIdRewards {
    /**
     * 
     * @type {DiscountsDiscountIdRewardsData}
     * @memberof DiscountsDiscountIdRewards
     */
    data?: DiscountsDiscountIdRewardsData;
}
/**
 * 
 * @export
 * @interface DiscountsDiscountIdRewardsData
 */
export interface DiscountsDiscountIdRewardsData {
    /**
     * 
     * @type {Array<DiscountsDiscountIdRewardsDataProducts>}
     * @memberof DiscountsDiscountIdRewardsData
     */
    products?: Array<DiscountsDiscountIdRewardsDataProducts>;
}
/**
 * 
 * @export
 * @interface DiscountsDiscountIdRewardsDataProducts
 */
export interface DiscountsDiscountIdRewardsDataProducts {
    /**
     * 
     * @type {string}
     * @memberof DiscountsDiscountIdRewardsDataProducts
     */
    product_id?: string;
    /**
     * 
     * @type {number}
     * @memberof DiscountsDiscountIdRewardsDataProducts
     */
    quantity?: number;
}
/**
 * 
 * @export
 * @interface DiscountsDiscountIdSets
 */
export interface DiscountsDiscountIdSets {
    /**
     * 
     * @type {Array<DiscountsDiscountIdSetsData>}
     * @memberof DiscountsDiscountIdSets
     */
    data?: Array<DiscountsDiscountIdSetsData>;
}
/**
 * 
 * @export
 * @interface DiscountsDiscountIdSetsData
 */
export interface DiscountsDiscountIdSetsData {
    /**
     * 
     * @type {string}
     * @memberof DiscountsDiscountIdSetsData
     */
    scope?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DiscountsDiscountIdSetsData
     */
    outcome?: boolean;
    /**
     * 
     * @type {DiscountsDiscountIdSetsItems}
     * @memberof DiscountsDiscountIdSetsData
     */
    items?: DiscountsDiscountIdSetsItems;
}
/**
 * 
 * @export
 * @interface DiscountsDiscountIdSetsItems
 */
export interface DiscountsDiscountIdSetsItems {
    /**
     * 
     * @type {Array<DiscountsDiscountIdSetsItemsData>}
     * @memberof DiscountsDiscountIdSetsItems
     */
    data?: Array<DiscountsDiscountIdSetsItemsData>;
}
/**
 * 
 * @export
 * @interface DiscountsDiscountIdSetsItemsData
 */
export interface DiscountsDiscountIdSetsItemsData {
    /**
     * 
     * @type {Array<string>}
     * @memberof DiscountsDiscountIdSetsItemsData
     */
    eligibles?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DiscountsDiscountIdSetsItemsData
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface DiscountsName
 */
export interface DiscountsName {
    /**
     * 
     * @type {string}
     * @memberof DiscountsName
     */
    en?: string;
}
/**
 * 
 * @export
 * @interface EmailPreview
 */
export interface EmailPreview {
    /**
     * 
     * @type {string}
     * @memberof EmailPreview
     */
    subject?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailPreview
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface EmailPreviewResponse
 */
export interface EmailPreviewResponse {
    /**
     * 
     * @type {EmailPreview}
     * @memberof EmailPreviewResponse
     */
    data?: EmailPreview;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject1
     */
    tracking_no?: string;
    /**
     * Corresponds to status set in config
     * @type {string}
     * @memberof InlineObject1
     */
    status?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject1
     */
    send_emails?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject10
     */
    slug?: string;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * An array of attribute IDs
     * @type {Array<string>}
     * @memberof InlineObject11
     */
    attributes: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * An array of collection IDs to associate
     * @type {Array<string>}
     * @memberof InlineObject12
     */
    collections: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * Array of category ID\'s
     * @type {Array<string>}
     * @memberof InlineObject13
     */
    categories: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * Array of channel ID\'s
     * @type {Array<string>}
     * @memberof InlineObject14
     */
    channels: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {ProductsProductIdAssociationsRelations}
     * @memberof InlineObject15
     */
    relations?: ProductsProductIdAssociationsRelations;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {Array<ProductsProductIdCustomerGroupsGroups>}
     * @memberof InlineObject16
     */
    groups: Array<ProductsProductIdCustomerGroupsGroups>;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    group_id: string;
    /**
     * 
     * @type {Array<AttributesName>}
     * @memberof InlineObject17
     */
    name: Array<AttributesName>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    handle: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject17
     */
    position?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject17
     */
    filterable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject17
     */
    scopeable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject17
     */
    translatable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject17
     */
    variant?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject17
     */
    searchable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject17
     */
    localised?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject17
     */
    required?: boolean;
    /**
     * 
     * @type {Array<AttributesLookups>}
     * @memberof InlineObject17
     */
    lookups?: Array<AttributesLookups>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject17
     */
    system?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * Unique name
     * @type {string}
     * @memberof InlineObject18
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject18
     */
    percentage: number;
}
/**
 * 
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * Must be unique
     * @type {string}
     * @memberof InlineObject19
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject19
     */
    percentage: number;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    payment_type_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    payment_type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    order_id: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    payment_token: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    customer_reference?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof InlineObject2
     */
    meta?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject2
     */
    company_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject20
     */
    redirect?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    locale?: string;
}
/**
 * 
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
    /**
     * Pass all products you wish to be associated.
     * @type {Array<string>}
     * @memberof InlineObject21
     */
    products?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
    /**
     * 
     * @type {CollectionsName}
     * @memberof InlineObject22
     */
    name?: CollectionsName;
    /**
     * 
     * @type {string}
     * @memberof InlineObject22
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
    /**
     * 
     * @type {CollectionsName}
     * @memberof InlineObject23
     */
    name?: CollectionsName;
}
/**
 * 
 * @export
 * @interface InlineObject24
 */
export interface InlineObject24 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject24
     */
    start_at?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject24
     */
    end_at?: string;
    /**
     * 
     * @type {DiscountsName}
     * @memberof InlineObject24
     */
    name: DiscountsName;
    /**
     * 
     * @type {number}
     * @memberof InlineObject24
     */
    uses?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject24
     */
    status?: boolean;
    /**
     * 
     * @type {Array<DiscountsChannels>}
     * @memberof InlineObject24
     */
    channels?: Array<DiscountsChannels>;
}
/**
 * 
 * @export
 * @interface InlineObject25
 */
export interface InlineObject25 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject25
     */
    start_at: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject25
     */
    end_at?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject25
     */
    priority?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject25
     */
    stop_rules?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject25
     */
    status?: boolean;
    /**
     * 
     * @type {DiscountsDiscountIdChannels}
     * @memberof InlineObject25
     */
    channels?: DiscountsDiscountIdChannels;
    /**
     * 
     * @type {DiscountsDiscountIdRewards}
     * @memberof InlineObject25
     */
    rewards?: DiscountsDiscountIdRewards;
    /**
     * 
     * @type {DiscountsDiscountIdSets}
     * @memberof InlineObject25
     */
    sets?: DiscountsDiscountIdSets;
}
/**
 * 
 * @export
 * @interface InlineObject26
 */
export interface InlineObject26 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject26
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject26
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject26
     */
    password_confirmation?: string;
}
/**
 * 
 * @export
 * @interface InlineObject27
 */
export interface InlineObject27 {
    /**
     * If left blank, the full amount will be refunded
     * @type {number}
     * @memberof InlineObject27
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject27
     */
    notes?: string;
}
/**
 * 
 * @export
 * @interface InlineObject28
 */
export interface InlineObject28 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject28
     */
    paRes: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject28
     */
    transaction: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject28
     */
    order_id: string;
}
/**
 * 
 * @export
 * @interface InlineObject29
 */
export interface InlineObject29 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject29
     */
    type: InlineObject29TypeEnum;
    /**
     * 
     * @type {CollectionsName}
     * @memberof InlineObject29
     */
    name?: CollectionsName;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject29TypeEnum {
    Standard = 'standard',
    Dhl = 'dhl',
    Regional = 'regional'
}

/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject3
     */
    orders: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    field: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject3
     */
    value?: string;
    /**
     * Whether to send any mailers when changing status
     * @type {boolean}
     * @memberof InlineObject3
     */
    send_emails?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject30
 */
export interface InlineObject30 {
    /**
     * 
     * @type {ShippingShippingMethodIdName}
     * @memberof InlineObject30
     */
    name: ShippingShippingMethodIdName;
    /**
     * 
     * @type {string}
     * @memberof InlineObject30
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InlineObject31
 */
export interface InlineObject31 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject31
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineObject32
 */
export interface InlineObject32 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject32
     */
    rate: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject32
     */
    zone_id: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject32
     */
    currency_id: string;
}
/**
 * 
 * @export
 * @interface InlineObject33
 */
export interface InlineObject33 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject33
     */
    rate: number;
    /**
     * 
     * @type {string}
     * @memberof InlineObject33
     */
    zone_id: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject33
     */
    currency_id: string;
}
/**
 * 
 * @export
 * @interface InlineObject34
 */
export interface InlineObject34 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject34
     */
    zones: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject35
 */
export interface InlineObject35 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject35
     */
    users?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject36
 */
export interface InlineObject36 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject36
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineObject37
 */
export interface InlineObject37 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject37
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject4
     */
    price_id?: string;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    phone?: string;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    quantity: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    line_total: number;
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    unit_price: number;
    /**
     * The tax rate as a percentage
     * @type {number}
     * @memberof InlineObject6
     */
    tax_rate: number;
    /**
     * Shows publicly on the order line
     * @type {string}
     * @memberof InlineObject6
     */
    description: string;
    /**
     * Should this line be treated as a manual one
     * @type {boolean}
     * @memberof InlineObject6
     */
    is_manual?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject6
     */
    is_shipping?: boolean;
    /**
     * If this is a variant, list the option name here
     * @type {string}
     * @memberof InlineObject6
     */
    option?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject6
     */
    sku: string;
    /**
     * 
     * @type {number}
     * @memberof InlineObject6
     */
    discount_total?: number;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * 
     * @type {number}
     * @memberof InlineObject7
     */
    inventory?: number;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * 
     * @type {Array<ProductsProductIdDuplicateRoutes>}
     * @memberof InlineObject8
     */
    routes: Array<ProductsProductIdDuplicateRoutes>;
    /**
     * 
     * @type {Array<ProductsProductIdDuplicateRoutes>}
     * @memberof InlineObject8
     */
    skus: Array<ProductsProductIdDuplicateRoutes>;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject9
     */
    slug?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {BasketResponse}
     * @memberof InlineResponse200
     */
    data?: BasketResponse;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse2001
     */
    labels?: Array<string>;
    /**
     * 
     * @type {Array<InlineResponse2001Datasets>}
     * @memberof InlineResponse2001
     */
    datasets?: Array<InlineResponse2001Datasets>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001Datasets
 */
export interface InlineResponse2001Datasets {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Datasets
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Datasets
     */
    backgroundColor?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Datasets
     */
    yAxisId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001Datasets
     */
    borderColor?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse2001Datasets
     */
    data?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2001Datasets
     */
    fill?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    month?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    sub_total?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    delivery_total?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    tax_total?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    order_total?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    discount_total?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {InlineResponse2003202003}
     * @memberof InlineResponse2003
     */
    _202003?: InlineResponse2003202003;
}
/**
 * 
 * @export
 * @interface InlineResponse2003202003
 */
export interface InlineResponse2003202003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003202003
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003202003
     */
    _new?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003202003
     */
    returning?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003202003
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    sub_total?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    delivery_total?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    tax_total?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    order_total?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    discount_total?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {InlineResponse2005Date}
     * @memberof InlineResponse2005
     */
    date?: InlineResponse2005Date;
}
/**
 * 
 * @export
 * @interface InlineResponse2005Date
 */
export interface InlineResponse2005Date {
    /**
     * 
     * @type {Array<InlineResponse2005DateProducts>}
     * @memberof InlineResponse2005Date
     */
    products?: Array<InlineResponse2005DateProducts>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005DateProducts
 */
export interface InlineResponse2005DateProducts {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005DateProducts
     */
    product_count?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005DateProducts
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005DateProducts
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005DateProducts
     */
    month?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    current_month?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    previous_month?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    today?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    yesterday?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    current_week?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    previous_week?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {ShippingMethod}
     * @memberof InlineResponse2007
     */
    data?: ShippingMethod;
}
/**
 * 
 * @export
 * @interface InlineResponse404
 */
export interface InlineResponse404 {
    /**
     * 
     * @type {Order}
     * @memberof InlineResponse404
     */
    data?: Order;
}

/**
 * 
 * @export
 * @interface InlineResponse422
 */
export interface InlineResponse422 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse422
     */
    id?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse4221
 */
export interface InlineResponse4221 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4221
     */
    orders?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4221
     */
    field?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4221
     */
    value?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse42210
 */
export interface InlineResponse42210 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse42210
     */
    name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse42210
     */
    type?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse42211
 */
export interface InlineResponse42211 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse42211
     */
    rate?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse42211
     */
    zone_id?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse42211
     */
    currency_id?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse42212
 */
export interface InlineResponse42212 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse42212
     */
    users?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse4222
 */
export interface InlineResponse4222 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4222
     */
    price_id?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse4223
 */
export interface InlineResponse4223 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4223
     */
    quantity?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4223
     */
    line_total?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4223
     */
    unit_price?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4223
     */
    tax_rate?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4223
     */
    description?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse4224
 */
export interface InlineResponse4224 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4224
     */
    attributes?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse4225
 */
export interface InlineResponse4225 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4225
     */
    collections?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse4226
 */
export interface InlineResponse4226 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4226
     */
    group_id?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4226
     */
    name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4226
     */
    handle?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse4227
 */
export interface InlineResponse4227 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4227
     */
    name?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse4228
 */
export interface InlineResponse4228 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4228
     */
    name?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4228
     */
    percentage?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineResponse4229
 */
export interface InlineResponse4229 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4229
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponse4229Errors>}
     * @memberof InlineResponse4229
     */
    errors?: Array<InlineResponse4229Errors>;
}
/**
 * 
 * @export
 * @interface InlineResponse4229Errors
 */
export interface InlineResponse4229Errors {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4229Errors
     */
    from?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse4229Errors
     */
    to?: Array<string>;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    encoding?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface InvoiceResponse
 */
export interface InvoiceResponse {
    /**
     * 
     * @type {Invoice}
     * @memberof InvoiceResponse
     */
    data?: Invoice;
}
/**
 * 
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    iso?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    lang?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    _default?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Language
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @interface LanguageCollection
 */
export interface LanguageCollection {
    /**
     * 
     * @type {Array<Language>}
     * @memberof LanguageCollection
     */
    data?: Array<Language>;
    /**
     * 
     * @type {Pagination}
     * @memberof LanguageCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface LanguageCollectionAllOf
 */
export interface LanguageCollectionAllOf {
    /**
     * 
     * @type {Array<Language>}
     * @memberof LanguageCollectionAllOf
     */
    data?: Array<Language>;
}
/**
 * 
 * @export
 * @interface LanguageResponse
 */
export interface LanguageResponse {
    /**
     * 
     * @type {Language}
     * @memberof LanguageResponse
     */
    data?: Language;
}
/**
 * 
 * @export
 * @interface Layout
 */
export interface Layout {
    /**
     * 
     * @type {string}
     * @memberof Layout
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Layout
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Layout
     */
    handle: string;
    /**
     * 
     * @type {string}
     * @memberof Layout
     */
    type: string;
}
/**
 * 
 * @export
 * @interface LayoutCollection
 */
export interface LayoutCollection {
    /**
     * 
     * @type {Array<Layout>}
     * @memberof LayoutCollection
     */
    data?: Array<Layout>;
    /**
     * 
     * @type {Pagination}
     * @memberof LayoutCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface LayoutCollectionAllOf
 */
export interface LayoutCollectionAllOf {
    /**
     * 
     * @type {Array<Layout>}
     * @memberof LayoutCollectionAllOf
     */
    data?: Array<Layout>;
}
/**
 * 
 * @export
 * @interface LayoutResponse
 */
export interface LayoutResponse {
    /**
     * 
     * @type {Layout}
     * @memberof LayoutResponse
     */
    data?: Layout;
}
/**
 * 
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    first?: string;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    last?: string;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    prev?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Links
     */
    next?: string | null;
}
/**
 * 
 * @export
 * @interface LocalisedAttributeData
 */
export interface LocalisedAttributeData {
    /**
     * 
     * @type {string}
     * @memberof LocalisedAttributeData
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof LocalisedAttributeData
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    display_id?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    sub_total?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    delivery_total?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    discount_total?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    tax_total?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    shipping_preference?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    shipping_method?: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    order_total?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    reference?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    customer_reference?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    invoice_reference?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    vat_no?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    tracking_no?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    dispatched_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    customer_name?: string;
    /**
     * 
     * @type {OrderContactDetails}
     * @memberof Order
     */
    contact_details?: OrderContactDetails;
    /**
     * 
     * @type {Address}
     * @memberof Order
     */
    billing_details?: Address;
    /**
     * 
     * @type {Address}
     * @memberof Order
     */
    shipping_details?: Address;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    notes?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof Order
     */
    meta?: Array<object>;
    /**
     * 
     * @type {BasketResponse}
     * @memberof Order
     */
    basket?: BasketResponse;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    discounts?: string;
    /**
     * 
     * @type {TransactionCollection}
     * @memberof Order
     */
    transactions?: TransactionCollection;
    /**
     * 
     * @type {OrderLineCollection}
     * @memberof Order
     */
    lines?: OrderLineCollection;
    /**
     * 
     * @type {OrderLineResponse}
     * @memberof Order
     */
    shipping?: OrderLineResponse;
    /**
     * 
     * @type {ActivityLogCollection}
     * @memberof Order
     */
    logs?: ActivityLogCollection;
    /**
     * 
     * @type {UserResponse}
     * @memberof Order
     */
    user?: UserResponse;
}
/**
 * 
 * @export
 * @interface OrderCollection
 */
export interface OrderCollection {
    /**
     * 
     * @type {Array<Order>}
     * @memberof OrderCollection
     */
    data?: Array<Order>;
    /**
     * 
     * @type {Pagination}
     * @memberof OrderCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface OrderCollectionAllOf
 */
export interface OrderCollectionAllOf {
    /**
     * 
     * @type {Array<Order>}
     * @memberof OrderCollectionAllOf
     */
    data?: Array<Order>;
}
/**
 * 
 * @export
 * @interface OrderContactDetails
 */
export interface OrderContactDetails {
    /**
     * 
     * @type {string}
     * @memberof OrderContactDetails
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderContactDetails
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface OrderExport
 */
export interface OrderExport {
    /**
     * 
     * @type {string}
     * @memberof OrderExport
     */
    format?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderExport
     */
    content?: string;
}
/**
 * 
 * @export
 * @interface OrderExportResponse
 */
export interface OrderExportResponse {
    /**
     * 
     * @type {OrderExport}
     * @memberof OrderExportResponse
     */
    data?: OrderExport;
}
/**
 * 
 * @export
 * @interface OrderLine
 */
export interface OrderLine {
    /**
     * 
     * @type {string}
     * @memberof OrderLine
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    quantity?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    line_total?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    discount_total?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    delivery_total?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    unit_price?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    unit_qty?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    tax_total?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderLine
     */
    tax_rate?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderLine
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderLine
     */
    option?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderLine
     */
    sku?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderLine
     */
    is_shipping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderLine
     */
    is_manual?: boolean;
    /**
     * 
     * @type {object}
     * @memberof OrderLine
     */
    meta?: object;
}
/**
 * 
 * @export
 * @interface OrderLineCollection
 */
export interface OrderLineCollection {
    /**
     * 
     * @type {Array<OrderLine>}
     * @memberof OrderLineCollection
     */
    data?: Array<OrderLine>;
}
/**
 * 
 * @export
 * @interface OrderLineResponse
 */
export interface OrderLineResponse {
    /**
     * 
     * @type {OrderLine}
     * @memberof OrderLineResponse
     */
    data?: OrderLine;
}
/**
 * 
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse {
    /**
     * 
     * @type {Order}
     * @memberof OrderResponse
     */
    data?: Order;
}
/**
 * 
 * @export
 * @interface OrderType
 */
export interface OrderType {
    /**
     * 
     * @type {string}
     * @memberof OrderType
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface OrderTypeCollection
 */
export interface OrderTypeCollection {
    /**
     * 
     * @type {Array<OrderType>}
     * @memberof OrderTypeCollection
     */
    data?: Array<OrderType>;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    current_page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    from?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    last_page?: number;
    /**
     * 
     * @type {string}
     * @memberof Pagination
     */
    path?: string;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    per_page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    to?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    total?: number;
}
/**
 * 
 * @export
 * @interface PaymentProvider
 */
export interface PaymentProvider {
    /**
     * 
     * @type {string}
     * @memberof PaymentProvider
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentProvider
     */
    name?: string;
    /**
     * If supported 
     * @type {string}
     * @memberof PaymentProvider
     */
    client_token?: string;
    /**
     * If supported
     * @type {string}
     * @memberof PaymentProvider
     */
    exires_at?: string;
}
/**
 * 
 * @export
 * @interface PaymentProviderResponse
 */
export interface PaymentProviderResponse {
    /**
     * 
     * @type {PaymentProvider}
     * @memberof PaymentProviderResponse
     */
    data?: PaymentProvider;
}
/**
 * 
 * @export
 * @interface PaymentType
 */
export interface PaymentType {
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    handle?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    driver?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentType
     */
    success_status?: string;
}
/**
 * 
 * @export
 * @interface PaymentTypeCollection
 */
export interface PaymentTypeCollection {
    /**
     * 
     * @type {Array<PaymentType>}
     * @memberof PaymentTypeCollection
     */
    data?: Array<PaymentType>;
    /**
     * 
     * @type {Pagination}
     * @memberof PaymentTypeCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface PaymentTypeCollectionAllOf
 */
export interface PaymentTypeCollectionAllOf {
    /**
     * 
     * @type {Array<PaymentType>}
     * @memberof PaymentTypeCollectionAllOf
     */
    data?: Array<PaymentType>;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    id?: string;
    /**
     * If this product is a draft, this will be populated
     * @type {string}
     * @memberof Product
     */
    drafted_at?: string;
    /**
     * Displays any variant option data
     * @type {object}
     * @memberof Product
     */
    option_data?: object;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface ProductCollection
 */
export interface ProductCollection {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductCollection
     */
    data?: Array<Product>;
    /**
     * 
     * @type {Pagination}
     * @memberof ProductCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface ProductCollectionAllOf
 */
export interface ProductCollectionAllOf {
    /**
     * 
     * @type {Array<Product>}
     * @memberof ProductCollectionAllOf
     */
    data?: Array<Product>;
}
/**
 * 
 * @export
 * @interface ProductCreateBody
 */
export interface ProductCreateBody {
    /**
     * 
     * @type {ShippingShippingMethodIdName}
     * @memberof ProductCreateBody
     */
    name: ShippingShippingMethodIdName;
    /**
     * 
     * @type {string}
     * @memberof ProductCreateBody
     */
    url: string;
    /**
     * 
     * @type {number}
     * @memberof ProductCreateBody
     */
    stock: number;
    /**
     * 
     * @type {string}
     * @memberof ProductCreateBody
     */
    family_id: string;
    /**
     * 
     * @type {number}
     * @memberof ProductCreateBody
     */
    price: number;
    /**
     * 
     * @type {string}
     * @memberof ProductCreateBody
     */
    sku: string;
}
/**
 * 
 * @export
 * @interface ProductFamily
 */
export interface ProductFamily {
    /**
     * 
     * @type {string}
     * @memberof ProductFamily
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductFamily
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ProductFamilyCollection
 */
export interface ProductFamilyCollection {
    /**
     * 
     * @type {Array<ProductFamily>}
     * @memberof ProductFamilyCollection
     */
    data?: Array<ProductFamily>;
    /**
     * 
     * @type {Pagination}
     * @memberof ProductFamilyCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface ProductFamilyCollectionAllOf
 */
export interface ProductFamilyCollectionAllOf {
    /**
     * 
     * @type {Array<ProductFamily>}
     * @memberof ProductFamilyCollectionAllOf
     */
    data?: Array<ProductFamily>;
}
/**
 * 
 * @export
 * @interface ProductFamilyResponse
 */
export interface ProductFamilyResponse {
    /**
     * 
     * @type {ProductFamily}
     * @memberof ProductFamilyResponse
     */
    data?: ProductFamily;
}
/**
 * 
 * @export
 * @interface ProductRecommendation
 */
export interface ProductRecommendation {
    /**
     * 
     * @type {string}
     * @memberof ProductRecommendation
     */
    id?: string;
    /**
     * 
     * @type {ProductResponse}
     * @memberof ProductRecommendation
     */
    product?: ProductResponse;
}
/**
 * 
 * @export
 * @interface ProductRecommendationCollection
 */
export interface ProductRecommendationCollection {
    /**
     * 
     * @type {Array<ProductRecommendation>}
     * @memberof ProductRecommendationCollection
     */
    data?: Array<ProductRecommendation>;
    /**
     * 
     * @type {Pagination}
     * @memberof ProductRecommendationCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface ProductRecommendationCollectionAllOf
 */
export interface ProductRecommendationCollectionAllOf {
    /**
     * 
     * @type {Array<ProductRecommendation>}
     * @memberof ProductRecommendationCollectionAllOf
     */
    data?: Array<ProductRecommendation>;
}
/**
 * 
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * 
     * @type {Product}
     * @memberof ProductResponse
     */
    data?: Product;
}
/**
 * 
 * @export
 * @interface ProductTierPrice
 */
export interface ProductTierPrice {
    /**
     * 
     * @type {string}
     * @memberof ProductTierPrice
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductTierPrice
     */
    lower_limit?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductTierPrice
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductTierPrice
     */
    tax?: number;
    /**
     * 
     * @type {CustomerGroupResponse}
     * @memberof ProductTierPrice
     */
    group?: CustomerGroupResponse;
}
/**
 * 
 * @export
 * @interface ProductTierPriceCollection
 */
export interface ProductTierPriceCollection {
    /**
     * 
     * @type {Array<ProductTierPrice>}
     * @memberof ProductTierPriceCollection
     */
    data?: Array<ProductTierPrice>;
}
/**
 * 
 * @export
 * @interface ProductUpdateBody
 */
export interface ProductUpdateBody {
    /**
     * 
     * @type {object}
     * @memberof ProductUpdateBody
     */
    attribute_data?: object;
    /**
     * 
     * @type {string}
     * @memberof ProductUpdateBody
     */
    family_id?: string;
}
/**
 * ### Available includes  - products - basketLines - image - tax - customerPricing - tiers
 * @export
 * @interface ProductVariant
 */
export interface ProductVariant {
    /**
     * 
     * @type {string}
     * @memberof ProductVariant
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductVariant
     */
    sku?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductVariant
     */
    backorder?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductVariant
     */
    requires_shipping?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    factor_tax?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    unit_price?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    total_tax?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    unit_tax?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    unit_qty?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    min_qty?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    max_qty?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    min_batch?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    inventory?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductVariant
     */
    incoming?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProductVariant
     */
    group_pricing?: boolean;
    /**
     * 
     * @type {ProductVariantWeight}
     * @memberof ProductVariant
     */
    weight?: ProductVariantWeight;
    /**
     * 
     * @type {ProductVariantWeight}
     * @memberof ProductVariant
     */
    height?: ProductVariantWeight;
    /**
     * 
     * @type {ProductVariantWeight}
     * @memberof ProductVariant
     */
    width?: ProductVariantWeight;
    /**
     * 
     * @type {ProductVariantWeight}
     * @memberof ProductVariant
     */
    depth?: ProductVariantWeight;
    /**
     * 
     * @type {ProductVariantWeight}
     * @memberof ProductVariant
     */
    volume?: ProductVariantWeight;
    /**
     * 
     * @type {ProductResponse}
     * @memberof ProductVariant
     */
    product?: ProductResponse;
    /**
     * 
     * @type {AssetResponse}
     * @memberof ProductVariant
     */
    image?: AssetResponse;
    /**
     * 
     * @type {ProductVariantCustomerPricing}
     * @memberof ProductVariant
     */
    customer_pricing?: ProductVariantCustomerPricing;
    /**
     * 
     * @type {TaxResponse}
     * @memberof ProductVariant
     */
    tax?: TaxResponse;
    /**
     * 
     * @type {ProductTierPriceCollection}
     * @memberof ProductVariant
     */
    tiers?: ProductTierPriceCollection;
    /**
     * 
     * @type {object}
     * @memberof ProductVariant
     */
    options?: object;
}
/**
 * 
 * @export
 * @interface ProductVariantCollection
 */
export interface ProductVariantCollection {
    /**
     * 
     * @type {Array<ProductVariant>}
     * @memberof ProductVariantCollection
     */
    data?: Array<ProductVariant>;
    /**
     * 
     * @type {Pagination}
     * @memberof ProductVariantCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface ProductVariantCollectionAllOf
 */
export interface ProductVariantCollectionAllOf {
    /**
     * 
     * @type {Array<ProductVariant>}
     * @memberof ProductVariantCollectionAllOf
     */
    data?: Array<ProductVariant>;
}
/**
 * 
 * @export
 * @interface ProductVariantCustomerPricing
 */
export interface ProductVariantCustomerPricing {
    /**
     * 
     * @type {Array<CustomerPrice>}
     * @memberof ProductVariantCustomerPricing
     */
    data?: Array<CustomerPrice>;
}
/**
 * 
 * @export
 * @interface ProductVariantResponse
 */
export interface ProductVariantResponse {
    /**
     * 
     * @type {ProductVariant}
     * @memberof ProductVariantResponse
     */
    data?: ProductVariant;
}
/**
 * 
 * @export
 * @interface ProductVariantWeight
 */
export interface ProductVariantWeight {
    /**
     * 
     * @type {string}
     * @memberof ProductVariantWeight
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductVariantWeight
     */
    unit?: string;
}
/**
 * 
 * @export
 * @interface ProductsProductIdAssociationsRelations
 */
export interface ProductsProductIdAssociationsRelations {
    /**
     * 
     * @type {string}
     * @memberof ProductsProductIdAssociationsRelations
     */
    association_id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductsProductIdAssociationsRelations
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ProductsProductIdCustomerGroupsGroups
 */
export interface ProductsProductIdCustomerGroupsGroups {
    /**
     * 
     * @type {boolean}
     * @memberof ProductsProductIdCustomerGroupsGroups
     */
    visible: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductsProductIdCustomerGroupsGroups
     */
    purchasable: boolean;
}
/**
 * 
 * @export
 * @interface ProductsProductIdDuplicateRoutes
 */
export interface ProductsProductIdDuplicateRoutes {
    /**
     * 
     * @type {string}
     * @memberof ProductsProductIdDuplicateRoutes
     */
    old?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductsProductIdDuplicateRoutes
     */
    _new?: string;
}
/**
 * 
 * @export
 * @interface RecycleBin
 */
export interface RecycleBin {
    /**
     * 
     * @type {string}
     * @memberof RecycleBin
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RecycleBin
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof RecycleBin
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RecycleBin
     */
    thumbnail?: string;
    /**
     * 
     * @type {string}
     * @memberof RecycleBin
     */
    deleted_at?: string;
    /**
     * 
     * @type {object}
     * @memberof RecycleBin
     */
    recyclable?: object;
}
/**
 * 
 * @export
 * @interface RecycleBinCollection
 */
export interface RecycleBinCollection {
    /**
     * 
     * @type {Array<RecycleBin>}
     * @memberof RecycleBinCollection
     */
    data?: Array<RecycleBin>;
    /**
     * 
     * @type {Pagination}
     * @memberof RecycleBinCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface RecycleBinCollectionAllOf
 */
export interface RecycleBinCollectionAllOf {
    /**
     * 
     * @type {Array<RecycleBin>}
     * @memberof RecycleBinCollectionAllOf
     */
    data?: Array<RecycleBin>;
}
/**
 * 
 * @export
 * @interface RecycleBinResponse
 */
export interface RecycleBinResponse {
    /**
     * 
     * @type {RecycleBin}
     * @memberof RecycleBinResponse
     */
    data?: RecycleBin;
}
/**
 * 
 * @export
 * @interface ReorderCategoryBody
 */
export interface ReorderCategoryBody {
    /**
     * before, after, over
     * @type {string}
     * @memberof ReorderCategoryBody
     */
    action?: string;
    /**
     * The ID of the category which moved
     * @type {string}
     * @memberof ReorderCategoryBody
     */
    moved_node: string;
    /**
     * The id of the category affected
     * @type {string}
     * @memberof ReorderCategoryBody
     */
    node: string;
}
/**
 * 
 * @export
 * @interface RootResponse
 */
export interface RootResponse {
    /**
     * 
     * @type {string}
     * @memberof RootResponse
     */
    version?: string;
    /**
     * 
     * @type {string}
     * @memberof RootResponse
     */
    locale?: string;
    /**
     * 
     * @type {string}
     * @memberof RootResponse
     */
    channel?: string;
    /**
     * 
     * @type {string}
     * @memberof RootResponse
     */
    currency?: string;
}
/**
 * 
 * @export
 * @interface Route
 */
export interface Route {
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    element_type?: string;
    /**
     * 
     * @type {number}
     * @memberof Route
     */
    element_id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Route
     */
    _default?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Route
     */
    redirect?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    path?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    locale?: string;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Route
     */
    drafted_at?: string;
    /**
     * 
     * @type {number}
     * @memberof Route
     */
    draft_parent_id?: number;
}
/**
 * 
 * @export
 * @interface RouteCollection
 */
export interface RouteCollection {
    /**
     * 
     * @type {Array<Route>}
     * @memberof RouteCollection
     */
    data?: Array<Route>;
    /**
     * 
     * @type {Pagination}
     * @memberof RouteCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface RouteCollectionAllOf
 */
export interface RouteCollectionAllOf {
    /**
     * 
     * @type {Array<Route>}
     * @memberof RouteCollectionAllOf
     */
    data?: Array<Route>;
}
/**
 * 
 * @export
 * @interface RouteResponse
 */
export interface RouteResponse {
    /**
     * 
     * @type {Route}
     * @memberof RouteResponse
     */
    data?: Route;
}
/**
 * 
 * @export
 * @interface SaveBasketBody
 */
export interface SaveBasketBody {
    /**
     * 
     * @type {string}
     * @memberof SaveBasketBody
     */
    name: string;
}
/**
 * 
 * @export
 * @interface SavedBasket
 */
export interface SavedBasket {
    /**
     * 
     * @type {string}
     * @memberof SavedBasket
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedBasket
     */
    name?: string;
    /**
     * 
     * @type {BasketResponse}
     * @memberof SavedBasket
     */
    basket?: BasketResponse;
}
/**
 * 
 * @export
 * @interface SavedBasketCollection
 */
export interface SavedBasketCollection {
    /**
     * 
     * @type {Array<SavedBasket>}
     * @memberof SavedBasketCollection
     */
    data?: Array<SavedBasket>;
    /**
     * 
     * @type {Pagination}
     * @memberof SavedBasketCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface SavedBasketCollectionAllOf
 */
export interface SavedBasketCollectionAllOf {
    /**
     * 
     * @type {Array<SavedBasket>}
     * @memberof SavedBasketCollectionAllOf
     */
    data?: Array<SavedBasket>;
}
/**
 * 
 * @export
 * @interface SavedBasketResponse
 */
export interface SavedBasketResponse {
    /**
     * 
     * @type {SavedBasket}
     * @memberof SavedBasketResponse
     */
    data?: SavedBasket;
}
/**
 * 
 * @export
 * @interface SavedSearch
 */
export interface SavedSearch {
    /**
     * 
     * @type {string}
     * @memberof SavedSearch
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedSearch
     */
    name?: string;
    /**
     * 
     * @type {object}
     * @memberof SavedSearch
     */
    payload?: object;
}
/**
 * 
 * @export
 * @interface SavedSearchCollection
 */
export interface SavedSearchCollection extends SavedSearchCollectionAllOf {
}
/**
 * 
 * @export
 * @interface SavedSearchCollectionAllOf
 */
export interface SavedSearchCollectionAllOf {
    /**
     * 
     * @type {Array<SavedSearch>}
     * @memberof SavedSearchCollectionAllOf
     */
    data?: Array<SavedSearch>;
}
/**
 * 
 * @export
 * @interface SavedSearchResponse
 */
export interface SavedSearchResponse {
    /**
     * 
     * @type {SavedSearch}
     * @memberof SavedSearchResponse
     */
    data?: SavedSearch;
}
/**
 * @type Search
 * @export
 */
export type Search = Category | Product;

/**
 * 
 * @export
 * @interface SearchResponse
 */
export interface SearchResponse {
    /**
     * 
     * @type {Array<Search>}
     * @memberof SearchResponse
     */
    data?: Array<Search>;
    /**
     * 
     * @type {Pagination & object}
     * @memberof SearchResponse
     */
    meta?: Pagination & object;
    /**
     * 
     * @type {Links}
     * @memberof SearchResponse
     */
    links?: Links;
}
/**
 * 
 * @export
 * @interface Setting
 */
export interface Setting {
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Setting
     */
    handle?: string;
    /**
     * 
     * @type {object}
     * @memberof Setting
     */
    content?: object;
}
/**
 * 
 * @export
 * @interface SettingCollection
 */
export interface SettingCollection {
    /**
     * 
     * @type {Array<Setting>}
     * @memberof SettingCollection
     */
    data?: Array<Setting>;
}
/**
 * 
 * @export
 * @interface SettingResponse
 */
export interface SettingResponse {
    /**
     * 
     * @type {Setting}
     * @memberof SettingResponse
     */
    data?: Setting;
}
/**
 * 
 * @export
 * @interface ShippingMethod
 */
export interface ShippingMethod {
    /**
     * 
     * @type {string}
     * @memberof ShippingMethod
     */
    type?: string;
    /**
     * 
     * @type {object}
     * @memberof ShippingMethod
     */
    attribute_data?: object;
    /**
     * 
     * @type {string}
     * @memberof ShippingMethod
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingMethod
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ShippingMethodAllOf
 */
export interface ShippingMethodAllOf {
    /**
     * 
     * @type {string}
     * @memberof ShippingMethodAllOf
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ShippingMethodCollection
 */
export interface ShippingMethodCollection {
    /**
     * 
     * @type {Array<ShippingMethod>}
     * @memberof ShippingMethodCollection
     */
    data?: Array<ShippingMethod>;
    /**
     * 
     * @type {Pagination}
     * @memberof ShippingMethodCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface ShippingMethodCollectionAllOf
 */
export interface ShippingMethodCollectionAllOf {
    /**
     * 
     * @type {Array<ShippingMethod>}
     * @memberof ShippingMethodCollectionAllOf
     */
    data?: Array<ShippingMethod>;
}
/**
 * 
 * @export
 * @interface ShippingMethodResponse
 */
export interface ShippingMethodResponse {
    /**
     * 
     * @type {ShippingMethod}
     * @memberof ShippingMethodResponse
     */
    data?: ShippingMethod;
}
/**
 * ###Â Available Includes  - method - zone - currency - customer_groups
 * @export
 * @interface ShippingPrice
 */
export interface ShippingPrice {
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ShippingPrice
     */
    rate?: number;
    /**
     * 
     * @type {number}
     * @memberof ShippingPrice
     */
    tax?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShippingPrice
     */
    fixed?: boolean;
    /**
     * Minimum basket total to be eligible
     * @type {number}
     * @memberof ShippingPrice
     */
    min_basket?: number;
    /**
     * 
     * @type {number}
     * @memberof ShippingPrice
     */
    min_basket_tax?: number;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    min_weight?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    weight_unit?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    min_height?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    height_unit?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    min_width?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    width_unit?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    min_depth?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    depth_unit?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    min_volume?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingPrice
     */
    volume_unit?: string;
    /**
     * 
     * @type {ShippingMethodResponse}
     * @memberof ShippingPrice
     */
    method?: ShippingMethodResponse;
    /**
     * 
     * @type {ShippingZoneResponse}
     * @memberof ShippingPrice
     */
    zone?: ShippingZoneResponse;
}
/**
 * 
 * @export
 * @interface ShippingPriceCollection
 */
export interface ShippingPriceCollection {
    /**
     * 
     * @type {Array<ShippingPrice>}
     * @memberof ShippingPriceCollection
     */
    data?: Array<ShippingPrice>;
}
/**
 * 
 * @export
 * @interface ShippingPriceResponse
 */
export interface ShippingPriceResponse {
    /**
     * 
     * @type {ShippingPrice}
     * @memberof ShippingPriceResponse
     */
    data?: ShippingPrice;
}
/**
 * 
 * @export
 * @interface ShippingShippingMethodIdName
 */
export interface ShippingShippingMethodIdName {
    /**
     * 
     * @type {string}
     * @memberof ShippingShippingMethodIdName
     */
    en: string;
}
/**
 * 
 * @export
 * @interface ShippingZone
 */
export interface ShippingZone {
    /**
     * 
     * @type {string}
     * @memberof ShippingZone
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingZone
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ShippingZoneCollection
 */
export interface ShippingZoneCollection {
    /**
     * 
     * @type {Array<ShippingZone>}
     * @memberof ShippingZoneCollection
     */
    data?: Array<ShippingZone>;
    /**
     * 
     * @type {Pagination}
     * @memberof ShippingZoneCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface ShippingZoneCollectionAllOf
 */
export interface ShippingZoneCollectionAllOf {
    /**
     * 
     * @type {Array<ShippingZone>}
     * @memberof ShippingZoneCollectionAllOf
     */
    data?: Array<ShippingZone>;
}
/**
 * 
 * @export
 * @interface ShippingZoneResponse
 */
export interface ShippingZoneResponse {
    /**
     * 
     * @type {ShippingZone}
     * @memberof ShippingZoneResponse
     */
    data?: ShippingZone;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface TagCollection
 */
export interface TagCollection {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagCollection
     */
    data?: Array<Tag>;
    /**
     * 
     * @type {Pagination}
     * @memberof TagCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface TagCollectionAllOf
 */
export interface TagCollectionAllOf {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagCollectionAllOf
     */
    data?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface TagResponse
 */
export interface TagResponse {
    /**
     * 
     * @type {Tag}
     * @memberof TagResponse
     */
    data?: Tag;
}
/**
 * 
 * @export
 * @interface Tax
 */
export interface Tax {
    /**
     * 
     * @type {string}
     * @memberof Tax
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Tax
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Tax
     */
    percentage?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Tax
     */
    _default?: boolean;
}
/**
 * 
 * @export
 * @interface TaxCollection
 */
export interface TaxCollection {
    /**
     * 
     * @type {Array<Tax>}
     * @memberof TaxCollection
     */
    data?: Array<Tax>;
    /**
     * 
     * @type {Pagination}
     * @memberof TaxCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface TaxCollectionAllOf
 */
export interface TaxCollectionAllOf {
    /**
     * 
     * @type {Array<Tax>}
     * @memberof TaxCollectionAllOf
     */
    data?: Array<Tax>;
}
/**
 * 
 * @export
 * @interface TaxResponse
 */
export interface TaxResponse {
    /**
     * 
     * @type {Tax}
     * @memberof TaxResponse
     */
    data?: Tax;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    transaction_id?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    merchant?: string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    card_type?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    last_four?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    driver?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    success?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    refund?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    address_matched?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    cvc_matched?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    threed_secure?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Transaction
     */
    postcode_matched?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    notes?: string;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface TransactionCollection
 */
export interface TransactionCollection {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof TransactionCollection
     */
    data?: Array<Transaction>;
    /**
     * 
     * @type {Pagination}
     * @memberof TransactionCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface TransactionCollectionAllOf
 */
export interface TransactionCollectionAllOf {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof TransactionCollectionAllOf
     */
    data?: Array<Transaction>;
}
/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * 
     * @type {Transaction}
     * @memberof TransactionResponse
     */
    data?: Transaction;
}
/**
 * 
 * @export
 * @interface Unauthenticated
 */
export interface Unauthenticated {
    /**
     * 
     * @type {string}
     * @memberof Unauthenticated
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface Unauthorized
 */
export interface Unauthorized {
    /**
     * 
     * @type {string}
     * @memberof Unauthorized
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface Unprocessable
 */
export interface Unprocessable {
    /**
     * 
     * @type {string}
     * @memberof Unprocessable
     */
    message?: string;
    /**
     * 
     * @type {object}
     * @memberof Unprocessable
     */
    errors?: object;
}
/**
 * 
 * @export
 * @interface UpdateAddressBody
 */
export interface UpdateAddressBody {
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    salutation?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    firstname?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    lastname?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    company_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    address_two?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    address_three?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    postal_code?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    country_id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAddressBody
     */
    shipping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAddressBody
     */
    billing?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAddressBody
     */
    _default?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    last_used_at?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressBody
     */
    delivery_instructions?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof UpdateAddressBody
     */
    meta?: Array<object>;
}
/**
 * 
 * @export
 * @interface UpdateAssetBody
 */
export interface UpdateAssetBody {
    /**
     * 
     * @type {Array<UpdateAssetBodyAssets>}
     * @memberof UpdateAssetBody
     */
    assets?: Array<UpdateAssetBodyAssets>;
}
/**
 * 
 * @export
 * @interface UpdateAssetBodyAssets
 */
export interface UpdateAssetBodyAssets {
    /**
     * 
     * @type {string}
     * @memberof UpdateAssetBodyAssets
     */
    id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateAssetBodyAssets
     */
    tags?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateAttributesBody
 */
export interface UpdateAttributesBody {
    /**
     * 
     * @type {object}
     * @memberof UpdateAttributesBody
     */
    attributes: object;
}
/**
 * 
 * @export
 * @interface UpdateChannelBody
 */
export interface UpdateChannelBody {
    /**
     * 
     * @type {string}
     * @memberof UpdateChannelBody
     */
    handle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateChannelBody
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateChannelBody
     */
    url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateChannelBody
     */
    _default?: boolean | null;
}
/**
 * 
 * @export
 * @interface UpdateCountryBody
 */
export interface UpdateCountryBody {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCountryBody
     */
    preferred?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCountryBody
     */
    enabled?: boolean | null;
}
/**
 * 
 * @export
 * @interface UpdateCustomerBody
 */
export interface UpdateCustomerBody {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerBody
     */
    firstname?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerBody
     */
    lastname?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateCustomerBody
     */
    contact_number?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateCustomerBody
     */
    alt_contact_number?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerBody
     */
    company_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerBody
     */
    vat_no?: string | null;
    /**
     * 
     * @type {object}
     * @memberof UpdateCustomerBody
     */
    fields?: object | null;
}
/**
 * 
 * @export
 * @interface UpdateCustomerGroupBody
 */
export interface UpdateCustomerGroupBody {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerGroupBody
     */
    handle?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerGroupBody
     */
    name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCustomerGroupBody
     */
    _default?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCustomerGroupBody
     */
    system?: boolean | null;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface UserCollection
 */
export interface UserCollection {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserCollection
     */
    data?: Array<User>;
    /**
     * 
     * @type {Pagination}
     * @memberof UserCollection
     */
    meta?: Pagination;
}
/**
 * 
 * @export
 * @interface UserCollectionAllOf
 */
export interface UserCollectionAllOf {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserCollectionAllOf
     */
    data?: Array<User>;
}
/**
 * 
 * @export
 * @interface UserFields
 */
export interface UserFields {
    /**
     * 
     * @type {object}
     * @memberof UserFields
     */
    fields?: object;
}
/**
 * 
 * @export
 * @interface UserFieldsResponse
 */
export interface UserFieldsResponse {
    /**
     * 
     * @type {UserFields}
     * @memberof UserFieldsResponse
     */
    data?: UserFields;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {User}
     * @memberof UserResponse
     */
    data?: User;
}

/**
 * AddressesApi - axios parameter creator
 * @export
 */
export const AddressesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an existing address
         * @summary 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddressesAddressId: async (addressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            if (addressId === null || addressId === undefined) {
                throw new RequiredError('addressId','Required parameter addressId was null or undefined when calling deleteAddressesAddressId.');
            }
            const localVarPath = `/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to create a new address
         * @summary Create new address
         * @param {string} firstname 
         * @param {string} lastname 
         * @param {string} address 
         * @param {string} city 
         * @param {string} state 
         * @param {string} postalCode 
         * @param {string} countryId 
         * @param {string} [salutation] 
         * @param {string} [companyName] 
         * @param {string} [email] 
         * @param {string} [phone] 
         * @param {string} [addressTwo] 
         * @param {string} [addressThree] 
         * @param {boolean} [shipping] 
         * @param {string} [userId] 
         * @param {boolean} [billing] 
         * @param {boolean} [_default] 
         * @param {string} [lastUsedAt] 
         * @param {string} [deliveryInstructions] 
         * @param {Array<object>} [meta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddresses: async (firstname: string, lastname: string, address: string, city: string, state: string, postalCode: string, countryId: string, salutation?: string, companyName?: string, email?: string, phone?: string, addressTwo?: string, addressThree?: string, shipping?: boolean, userId?: string, billing?: boolean, _default?: boolean, lastUsedAt?: string, deliveryInstructions?: string, meta?: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'firstname' is not null or undefined
            if (firstname === null || firstname === undefined) {
                throw new RequiredError('firstname','Required parameter firstname was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'lastname' is not null or undefined
            if (lastname === null || lastname === undefined) {
                throw new RequiredError('lastname','Required parameter lastname was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new RequiredError('address','Required parameter address was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'city' is not null or undefined
            if (city === null || city === undefined) {
                throw new RequiredError('city','Required parameter city was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new RequiredError('state','Required parameter state was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'postalCode' is not null or undefined
            if (postalCode === null || postalCode === undefined) {
                throw new RequiredError('postalCode','Required parameter postalCode was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'countryId' is not null or undefined
            if (countryId === null || countryId === undefined) {
                throw new RequiredError('countryId','Required parameter countryId was null or undefined when calling postAddresses.');
            }
            const localVarPath = `/addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (salutation !== undefined) { 
                localVarFormParams.append('salutation', salutation as any);
            }
    
            if (firstname !== undefined) { 
                localVarFormParams.append('firstname', firstname as any);
            }
    
            if (lastname !== undefined) { 
                localVarFormParams.append('lastname', lastname as any);
            }
    
            if (companyName !== undefined) { 
                localVarFormParams.append('company_name', companyName as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }
    
            if (phone !== undefined) { 
                localVarFormParams.append('phone', phone as any);
            }
    
            if (address !== undefined) { 
                localVarFormParams.append('address', address as any);
            }
    
            if (addressTwo !== undefined) { 
                localVarFormParams.append('address_two', addressTwo as any);
            }
    
            if (addressThree !== undefined) { 
                localVarFormParams.append('address_three', addressThree as any);
            }
    
            if (city !== undefined) { 
                localVarFormParams.append('city', city as any);
            }
    
            if (state !== undefined) { 
                localVarFormParams.append('state', state as any);
            }
    
            if (postalCode !== undefined) { 
                localVarFormParams.append('postal_code', postalCode as any);
            }
    
            if (countryId !== undefined) { 
                localVarFormParams.append('country_id', countryId as any);
            }
    
            if (shipping !== undefined) { 
                localVarFormParams.append('shipping', shipping as any);
            }
    
            if (userId !== undefined) { 
                localVarFormParams.append('user_id', userId as any);
            }
    
            if (billing !== undefined) { 
                localVarFormParams.append('billing', billing as any);
            }
    
            if (_default !== undefined) { 
                localVarFormParams.append('default', _default as any);
            }
    
            if (lastUsedAt !== undefined) { 
                localVarFormParams.append('last_used_at', lastUsedAt as any);
            }
    
            if (deliveryInstructions !== undefined) { 
                localVarFormParams.append('delivery_instructions', deliveryInstructions as any);
            }
                if (meta) {
            
                localVarFormParams.append('meta', meta.join(COLLECTION_FORMATS.csv));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to update an existing address
         * @summary Update existing address
         * @param {string} addressId 
         * @param {UpdateAddressBody} [updateAddressBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAddresses: async (addressId: string, updateAddressBody?: UpdateAddressBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            if (addressId === null || addressId === undefined) {
                throw new RequiredError('addressId','Required parameter addressId was null or undefined when calling putAddresses.');
            }
            const localVarPath = `/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/javascript';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateAddressBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateAddressBody !== undefined ? updateAddressBody : {}) : (updateAddressBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressesApi - functional programming interface
 * @export
 */
export const AddressesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete an existing address
         * @summary 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAddressesAddressId(addressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AddressesApiAxiosParamCreator(configuration).deleteAddressesAddressId(addressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint allows you to create a new address
         * @summary Create new address
         * @param {string} firstname 
         * @param {string} lastname 
         * @param {string} address 
         * @param {string} city 
         * @param {string} state 
         * @param {string} postalCode 
         * @param {string} countryId 
         * @param {string} [salutation] 
         * @param {string} [companyName] 
         * @param {string} [email] 
         * @param {string} [phone] 
         * @param {string} [addressTwo] 
         * @param {string} [addressThree] 
         * @param {boolean} [shipping] 
         * @param {string} [userId] 
         * @param {boolean} [billing] 
         * @param {boolean} [_default] 
         * @param {string} [lastUsedAt] 
         * @param {string} [deliveryInstructions] 
         * @param {Array<object>} [meta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAddresses(firstname: string, lastname: string, address: string, city: string, state: string, postalCode: string, countryId: string, salutation?: string, companyName?: string, email?: string, phone?: string, addressTwo?: string, addressThree?: string, shipping?: boolean, userId?: string, billing?: boolean, _default?: boolean, lastUsedAt?: string, deliveryInstructions?: string, meta?: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await AddressesApiAxiosParamCreator(configuration).postAddresses(firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, billing, _default, lastUsedAt, deliveryInstructions, meta, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint allows you to update an existing address
         * @summary Update existing address
         * @param {string} addressId 
         * @param {UpdateAddressBody} [updateAddressBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAddresses(addressId: string, updateAddressBody?: UpdateAddressBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressResponse>> {
            const localVarAxiosArgs = await AddressesApiAxiosParamCreator(configuration).putAddresses(addressId, updateAddressBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AddressesApi - factory interface
 * @export
 */
export const AddressesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete an existing address
         * @summary 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddressesAddressId(addressId: string, options?: any): AxiosPromise<void> {
            return AddressesApiFp(configuration).deleteAddressesAddressId(addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to create a new address
         * @summary Create new address
         * @param {string} firstname 
         * @param {string} lastname 
         * @param {string} address 
         * @param {string} city 
         * @param {string} state 
         * @param {string} postalCode 
         * @param {string} countryId 
         * @param {string} [salutation] 
         * @param {string} [companyName] 
         * @param {string} [email] 
         * @param {string} [phone] 
         * @param {string} [addressTwo] 
         * @param {string} [addressThree] 
         * @param {boolean} [shipping] 
         * @param {string} [userId] 
         * @param {boolean} [billing] 
         * @param {boolean} [_default] 
         * @param {string} [lastUsedAt] 
         * @param {string} [deliveryInstructions] 
         * @param {Array<object>} [meta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddresses(firstname: string, lastname: string, address: string, city: string, state: string, postalCode: string, countryId: string, salutation?: string, companyName?: string, email?: string, phone?: string, addressTwo?: string, addressThree?: string, shipping?: boolean, userId?: string, billing?: boolean, _default?: boolean, lastUsedAt?: string, deliveryInstructions?: string, meta?: Array<object>, options?: any): AxiosPromise<AddressResponse> {
            return AddressesApiFp(configuration).postAddresses(firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, billing, _default, lastUsedAt, deliveryInstructions, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to update an existing address
         * @summary Update existing address
         * @param {string} addressId 
         * @param {UpdateAddressBody} [updateAddressBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAddresses(addressId: string, updateAddressBody?: UpdateAddressBody, options?: any): AxiosPromise<AddressResponse> {
            return AddressesApiFp(configuration).putAddresses(addressId, updateAddressBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
export class AddressesApi extends BaseAPI {
    /**
     * Delete an existing address
     * @summary 
     * @param {string} addressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public deleteAddressesAddressId(addressId: string, options?: any) {
        return AddressesApiFp(this.configuration).deleteAddressesAddressId(addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to create a new address
     * @summary Create new address
     * @param {string} firstname 
     * @param {string} lastname 
     * @param {string} address 
     * @param {string} city 
     * @param {string} state 
     * @param {string} postalCode 
     * @param {string} countryId 
     * @param {string} [salutation] 
     * @param {string} [companyName] 
     * @param {string} [email] 
     * @param {string} [phone] 
     * @param {string} [addressTwo] 
     * @param {string} [addressThree] 
     * @param {boolean} [shipping] 
     * @param {string} [userId] 
     * @param {boolean} [billing] 
     * @param {boolean} [_default] 
     * @param {string} [lastUsedAt] 
     * @param {string} [deliveryInstructions] 
     * @param {Array<object>} [meta] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public postAddresses(firstname: string, lastname: string, address: string, city: string, state: string, postalCode: string, countryId: string, salutation?: string, companyName?: string, email?: string, phone?: string, addressTwo?: string, addressThree?: string, shipping?: boolean, userId?: string, billing?: boolean, _default?: boolean, lastUsedAt?: string, deliveryInstructions?: string, meta?: Array<object>, options?: any) {
        return AddressesApiFp(this.configuration).postAddresses(firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, billing, _default, lastUsedAt, deliveryInstructions, meta, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to update an existing address
     * @summary Update existing address
     * @param {string} addressId 
     * @param {UpdateAddressBody} [updateAddressBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    public putAddresses(addressId: string, updateAddressBody?: UpdateAddressBody, options?: any) {
        return AddressesApiFp(this.configuration).putAddresses(addressId, updateAddressBody, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload an asset to a model
         * @summary Create Asset
         * @param {string} [mimeType] Required when passing url
         * @param {string} [url] External URL to file to upload, required without file
         * @param {object} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssets: async (mimeType?: string, url?: string, file?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/assets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (mimeType !== undefined) { 
                localVarFormParams.append('mime_type', mimeType as any);
            }
    
            if (url !== undefined) { 
                localVarFormParams.append('url', url as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches any assets from a given model. Useful if you want to remove certain assets from a product (or another model) without deleting the asset itself.
         * @summary Detach an asset from it\'s model
         * @param {string} assetId The hashed asset id
         * @param {string} ownerId The hashed owner id
         * @param {AssetDetachBody} [assetDetachBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsAssetIdDetachOwnerId: async (assetId: string, ownerId: string, assetDetachBody?: AssetDetachBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new RequiredError('assetId','Required parameter assetId was null or undefined when calling postAssetsAssetIdDetachOwnerId.');
            }
            // verify required parameter 'ownerId' is not null or undefined
            if (ownerId === null || ownerId === undefined) {
                throw new RequiredError('ownerId','Required parameter ownerId was null or undefined when calling postAssetsAssetIdDetachOwnerId.');
            }
            const localVarPath = `/assets/{assetId}/detach/{ownerId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"ownerId"}}`, encodeURIComponent(String(ownerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof assetDetachBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(assetDetachBody !== undefined ? assetDetachBody : {}) : (assetDetachBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows you to upload an asset without having to attach it to a model. This is good for one time uploads where you just want to get back a URL
         * @summary Simple asset upload
         * @param {object} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsSimple: async (file: object, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling postAssetsSimple.');
            }
            const localVarPath = `/assets/simple`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all assets in the given array of ids.
         * @summary Update Assets
         * @param {UpdateAssetBody} [updateAssetBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssets: async (updateAssetBody?: UpdateAssetBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/assets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateAssetBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateAssetBody !== undefined ? updateAssetBody : {}) : (updateAssetBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Upload an asset to a model
         * @summary Create Asset
         * @param {string} [mimeType] Required when passing url
         * @param {string} [url] External URL to file to upload, required without file
         * @param {object} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssets(mimeType?: string, url?: string, file?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponse>> {
            const localVarAxiosArgs = await AssetsApiAxiosParamCreator(configuration).postAssets(mimeType, url, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Detaches any assets from a given model. Useful if you want to remove certain assets from a product (or another model) without deleting the asset itself.
         * @summary Detach an asset from it\'s model
         * @param {string} assetId The hashed asset id
         * @param {string} ownerId The hashed owner id
         * @param {AssetDetachBody} [assetDetachBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssetsAssetIdDetachOwnerId(assetId: string, ownerId: string, assetDetachBody?: AssetDetachBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AssetsApiAxiosParamCreator(configuration).postAssetsAssetIdDetachOwnerId(assetId, ownerId, assetDetachBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint allows you to upload an asset without having to attach it to a model. This is good for one time uploads where you just want to get back a URL
         * @summary Simple asset upload
         * @param {object} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssetsSimple(file: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetSimple>> {
            const localVarAxiosArgs = await AssetsApiAxiosParamCreator(configuration).postAssetsSimple(file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update all assets in the given array of ids.
         * @summary Update Assets
         * @param {UpdateAssetBody} [updateAssetBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAssets(updateAssetBody?: UpdateAssetBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetResponse>> {
            const localVarAxiosArgs = await AssetsApiAxiosParamCreator(configuration).putAssets(updateAssetBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Upload an asset to a model
         * @summary Create Asset
         * @param {string} [mimeType] Required when passing url
         * @param {string} [url] External URL to file to upload, required without file
         * @param {object} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssets(mimeType?: string, url?: string, file?: object, options?: any): AxiosPromise<AssetResponse> {
            return AssetsApiFp(configuration).postAssets(mimeType, url, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches any assets from a given model. Useful if you want to remove certain assets from a product (or another model) without deleting the asset itself.
         * @summary Detach an asset from it\'s model
         * @param {string} assetId The hashed asset id
         * @param {string} ownerId The hashed owner id
         * @param {AssetDetachBody} [assetDetachBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsAssetIdDetachOwnerId(assetId: string, ownerId: string, assetDetachBody?: AssetDetachBody, options?: any): AxiosPromise<void> {
            return AssetsApiFp(configuration).postAssetsAssetIdDetachOwnerId(assetId, ownerId, assetDetachBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to upload an asset without having to attach it to a model. This is good for one time uploads where you just want to get back a URL
         * @summary Simple asset upload
         * @param {object} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsSimple(file: object, options?: any): AxiosPromise<AssetSimple> {
            return AssetsApiFp(configuration).postAssetsSimple(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all assets in the given array of ids.
         * @summary Update Assets
         * @param {UpdateAssetBody} [updateAssetBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssets(updateAssetBody?: UpdateAssetBody, options?: any): AxiosPromise<AssetResponse> {
            return AssetsApiFp(configuration).putAssets(updateAssetBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * Upload an asset to a model
     * @summary Create Asset
     * @param {string} [mimeType] Required when passing url
     * @param {string} [url] External URL to file to upload, required without file
     * @param {object} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public postAssets(mimeType?: string, url?: string, file?: object, options?: any) {
        return AssetsApiFp(this.configuration).postAssets(mimeType, url, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches any assets from a given model. Useful if you want to remove certain assets from a product (or another model) without deleting the asset itself.
     * @summary Detach an asset from it\'s model
     * @param {string} assetId The hashed asset id
     * @param {string} ownerId The hashed owner id
     * @param {AssetDetachBody} [assetDetachBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public postAssetsAssetIdDetachOwnerId(assetId: string, ownerId: string, assetDetachBody?: AssetDetachBody, options?: any) {
        return AssetsApiFp(this.configuration).postAssetsAssetIdDetachOwnerId(assetId, ownerId, assetDetachBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows you to upload an asset without having to attach it to a model. This is good for one time uploads where you just want to get back a URL
     * @summary Simple asset upload
     * @param {object} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public postAssetsSimple(file: object, options?: any) {
        return AssetsApiFp(this.configuration).postAssetsSimple(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all assets in the given array of ids.
     * @summary Update Assets
     * @param {UpdateAssetBody} [updateAssetBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public putAssets(updateAssetBody?: UpdateAssetBody, options?: any) {
        return AssetsApiFp(this.configuration).putAssets(updateAssetBody, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AssociationsApi - axios parameter creator
 * @export
 */
export const AssociationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated response of association groups available in the system
         * @summary Paginated array of association groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssociationsGroups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/associations/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssociationsApi - functional programming interface
 * @export
 */
export const AssociationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a paginated response of association groups available in the system
         * @summary Paginated array of association groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssociationsGroups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssociationGroupCollection>> {
            const localVarAxiosArgs = await AssociationsApiAxiosParamCreator(configuration).getAssociationsGroups(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AssociationsApi - factory interface
 * @export
 */
export const AssociationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a paginated response of association groups available in the system
         * @summary Paginated array of association groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssociationsGroups(options?: any): AxiosPromise<AssociationGroupCollection> {
            return AssociationsApiFp(configuration).getAssociationsGroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssociationsApi - object-oriented interface
 * @export
 * @class AssociationsApi
 * @extends {BaseAPI}
 */
export class AssociationsApi extends BaseAPI {
    /**
     * Returns a paginated response of association groups available in the system
     * @summary Paginated array of association groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssociationsApi
     */
    public getAssociationsGroups(options?: any) {
        return AssociationsApiFp(this.configuration).getAssociationsGroups(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AttributesApi - axios parameter creator
 * @export
 */
export const AttributesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an attribute group
         * @summary Delete an attribute group
         * @param {string} attributeGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributeGroupsAttributeGroupId: async (attributeGroupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeGroupId' is not null or undefined
            if (attributeGroupId === null || attributeGroupId === undefined) {
                throw new RequiredError('attributeGroupId','Required parameter attributeGroupId was null or undefined when calling deleteAttributeGroupsAttributeGroupId.');
            }
            const localVarPath = `/attribute-groups/{attributeGroupId}`
                .replace(`{${"attributeGroupId"}}`, encodeURIComponent(String(attributeGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an attribute.
         * @summary Delete an attribute
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributesAttributeId: async (attributeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            if (attributeId === null || attributeId === undefined) {
                throw new RequiredError('attributeId','Required parameter attributeId was null or undefined when calling deleteAttributesAttributeId.');
            }
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of available attribute groups
         * @summary Paginated list of Attribute Groups
         * @param {boolean} [allRecords] Will skip pagination and return all records
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroups: async (allRecords?: boolean, include?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/attribute-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (allRecords !== undefined) {
                localVarQueryParameter['all_records'] = allRecords;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single attribute group
         * @summary Get a single attribute group
         * @param {string} attributeGroupId 
         * @param {number} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroupsAttributeGroupId: async (attributeGroupId: string, include?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeGroupId' is not null or undefined
            if (attributeGroupId === null || attributeGroupId === undefined) {
                throw new RequiredError('attributeGroupId','Required parameter attributeGroupId was null or undefined when calling getAttributeGroupsAttributeGroupId.');
            }
            const localVarPath = `/attribute-groups/{attributeGroupId}`
                .replace(`{${"attributeGroupId"}}`, encodeURIComponent(String(attributeGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a paged array of attributes
         * @summary Get Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/attributes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an attribute from a given ID.
         * @summary Get an attribute
         * @param {string} attributeId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesAttributeId: async (attributeId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            if (attributeId === null || attributeId === undefined) {
                throw new RequiredError('attributeId','Required parameter attributeId was null or undefined when calling getAttributesAttributeId.');
            }
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an Attribute Group
         * @param {CreateAttributeGroupBodyName} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributeGroups: async (name?: CreateAttributeGroupBodyName, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/attribute-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new attribute
         * @summary Create Attribute
         * @param {InlineObject17} [inlineObject17] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributes: async (inlineObject17?: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/attributes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject17 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject17 !== undefined ? inlineObject17 : {}) : (inlineObject17 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an attribute group.
         * @summary Update an attribute group
         * @param {string} attributeGroupId 
         * @param {AttributeGroup} [attributeGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsAttributeGroupId: async (attributeGroupId: string, attributeGroup?: AttributeGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeGroupId' is not null or undefined
            if (attributeGroupId === null || attributeGroupId === undefined) {
                throw new RequiredError('attributeGroupId','Required parameter attributeGroupId was null or undefined when calling putAttributeGroupsAttributeGroupId.');
            }
            const localVarPath = `/attribute-groups/{attributeGroupId}`
                .replace(`{${"attributeGroupId"}}`, encodeURIComponent(String(attributeGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof attributeGroup !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(attributeGroup !== undefined ? attributeGroup : {}) : (attributeGroup || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a request to reorder the attribute groups in the system
         * @summary Reorder attribute groups
         * @param {AttributeGroupReorderBody} [attributeGroupReorderBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsReorder: async (attributeGroupReorderBody?: AttributeGroupReorderBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/attribute-groups/reorder`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof attributeGroupReorderBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(attributeGroupReorderBody !== undefined ? attributeGroupReorderBody : {}) : (attributeGroupReorderBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an attribute from a given ID.
         * @summary Update an attribute
         * @param {string} attributeId 
         * @param {UpdateAttributesBody} [updateAttributesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesAttributeId: async (attributeId: string, updateAttributesBody?: UpdateAttributesBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'attributeId' is not null or undefined
            if (attributeId === null || attributeId === undefined) {
                throw new RequiredError('attributeId','Required parameter attributeId was null or undefined when calling putAttributesAttributeId.');
            }
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateAttributesBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateAttributesBody !== undefined ? updateAttributesBody : {}) : (updateAttributesBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to reorder a target category in relation to another.
         * @summary Update request to reorder attributes
         * @param {AttributesReorderBody} [attributesReorderBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesOrder: async (attributesReorderBody?: AttributesReorderBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/attributes/order`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof attributesReorderBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(attributesReorderBody !== undefined ? attributesReorderBody : {}) : (attributesReorderBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttributesApi - functional programming interface
 * @export
 */
export const AttributesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes an attribute group
         * @summary Delete an attribute group
         * @param {string} attributeGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttributeGroupsAttributeGroupId(attributeGroupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).deleteAttributeGroupsAttributeGroupId(attributeGroupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an attribute.
         * @summary Delete an attribute
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAttributesAttributeId(attributeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).deleteAttributesAttributeId(attributeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of available attribute groups
         * @summary Paginated list of Attribute Groups
         * @param {boolean} [allRecords] Will skip pagination and return all records
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttributeGroups(allRecords?: boolean, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeGroupCollection>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).getAttributeGroups(allRecords, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a single attribute group
         * @summary Get a single attribute group
         * @param {string} attributeGroupId 
         * @param {number} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttributeGroupsAttributeGroupId(attributeGroupId: string, include?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeGroupResponse>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).getAttributeGroupsAttributeGroupId(attributeGroupId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return a paged array of attributes
         * @summary Get Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttributes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeCollection>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).getAttributes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an attribute from a given ID.
         * @summary Get an attribute
         * @param {string} attributeId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAttributesAttributeId(attributeId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeResponse>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).getAttributesAttributeId(attributeId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create an Attribute Group
         * @param {CreateAttributeGroupBodyName} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAttributeGroups(name?: CreateAttributeGroupBodyName, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeGroupResponse>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).postAttributeGroups(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new attribute
         * @summary Create Attribute
         * @param {InlineObject17} [inlineObject17] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAttributes(inlineObject17?: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeResponse>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).postAttributes(inlineObject17, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an attribute group.
         * @summary Update an attribute group
         * @param {string} attributeGroupId 
         * @param {AttributeGroup} [attributeGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAttributeGroupsAttributeGroupId(attributeGroupId: string, attributeGroup?: AttributeGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeGroupResponse>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).putAttributeGroupsAttributeGroupId(attributeGroupId, attributeGroup, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sends a request to reorder the attribute groups in the system
         * @summary Reorder attribute groups
         * @param {AttributeGroupReorderBody} [attributeGroupReorderBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAttributeGroupsReorder(attributeGroupReorderBody?: AttributeGroupReorderBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).putAttributeGroupsReorder(attributeGroupReorderBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an attribute from a given ID.
         * @summary Update an attribute
         * @param {string} attributeId 
         * @param {UpdateAttributesBody} [updateAttributesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAttributesAttributeId(attributeId: string, updateAttributesBody?: UpdateAttributesBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttributeResponse>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).putAttributesAttributeId(attributeId, updateAttributesBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows you to reorder a target category in relation to another.
         * @summary Update request to reorder attributes
         * @param {AttributesReorderBody} [attributesReorderBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAttributesOrder(attributesReorderBody?: AttributesReorderBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await AttributesApiAxiosParamCreator(configuration).putAttributesOrder(attributesReorderBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AttributesApi - factory interface
 * @export
 */
export const AttributesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes an attribute group
         * @summary Delete an attribute group
         * @param {string} attributeGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributeGroupsAttributeGroupId(attributeGroupId: string, options?: any): AxiosPromise<void> {
            return AttributesApiFp(configuration).deleteAttributeGroupsAttributeGroupId(attributeGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an attribute.
         * @summary Delete an attribute
         * @param {string} attributeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributesAttributeId(attributeId: string, options?: any): AxiosPromise<void> {
            return AttributesApiFp(configuration).deleteAttributesAttributeId(attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of available attribute groups
         * @summary Paginated list of Attribute Groups
         * @param {boolean} [allRecords] Will skip pagination and return all records
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroups(allRecords?: boolean, include?: string, options?: any): AxiosPromise<AttributeGroupCollection> {
            return AttributesApiFp(configuration).getAttributeGroups(allRecords, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a single attribute group
         * @summary Get a single attribute group
         * @param {string} attributeGroupId 
         * @param {number} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroupsAttributeGroupId(attributeGroupId: string, include?: number, options?: any): AxiosPromise<AttributeGroupResponse> {
            return AttributesApiFp(configuration).getAttributeGroupsAttributeGroupId(attributeGroupId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a paged array of attributes
         * @summary Get Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributes(options?: any): AxiosPromise<AttributeCollection> {
            return AttributesApiFp(configuration).getAttributes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an attribute from a given ID.
         * @summary Get an attribute
         * @param {string} attributeId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesAttributeId(attributeId: string, include?: string, options?: any): AxiosPromise<AttributeResponse> {
            return AttributesApiFp(configuration).getAttributesAttributeId(attributeId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an Attribute Group
         * @param {CreateAttributeGroupBodyName} [name] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributeGroups(name?: CreateAttributeGroupBodyName, options?: any): AxiosPromise<AttributeGroupResponse> {
            return AttributesApiFp(configuration).postAttributeGroups(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new attribute
         * @summary Create Attribute
         * @param {InlineObject17} [inlineObject17] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributes(inlineObject17?: InlineObject17, options?: any): AxiosPromise<AttributeResponse> {
            return AttributesApiFp(configuration).postAttributes(inlineObject17, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an attribute group.
         * @summary Update an attribute group
         * @param {string} attributeGroupId 
         * @param {AttributeGroup} [attributeGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsAttributeGroupId(attributeGroupId: string, attributeGroup?: AttributeGroup, options?: any): AxiosPromise<AttributeGroupResponse> {
            return AttributesApiFp(configuration).putAttributeGroupsAttributeGroupId(attributeGroupId, attributeGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a request to reorder the attribute groups in the system
         * @summary Reorder attribute groups
         * @param {AttributeGroupReorderBody} [attributeGroupReorderBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsReorder(attributeGroupReorderBody?: AttributeGroupReorderBody, options?: any): AxiosPromise<void> {
            return AttributesApiFp(configuration).putAttributeGroupsReorder(attributeGroupReorderBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an attribute from a given ID.
         * @summary Update an attribute
         * @param {string} attributeId 
         * @param {UpdateAttributesBody} [updateAttributesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesAttributeId(attributeId: string, updateAttributesBody?: UpdateAttributesBody, options?: any): AxiosPromise<AttributeResponse> {
            return AttributesApiFp(configuration).putAttributesAttributeId(attributeId, updateAttributesBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to reorder a target category in relation to another.
         * @summary Update request to reorder attributes
         * @param {AttributesReorderBody} [attributesReorderBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesOrder(attributesReorderBody?: AttributesReorderBody, options?: any): AxiosPromise<void> {
            return AttributesApiFp(configuration).putAttributesOrder(attributesReorderBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttributesApi - object-oriented interface
 * @export
 * @class AttributesApi
 * @extends {BaseAPI}
 */
export class AttributesApi extends BaseAPI {
    /**
     * Deletes an attribute group
     * @summary Delete an attribute group
     * @param {string} attributeGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public deleteAttributeGroupsAttributeGroupId(attributeGroupId: string, options?: any) {
        return AttributesApiFp(this.configuration).deleteAttributeGroupsAttributeGroupId(attributeGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an attribute.
     * @summary Delete an attribute
     * @param {string} attributeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public deleteAttributesAttributeId(attributeId: string, options?: any) {
        return AttributesApiFp(this.configuration).deleteAttributesAttributeId(attributeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of available attribute groups
     * @summary Paginated list of Attribute Groups
     * @param {boolean} [allRecords] Will skip pagination and return all records
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public getAttributeGroups(allRecords?: boolean, include?: string, options?: any) {
        return AttributesApiFp(this.configuration).getAttributeGroups(allRecords, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a single attribute group
     * @summary Get a single attribute group
     * @param {string} attributeGroupId 
     * @param {number} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public getAttributeGroupsAttributeGroupId(attributeGroupId: string, include?: number, options?: any) {
        return AttributesApiFp(this.configuration).getAttributeGroupsAttributeGroupId(attributeGroupId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a paged array of attributes
     * @summary Get Attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public getAttributes(options?: any) {
        return AttributesApiFp(this.configuration).getAttributes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an attribute from a given ID.
     * @summary Get an attribute
     * @param {string} attributeId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public getAttributesAttributeId(attributeId: string, include?: string, options?: any) {
        return AttributesApiFp(this.configuration).getAttributesAttributeId(attributeId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an Attribute Group
     * @param {CreateAttributeGroupBodyName} [name] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public postAttributeGroups(name?: CreateAttributeGroupBodyName, options?: any) {
        return AttributesApiFp(this.configuration).postAttributeGroups(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new attribute
     * @summary Create Attribute
     * @param {InlineObject17} [inlineObject17] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public postAttributes(inlineObject17?: InlineObject17, options?: any) {
        return AttributesApiFp(this.configuration).postAttributes(inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an attribute group.
     * @summary Update an attribute group
     * @param {string} attributeGroupId 
     * @param {AttributeGroup} [attributeGroup] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public putAttributeGroupsAttributeGroupId(attributeGroupId: string, attributeGroup?: AttributeGroup, options?: any) {
        return AttributesApiFp(this.configuration).putAttributeGroupsAttributeGroupId(attributeGroupId, attributeGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a request to reorder the attribute groups in the system
     * @summary Reorder attribute groups
     * @param {AttributeGroupReorderBody} [attributeGroupReorderBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public putAttributeGroupsReorder(attributeGroupReorderBody?: AttributeGroupReorderBody, options?: any) {
        return AttributesApiFp(this.configuration).putAttributeGroupsReorder(attributeGroupReorderBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an attribute from a given ID.
     * @summary Update an attribute
     * @param {string} attributeId 
     * @param {UpdateAttributesBody} [updateAttributesBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public putAttributesAttributeId(attributeId: string, updateAttributesBody?: UpdateAttributesBody, options?: any) {
        return AttributesApiFp(this.configuration).putAttributesAttributeId(attributeId, updateAttributesBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to reorder a target category in relation to another.
     * @summary Update request to reorder attributes
     * @param {AttributesReorderBody} [attributesReorderBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    public putAttributesOrder(attributesReorderBody?: AttributesReorderBody, options?: any) {
        return AttributesApiFp(this.configuration).putAttributesOrder(attributesReorderBody, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BasketsApi - axios parameter creator
 * @export
 */
export const BasketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes basket lines from a basket
         * @summary Delete basket lines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketLines: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/basket-lines`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a basket
         * @summary Delete a basket by ID
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketId: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling deleteBasketsBasketId.');
            }
            const localVarPath = `/baskets/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one. 
         * @summary Remove discount
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketIdDiscounts: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling deleteBasketsBasketIdDiscounts.');
            }
            const localVarPath = `/baskets/{basketId}/discounts`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of baskets
         * @summary Get baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaskets: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/baskets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a basket by it\'s ID
         * @summary Get basket
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsBasketId: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling getBasketsBasketId.');
            }
            const localVarPath = `/baskets/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request will get the current active basket for a user
         * @summary Get the current basket for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsCurrent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/baskets/current`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an authenticatd users saved baskets.
         * @summary Get a users saved baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsSaved: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/baskets/saved`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add lines to a basket
         * @summary Create basket lines
         * @param {CreateBasketLinesBody} [createBasketLinesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketLines: async (createBasketLinesBody?: CreateBasketLinesBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/basket-lines`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createBasketLinesBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createBasketLinesBody !== undefined ? createBasketLinesBody : {}) : (createBasketLinesBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A user is able to \"claim\" a guest basket. 
         * @summary Allow a user to claim a basket
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdClaim: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling postBasketsBasketIdClaim.');
            }
            const localVarPath = `/baskets/{basketId}/claim`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to add custom meta information to a basket.
         * @summary Add meta information
         * @param {string} basketId 
         * @param {AddBasketMetaBody} [addBasketMetaBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdMeta: async (basketId: string, addBasketMetaBody?: AddBasketMetaBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling postBasketsBasketIdMeta.');
            }
            const localVarPath = `/baskets/{basketId}/meta`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof addBasketMetaBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(addBasketMetaBody !== undefined ? addBasketMetaBody : {}) : (addBasketMetaBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves a basket to a users account.
         * @summary Save a basket for a user
         * @param {string} basketId 
         * @param {SaveBasketBody} [saveBasketBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdSave: async (basketId: string, saveBasketBody?: SaveBasketBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling postBasketsBasketIdSave.');
            }
            const localVarPath = `/baskets/{basketId}/save`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof saveBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(saveBasketBody !== undefined ? saveBasketBody : {}) : (saveBasketBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
         * @summary Resolve a basket
         * @param {SaveBasketBody} [saveBasketBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsResolve: async (saveBasketBody?: SaveBasketBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/baskets/resolve`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof saveBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(saveBasketBody !== undefined ? saveBasketBody : {}) : (saveBasketBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a basket line based on it\'s ID.
         * @summary Update basket line
         * @param {string} basketLineId 
         * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineId: async (basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketLineId' is not null or undefined
            if (basketLineId === null || basketLineId === undefined) {
                throw new RequiredError('basketLineId','Required parameter basketLineId was null or undefined when calling putBasketLinesBasketLineId.');
            }
            const localVarPath = `/basket-lines/{basketLineId}`
                .replace(`{${"basketLineId"}}`, encodeURIComponent(String(basketLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof basketLineUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(basketLineUpdateBody !== undefined ? basketLineUpdateBody : {}) : (basketLineUpdateBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update basket line quantity
         * @summary Update basket line quantity
         * @param {string} basketLineId 
         * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdAdd: async (basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketLineId' is not null or undefined
            if (basketLineId === null || basketLineId === undefined) {
                throw new RequiredError('basketLineId','Required parameter basketLineId was null or undefined when calling putBasketLinesBasketLineIdAdd.');
            }
            const localVarPath = `/basket-lines/{basketLineId}/add`
                .replace(`{${"basketLineId"}}`, encodeURIComponent(String(basketLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof basketLineUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(basketLineUpdateBody !== undefined ? basketLineUpdateBody : {}) : (basketLineUpdateBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes quantity from a basket line
         * @summary Remove basket line quantity
         * @param {string} basketLineId 
         * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdRemove: async (basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketLineId' is not null or undefined
            if (basketLineId === null || basketLineId === undefined) {
                throw new RequiredError('basketLineId','Required parameter basketLineId was null or undefined when calling putBasketLinesBasketLineIdRemove.');
            }
            const localVarPath = `/basket-lines/{basketLineId}/remove`
                .replace(`{${"basketLineId"}}`, encodeURIComponent(String(basketLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof basketLineUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(basketLineUpdateBody !== undefined ? basketLineUpdateBody : {}) : (basketLineUpdateBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a basket
         * @summary Update a basket by ID
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsBasketId: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling putBasketsBasketId.');
            }
            const localVarPath = `/baskets/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a saved basket on the API
         * @summary Update a saved basket
         * @param {string} basketId 
         * @param {SaveBasketBody} [saveBasketBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsSavedBasketId: async (basketId: string, saveBasketBody?: SaveBasketBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling putBasketsSavedBasketId.');
            }
            const localVarPath = `/baskets/saved/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof saveBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(saveBasketBody !== undefined ? saveBasketBody : {}) : (saveBasketBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasketsApi - functional programming interface
 * @export
 */
export const BasketsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Removes basket lines from a basket
         * @summary Delete basket lines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBasketLines(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).deleteBasketLines(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a basket
         * @summary Delete a basket by ID
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBasketsBasketId(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).deleteBasketsBasketId(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one. 
         * @summary Remove discount
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBasketsBasketIdDiscounts(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).deleteBasketsBasketIdDiscounts(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a paginated list of baskets
         * @summary Get baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBaskets(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketCollection>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).getBaskets(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a basket by it\'s ID
         * @summary Get basket
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasketsBasketId(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).getBasketsBasketId(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This request will get the current active basket for a user
         * @summary Get the current basket for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasketsCurrent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).getBasketsCurrent(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an authenticatd users saved baskets.
         * @summary Get a users saved baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasketsSaved(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedBasketCollection>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).getBasketsSaved(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add lines to a basket
         * @summary Create basket lines
         * @param {CreateBasketLinesBody} [createBasketLinesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketLines(createBasketLinesBody?: CreateBasketLinesBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketLines(createBasketLinesBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * A user is able to \"claim\" a guest basket. 
         * @summary Allow a user to claim a basket
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketsBasketIdClaim(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketsBasketIdClaim(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows you to add custom meta information to a basket.
         * @summary Add meta information
         * @param {string} basketId 
         * @param {AddBasketMetaBody} [addBasketMetaBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketsBasketIdMeta(basketId: string, addBasketMetaBody?: AddBasketMetaBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketsBasketIdMeta(basketId, addBasketMetaBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Saves a basket to a users account.
         * @summary Save a basket for a user
         * @param {string} basketId 
         * @param {SaveBasketBody} [saveBasketBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketsBasketIdSave(basketId: string, saveBasketBody?: SaveBasketBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketsBasketIdSave(basketId, saveBasketBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
         * @summary Resolve a basket
         * @param {SaveBasketBody} [saveBasketBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postBasketsResolve(saveBasketBody?: SaveBasketBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).postBasketsResolve(saveBasketBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a basket line based on it\'s ID.
         * @summary Update basket line
         * @param {string} basketLineId 
         * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketLinesBasketLineId(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update basket line quantity
         * @summary Update basket line quantity
         * @param {string} basketLineId 
         * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketLinesBasketLineIdAdd(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes quantity from a basket line
         * @summary Remove basket line quantity
         * @param {string} basketLineId 
         * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketLinesBasketLineIdRemove(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a basket
         * @summary Update a basket by ID
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketsBasketId(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketsBasketId(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a saved basket on the API
         * @summary Update a saved basket
         * @param {string} basketId 
         * @param {SaveBasketBody} [saveBasketBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putBasketsSavedBasketId(basketId: string, saveBasketBody?: SaveBasketBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedBasketResponse>> {
            const localVarAxiosArgs = await BasketsApiAxiosParamCreator(configuration).putBasketsSavedBasketId(basketId, saveBasketBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BasketsApi - factory interface
 * @export
 */
export const BasketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Removes basket lines from a basket
         * @summary Delete basket lines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketLines(options?: any): AxiosPromise<InlineResponse200> {
            return BasketsApiFp(configuration).deleteBasketLines(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a basket
         * @summary Delete a basket by ID
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketId(basketId: string, options?: any): AxiosPromise<void> {
            return BasketsApiFp(configuration).deleteBasketsBasketId(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one. 
         * @summary Remove discount
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketIdDiscounts(basketId: string, options?: any): AxiosPromise<void> {
            return BasketsApiFp(configuration).deleteBasketsBasketIdDiscounts(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of baskets
         * @summary Get baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaskets(options?: any): AxiosPromise<BasketCollection> {
            return BasketsApiFp(configuration).getBaskets(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a basket by it\'s ID
         * @summary Get basket
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsBasketId(basketId: string, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).getBasketsBasketId(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will get the current active basket for a user
         * @summary Get the current basket for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsCurrent(options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).getBasketsCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an authenticatd users saved baskets.
         * @summary Get a users saved baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsSaved(options?: any): AxiosPromise<SavedBasketCollection> {
            return BasketsApiFp(configuration).getBasketsSaved(options).then((request) => request(axios, basePath));
        },
        /**
         * Add lines to a basket
         * @summary Create basket lines
         * @param {CreateBasketLinesBody} [createBasketLinesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketLines(createBasketLinesBody?: CreateBasketLinesBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketLines(createBasketLinesBody, options).then((request) => request(axios, basePath));
        },
        /**
         * A user is able to \"claim\" a guest basket. 
         * @summary Allow a user to claim a basket
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdClaim(basketId: string, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketsBasketIdClaim(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to add custom meta information to a basket.
         * @summary Add meta information
         * @param {string} basketId 
         * @param {AddBasketMetaBody} [addBasketMetaBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdMeta(basketId: string, addBasketMetaBody?: AddBasketMetaBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketsBasketIdMeta(basketId, addBasketMetaBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves a basket to a users account.
         * @summary Save a basket for a user
         * @param {string} basketId 
         * @param {SaveBasketBody} [saveBasketBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdSave(basketId: string, saveBasketBody?: SaveBasketBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketsBasketIdSave(basketId, saveBasketBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
         * @summary Resolve a basket
         * @param {SaveBasketBody} [saveBasketBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsResolve(saveBasketBody?: SaveBasketBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).postBasketsResolve(saveBasketBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a basket line based on it\'s ID.
         * @summary Update basket line
         * @param {string} basketLineId 
         * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineId(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update basket line quantity
         * @summary Update basket line quantity
         * @param {string} basketLineId 
         * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdAdd(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes quantity from a basket line
         * @summary Remove basket line quantity
         * @param {string} basketLineId 
         * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdRemove(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a basket
         * @summary Update a basket by ID
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsBasketId(basketId: string, options?: any): AxiosPromise<BasketResponse> {
            return BasketsApiFp(configuration).putBasketsBasketId(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a saved basket on the API
         * @summary Update a saved basket
         * @param {string} basketId 
         * @param {SaveBasketBody} [saveBasketBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsSavedBasketId(basketId: string, saveBasketBody?: SaveBasketBody, options?: any): AxiosPromise<SavedBasketResponse> {
            return BasketsApiFp(configuration).putBasketsSavedBasketId(basketId, saveBasketBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BasketsApi - object-oriented interface
 * @export
 * @class BasketsApi
 * @extends {BaseAPI}
 */
export class BasketsApi extends BaseAPI {
    /**
     * Removes basket lines from a basket
     * @summary Delete basket lines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public deleteBasketLines(options?: any) {
        return BasketsApiFp(this.configuration).deleteBasketLines(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a basket
     * @summary Delete a basket by ID
     * @param {string} basketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public deleteBasketsBasketId(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).deleteBasketsBasketId(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one. 
     * @summary Remove discount
     * @param {string} basketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public deleteBasketsBasketIdDiscounts(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).deleteBasketsBasketIdDiscounts(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated list of baskets
     * @summary Get baskets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public getBaskets(options?: any) {
        return BasketsApiFp(this.configuration).getBaskets(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a basket by it\'s ID
     * @summary Get basket
     * @param {string} basketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public getBasketsBasketId(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).getBasketsBasketId(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will get the current active basket for a user
     * @summary Get the current basket for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public getBasketsCurrent(options?: any) {
        return BasketsApiFp(this.configuration).getBasketsCurrent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an authenticatd users saved baskets.
     * @summary Get a users saved baskets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public getBasketsSaved(options?: any) {
        return BasketsApiFp(this.configuration).getBasketsSaved(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add lines to a basket
     * @summary Create basket lines
     * @param {CreateBasketLinesBody} [createBasketLinesBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketLines(createBasketLinesBody?: CreateBasketLinesBody, options?: any) {
        return BasketsApiFp(this.configuration).postBasketLines(createBasketLinesBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A user is able to \"claim\" a guest basket. 
     * @summary Allow a user to claim a basket
     * @param {string} basketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketsBasketIdClaim(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).postBasketsBasketIdClaim(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to add custom meta information to a basket.
     * @summary Add meta information
     * @param {string} basketId 
     * @param {AddBasketMetaBody} [addBasketMetaBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketsBasketIdMeta(basketId: string, addBasketMetaBody?: AddBasketMetaBody, options?: any) {
        return BasketsApiFp(this.configuration).postBasketsBasketIdMeta(basketId, addBasketMetaBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves a basket to a users account.
     * @summary Save a basket for a user
     * @param {string} basketId 
     * @param {SaveBasketBody} [saveBasketBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketsBasketIdSave(basketId: string, saveBasketBody?: SaveBasketBody, options?: any) {
        return BasketsApiFp(this.configuration).postBasketsBasketIdSave(basketId, saveBasketBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
     * @summary Resolve a basket
     * @param {SaveBasketBody} [saveBasketBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public postBasketsResolve(saveBasketBody?: SaveBasketBody, options?: any) {
        return BasketsApiFp(this.configuration).postBasketsResolve(saveBasketBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a basket line based on it\'s ID.
     * @summary Update basket line
     * @param {string} basketLineId 
     * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketLinesBasketLineId(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any) {
        return BasketsApiFp(this.configuration).putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update basket line quantity
     * @summary Update basket line quantity
     * @param {string} basketLineId 
     * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketLinesBasketLineIdAdd(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any) {
        return BasketsApiFp(this.configuration).putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes quantity from a basket line
     * @summary Remove basket line quantity
     * @param {string} basketLineId 
     * @param {BasketLineUpdateBody} [basketLineUpdateBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketLinesBasketLineIdRemove(basketLineId: string, basketLineUpdateBody?: BasketLineUpdateBody, options?: any) {
        return BasketsApiFp(this.configuration).putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a basket
     * @summary Update a basket by ID
     * @param {string} basketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketsBasketId(basketId: string, options?: any) {
        return BasketsApiFp(this.configuration).putBasketsBasketId(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a saved basket on the API
     * @summary Update a saved basket
     * @param {string} basketId 
     * @param {SaveBasketBody} [saveBasketBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    public putBasketsSavedBasketId(basketId: string, saveBasketBody?: SaveBasketBody, options?: any) {
        return BasketsApiFp(this.configuration).putBasketsSavedBasketId(basketId, saveBasketBody, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a paginated resource of categories
         * @summary Get Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single category from a given ID
         * @summary Return a single category
         * @param {string} categoryId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesCategoryId: async (categoryId: string, includes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling getCategoriesCategoryId.');
            }
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns categories by a given parent ID.
         * @summary Get categories by parent id
         * @param {string} parentId If omitted will return top level catgories
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesParentParentId: async (parentId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'parentId' is not null or undefined
            if (parentId === null || parentId === undefined) {
                throw new RequiredError('parentId','Required parameter parentId was null or undefined when calling getCategoriesParentParentId.');
            }
            const localVarPath = `/categories/parent/{parentId}`
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attaches channels to a catagory
         * @summary Attach channels to a category
         * @param {string} categoryId 
         * @param {AttachCategoryChannelsBody} [attachCategoryChannelsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdChannels: async (categoryId: string, attachCategoryChannelsBody?: AttachCategoryChannelsBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling postCategoriesCategoryIdChannels.');
            }
            const localVarPath = `/categories/{categoryId}/channels`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof attachCategoryChannelsBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(attachCategoryChannelsBody !== undefined ? attachCategoryChannelsBody : {}) : (attachCategoryChannelsBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attaches customer groups to a category resource.
         * @summary Attach customer groups to a category
         * @param {string} categoryId 
         * @param {AttachCategoryCustomerGroupsBody} [attachCategoryCustomerGroupsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdCustomerGroups: async (categoryId: string, attachCategoryCustomerGroupsBody?: AttachCategoryCustomerGroupsBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling postCategoriesCategoryIdCustomerGroups.');
            }
            const localVarPath = `/categories/{categoryId}/customer-groups`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof attachCategoryCustomerGroupsBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(attachCategoryCustomerGroupsBody !== undefined ? attachCategoryCustomerGroupsBody : {}) : (attachCategoryCustomerGroupsBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or return the current category draft resource.
         * @summary Create or retrieve the current category draft
         * @param {string} categoryId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdDrafts: async (categoryId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling postCategoriesCategoryIdDrafts.');
            }
            const localVarPath = `/categories/{categoryId}/drafts`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attaches layouts to a category resource
         * @summary Update a category layout
         * @param {string} categoryId 
         * @param {CategoryAttachLayoutBody} [categoryAttachLayoutBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryLayouts: async (categoryId: string, categoryAttachLayoutBody?: CategoryAttachLayoutBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling postCategoriesCategoryLayouts.');
            }
            const localVarPath = `/categories/{categoryId}/layouts`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof categoryAttachLayoutBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(categoryAttachLayoutBody !== undefined ? categoryAttachLayoutBody : {}) : (categoryAttachLayoutBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attaches routes to a category resource.
         * @summary Update a category\'s routes
         * @param {string} categoryId 
         * @param {AttachCategoryRoutesBody} [attachCategoryRoutesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryRoutes: async (categoryId: string, attachCategoryRoutesBody?: AttachCategoryRoutesBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling postCategoriesCategoryRoutes.');
            }
            const localVarPath = `/categories/{categoryId}/routes`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof attachCategoryRoutesBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(attachCategoryRoutesBody !== undefined ? attachCategoryRoutesBody : {}) : (attachCategoryRoutesBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reorder a category
         * @param {ReorderCategoryBody} [reorderCategoryBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesReorder: async (reorderCategoryBody?: ReorderCategoryBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories/reorder`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof reorderCategoryBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(reorderCategoryBody !== undefined ? reorderCategoryBody : {}) : (reorderCategoryBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a category using a given ID.
         * @summary Update a category
         * @param {string} categoryId 
         * @param {CreateCategoryBody} [createCategoryBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryId: async (categoryId: string, createCategoryBody?: CreateCategoryBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling putCategoriesCategoryId.');
            }
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createCategoryBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createCategoryBody !== undefined ? createCategoryBody : {}) : (createCategoryBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attaches products to a category resource.
         * @summary Attach products
         * @param {string} categoryId 
         * @param {AttachCategoryProductsBody} [attachCategoryProductsBody] When using \&quot;custom\&quot; sort type, sorting will be based on the position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryIdProducts: async (categoryId: string, attachCategoryProductsBody?: AttachCategoryProductsBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling putCategoriesCategoryIdProducts.');
            }
            const localVarPath = `/categories/{categoryId}/products`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof attachCategoryProductsBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(attachCategoryProductsBody !== undefined ? attachCategoryProductsBody : {}) : (attachCategoryProductsBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a paginated resource of categories
         * @summary Get Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryCollection>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).getCategories(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single category from a given ID
         * @summary Return a single category
         * @param {string} categoryId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesCategoryId(categoryId: string, includes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).getCategoriesCategoryId(categoryId, includes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns categories by a given parent ID.
         * @summary Get categories by parent id
         * @param {string} parentId If omitted will return top level catgories
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoriesParentParentId(parentId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryCollection>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).getCategoriesParentParentId(parentId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Attaches channels to a catagory
         * @summary Attach channels to a category
         * @param {string} categoryId 
         * @param {AttachCategoryChannelsBody} [attachCategoryChannelsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCategoriesCategoryIdChannels(categoryId: string, attachCategoryChannelsBody?: AttachCategoryChannelsBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryIdChannels(categoryId, attachCategoryChannelsBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Attaches customer groups to a category resource.
         * @summary Attach customer groups to a category
         * @param {string} categoryId 
         * @param {AttachCategoryCustomerGroupsBody} [attachCategoryCustomerGroupsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCategoriesCategoryIdCustomerGroups(categoryId: string, attachCategoryCustomerGroupsBody?: AttachCategoryCustomerGroupsBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryIdCustomerGroups(categoryId, attachCategoryCustomerGroupsBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create or return the current category draft resource.
         * @summary Create or retrieve the current category draft
         * @param {string} categoryId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCategoriesCategoryIdDrafts(categoryId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryIdDrafts(categoryId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Attaches layouts to a category resource
         * @summary Update a category layout
         * @param {string} categoryId 
         * @param {CategoryAttachLayoutBody} [categoryAttachLayoutBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCategoriesCategoryLayouts(categoryId: string, categoryAttachLayoutBody?: CategoryAttachLayoutBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryLayouts(categoryId, categoryAttachLayoutBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Attaches routes to a category resource.
         * @summary Update a category\'s routes
         * @param {string} categoryId 
         * @param {AttachCategoryRoutesBody} [attachCategoryRoutesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCategoriesCategoryRoutes(categoryId: string, attachCategoryRoutesBody?: AttachCategoryRoutesBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryRoutes(categoryId, attachCategoryRoutesBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Reorder a category
         * @param {ReorderCategoryBody} [reorderCategoryBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCategoriesReorder(reorderCategoryBody?: ReorderCategoryBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).postCategoriesReorder(reorderCategoryBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a category using a given ID.
         * @summary Update a category
         * @param {string} categoryId 
         * @param {CreateCategoryBody} [createCategoryBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCategoriesCategoryId(categoryId: string, createCategoryBody?: CreateCategoryBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).putCategoriesCategoryId(categoryId, createCategoryBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Attaches products to a category resource.
         * @summary Attach products
         * @param {string} categoryId 
         * @param {AttachCategoryProductsBody} [attachCategoryProductsBody] When using \&quot;custom\&quot; sort type, sorting will be based on the position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCategoriesCategoryIdProducts(categoryId: string, attachCategoryProductsBody?: AttachCategoryProductsBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await CategoriesApiAxiosParamCreator(configuration).putCategoriesCategoryIdProducts(categoryId, attachCategoryProductsBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a paginated resource of categories
         * @summary Get Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(options?: any): AxiosPromise<CategoryCollection> {
            return CategoriesApiFp(configuration).getCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single category from a given ID
         * @summary Return a single category
         * @param {string} categoryId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesCategoryId(categoryId: string, includes?: string, options?: any): AxiosPromise<CategoryResponse> {
            return CategoriesApiFp(configuration).getCategoriesCategoryId(categoryId, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns categories by a given parent ID.
         * @summary Get categories by parent id
         * @param {string} parentId If omitted will return top level catgories
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesParentParentId(parentId: string, include?: string, options?: any): AxiosPromise<CategoryCollection> {
            return CategoriesApiFp(configuration).getCategoriesParentParentId(parentId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches channels to a catagory
         * @summary Attach channels to a category
         * @param {string} categoryId 
         * @param {AttachCategoryChannelsBody} [attachCategoryChannelsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdChannels(categoryId: string, attachCategoryChannelsBody?: AttachCategoryChannelsBody, options?: any): AxiosPromise<CategoryResponse> {
            return CategoriesApiFp(configuration).postCategoriesCategoryIdChannels(categoryId, attachCategoryChannelsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches customer groups to a category resource.
         * @summary Attach customer groups to a category
         * @param {string} categoryId 
         * @param {AttachCategoryCustomerGroupsBody} [attachCategoryCustomerGroupsBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdCustomerGroups(categoryId: string, attachCategoryCustomerGroupsBody?: AttachCategoryCustomerGroupsBody, options?: any): AxiosPromise<CategoryResponse> {
            return CategoriesApiFp(configuration).postCategoriesCategoryIdCustomerGroups(categoryId, attachCategoryCustomerGroupsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or return the current category draft resource.
         * @summary Create or retrieve the current category draft
         * @param {string} categoryId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdDrafts(categoryId: string, include?: string, options?: any): AxiosPromise<CategoryResponse> {
            return CategoriesApiFp(configuration).postCategoriesCategoryIdDrafts(categoryId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches layouts to a category resource
         * @summary Update a category layout
         * @param {string} categoryId 
         * @param {CategoryAttachLayoutBody} [categoryAttachLayoutBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryLayouts(categoryId: string, categoryAttachLayoutBody?: CategoryAttachLayoutBody, options?: any): AxiosPromise<CategoryResponse> {
            return CategoriesApiFp(configuration).postCategoriesCategoryLayouts(categoryId, categoryAttachLayoutBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches routes to a category resource.
         * @summary Update a category\'s routes
         * @param {string} categoryId 
         * @param {AttachCategoryRoutesBody} [attachCategoryRoutesBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryRoutes(categoryId: string, attachCategoryRoutesBody?: AttachCategoryRoutesBody, options?: any): AxiosPromise<CategoryResponse> {
            return CategoriesApiFp(configuration).postCategoriesCategoryRoutes(categoryId, attachCategoryRoutesBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reorder a category
         * @param {ReorderCategoryBody} [reorderCategoryBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesReorder(reorderCategoryBody?: ReorderCategoryBody, options?: any): AxiosPromise<Message> {
            return CategoriesApiFp(configuration).postCategoriesReorder(reorderCategoryBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a category using a given ID.
         * @summary Update a category
         * @param {string} categoryId 
         * @param {CreateCategoryBody} [createCategoryBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryId(categoryId: string, createCategoryBody?: CreateCategoryBody, options?: any): AxiosPromise<CategoryResponse> {
            return CategoriesApiFp(configuration).putCategoriesCategoryId(categoryId, createCategoryBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches products to a category resource.
         * @summary Attach products
         * @param {string} categoryId 
         * @param {AttachCategoryProductsBody} [attachCategoryProductsBody] When using \&quot;custom\&quot; sort type, sorting will be based on the position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryIdProducts(categoryId: string, attachCategoryProductsBody?: AttachCategoryProductsBody, options?: any): AxiosPromise<CategoryResponse> {
            return CategoriesApiFp(configuration).putCategoriesCategoryIdProducts(categoryId, attachCategoryProductsBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Returns a paginated resource of categories
     * @summary Get Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategories(options?: any) {
        return CategoriesApiFp(this.configuration).getCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single category from a given ID
     * @summary Return a single category
     * @param {string} categoryId 
     * @param {string} [includes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategoriesCategoryId(categoryId: string, includes?: string, options?: any) {
        return CategoriesApiFp(this.configuration).getCategoriesCategoryId(categoryId, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns categories by a given parent ID.
     * @summary Get categories by parent id
     * @param {string} parentId If omitted will return top level catgories
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategoriesParentParentId(parentId: string, include?: string, options?: any) {
        return CategoriesApiFp(this.configuration).getCategoriesParentParentId(parentId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attaches channels to a catagory
     * @summary Attach channels to a category
     * @param {string} categoryId 
     * @param {AttachCategoryChannelsBody} [attachCategoryChannelsBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public postCategoriesCategoryIdChannels(categoryId: string, attachCategoryChannelsBody?: AttachCategoryChannelsBody, options?: any) {
        return CategoriesApiFp(this.configuration).postCategoriesCategoryIdChannels(categoryId, attachCategoryChannelsBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attaches customer groups to a category resource.
     * @summary Attach customer groups to a category
     * @param {string} categoryId 
     * @param {AttachCategoryCustomerGroupsBody} [attachCategoryCustomerGroupsBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public postCategoriesCategoryIdCustomerGroups(categoryId: string, attachCategoryCustomerGroupsBody?: AttachCategoryCustomerGroupsBody, options?: any) {
        return CategoriesApiFp(this.configuration).postCategoriesCategoryIdCustomerGroups(categoryId, attachCategoryCustomerGroupsBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or return the current category draft resource.
     * @summary Create or retrieve the current category draft
     * @param {string} categoryId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public postCategoriesCategoryIdDrafts(categoryId: string, include?: string, options?: any) {
        return CategoriesApiFp(this.configuration).postCategoriesCategoryIdDrafts(categoryId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attaches layouts to a category resource
     * @summary Update a category layout
     * @param {string} categoryId 
     * @param {CategoryAttachLayoutBody} [categoryAttachLayoutBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public postCategoriesCategoryLayouts(categoryId: string, categoryAttachLayoutBody?: CategoryAttachLayoutBody, options?: any) {
        return CategoriesApiFp(this.configuration).postCategoriesCategoryLayouts(categoryId, categoryAttachLayoutBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attaches routes to a category resource.
     * @summary Update a category\'s routes
     * @param {string} categoryId 
     * @param {AttachCategoryRoutesBody} [attachCategoryRoutesBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public postCategoriesCategoryRoutes(categoryId: string, attachCategoryRoutesBody?: AttachCategoryRoutesBody, options?: any) {
        return CategoriesApiFp(this.configuration).postCategoriesCategoryRoutes(categoryId, attachCategoryRoutesBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reorder a category
     * @param {ReorderCategoryBody} [reorderCategoryBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public postCategoriesReorder(reorderCategoryBody?: ReorderCategoryBody, options?: any) {
        return CategoriesApiFp(this.configuration).postCategoriesReorder(reorderCategoryBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a category using a given ID.
     * @summary Update a category
     * @param {string} categoryId 
     * @param {CreateCategoryBody} [createCategoryBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public putCategoriesCategoryId(categoryId: string, createCategoryBody?: CreateCategoryBody, options?: any) {
        return CategoriesApiFp(this.configuration).putCategoriesCategoryId(categoryId, createCategoryBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attaches products to a category resource.
     * @summary Attach products
     * @param {string} categoryId 
     * @param {AttachCategoryProductsBody} [attachCategoryProductsBody] When using \&quot;custom\&quot; sort type, sorting will be based on the position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public putCategoriesCategoryIdProducts(categoryId: string, attachCategoryProductsBody?: AttachCategoryProductsBody, options?: any) {
        return CategoriesApiFp(this.configuration).putCategoriesCategoryIdProducts(categoryId, attachCategoryProductsBody, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ChannelsApi - axios parameter creator
 * @export
 */
export const ChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the channel resource
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelsChannelId: async (channelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling deleteChannelsChannelId.');
            }
            const localVarPath = `/channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a paginated list of all channel
         * @summary Get all channels
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels: async (includes?: string, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the channel resource
         * @param {string} channelId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsChannelId: async (channelId: string, includes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling getChannelsChannelId.');
            }
            const localVarPath = `/channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new channel resource
         * @summary Create a new channel
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {string} [url] 
         * @param {boolean} [_default] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannels: async (handle?: string, name?: string, url?: string, _default?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (handle !== undefined) { 
                localVarFormParams.append('handle', handle as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (url !== undefined) { 
                localVarFormParams.append('url', url as any);
            }
    
            if (_default !== undefined) { 
                localVarFormParams.append('default', _default as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the channel resource
         * @param {string} channelId 
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {string} [url] 
         * @param {boolean} [_default] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelsChannelId: async (channelId: string, handle?: string, name?: string, url?: string, _default?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling putChannelsChannelId.');
            }
            const localVarPath = `/channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (handle !== undefined) { 
                localVarFormParams.append('handle', handle as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (url !== undefined) { 
                localVarFormParams.append('url', url as any);
            }
    
            if (_default !== undefined) { 
                localVarFormParams.append('default', _default as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelsApi - functional programming interface
 * @export
 */
export const ChannelsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the channel resource
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChannelsChannelId(channelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).deleteChannelsChannelId(channelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a paginated list of all channel
         * @summary Get all channels
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannels(includes?: string, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelCollection>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannels(includes, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the channel resource
         * @param {string} channelId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelsChannelId(channelId: string, includes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelResponse>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).getChannelsChannelId(channelId, includes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new channel resource
         * @summary Create a new channel
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {string} [url] 
         * @param {boolean} [_default] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannels(handle?: string, name?: string, url?: string, _default?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channel>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).postChannels(handle, name, url, _default, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update the channel resource
         * @param {string} channelId 
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {string} [url] 
         * @param {boolean} [_default] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannelsChannelId(channelId: string, handle?: string, name?: string, url?: string, _default?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelResponse>> {
            const localVarAxiosArgs = await ChannelsApiAxiosParamCreator(configuration).putChannelsChannelId(channelId, handle, name, url, _default, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChannelsApi - factory interface
 * @export
 */
export const ChannelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete the channel resource
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelsChannelId(channelId: string, options?: any): AxiosPromise<void> {
            return ChannelsApiFp(configuration).deleteChannelsChannelId(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of all channel
         * @summary Get all channels
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(includes?: string, perPage?: number, options?: any): AxiosPromise<ChannelCollection> {
            return ChannelsApiFp(configuration).getChannels(includes, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the channel resource
         * @param {string} channelId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsChannelId(channelId: string, includes?: string, options?: any): AxiosPromise<ChannelResponse> {
            return ChannelsApiFp(configuration).getChannelsChannelId(channelId, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new channel resource
         * @summary Create a new channel
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {string} [url] 
         * @param {boolean} [_default] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannels(handle?: string, name?: string, url?: string, _default?: boolean, options?: any): AxiosPromise<Channel> {
            return ChannelsApiFp(configuration).postChannels(handle, name, url, _default, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the channel resource
         * @param {string} channelId 
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {string} [url] 
         * @param {boolean} [_default] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelsChannelId(channelId: string, handle?: string, name?: string, url?: string, _default?: boolean, options?: any): AxiosPromise<ChannelResponse> {
            return ChannelsApiFp(configuration).putChannelsChannelId(channelId, handle, name, url, _default, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
export class ChannelsApi extends BaseAPI {
    /**
     * 
     * @summary Delete the channel resource
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public deleteChannelsChannelId(channelId: string, options?: any) {
        return ChannelsApiFp(this.configuration).deleteChannelsChannelId(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a paginated list of all channel
     * @summary Get all channels
     * @param {string} [includes] Comma separated includes for the resource
     * @param {number} [perPage] How many results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannels(includes?: string, perPage?: number, options?: any) {
        return ChannelsApiFp(this.configuration).getChannels(includes, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the channel resource
     * @param {string} channelId 
     * @param {string} [includes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public getChannelsChannelId(channelId: string, includes?: string, options?: any) {
        return ChannelsApiFp(this.configuration).getChannelsChannelId(channelId, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new channel resource
     * @summary Create a new channel
     * @param {string} [handle] 
     * @param {string} [name] 
     * @param {string} [url] 
     * @param {boolean} [_default] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public postChannels(handle?: string, name?: string, url?: string, _default?: boolean, options?: any) {
        return ChannelsApiFp(this.configuration).postChannels(handle, name, url, _default, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the channel resource
     * @param {string} channelId 
     * @param {string} [handle] 
     * @param {string} [name] 
     * @param {string} [url] 
     * @param {boolean} [_default] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    public putChannelsChannelId(channelId: string, handle?: string, name?: string, url?: string, _default?: boolean, options?: any) {
        return ChannelsApiFp(this.configuration).putChannelsChannelId(channelId, handle, name, url, _default, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CollectionsApi - axios parameter creator
 * @export
 */
export const CollectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Collection by its ID
         * @summary Delete Collection
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionsCollectionId: async (collectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling deleteCollectionsCollectionId.');
            }
            const localVarPath = `/collections/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated response of collections.
         * @summary Get Collections
         * @param {'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups'} [include] 
         * @param {string} [perPage] 
         * @param {string} [fullResponse] 
         * @param {string} [sort] 
         * @param {string} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections: async (include?: 'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups', perPage?: string, fullResponse?: string, sort?: string, page?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single Collection by its ID
         * @summary Single Collection
         * @param {string} collectionId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollectionId: async (collectionId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling getCollectionsCollectionId.');
            }
            const localVarPath = `/collections/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new collection.
         * @summary Create Collection
         * @param {InlineObject22} [inlineObject22] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollections: async (inlineObject22?: InlineObject22, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/collections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject22 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject22 !== undefined ? inlineObject22 : {}) : (inlineObject22 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Syncs products with a collection.
         * @summary Update a collection\'s products
         * @param {string} collectionId 
         * @param {InlineObject21} [inlineObject21] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionIdProducts: async (collectionId: string, inlineObject21?: InlineObject21, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling postCollectionsCollectionIdProducts.');
            }
            const localVarPath = `/collections/{collectionId}/products`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject21 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject21 !== undefined ? inlineObject21 : {}) : (inlineObject21 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This request will allow you to attach routes to a collection
         * @summary Update a collection\'s routes
         * @param {string} collectionId 
         * @param {InlineObject20} [inlineObject20] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionRoutes: async (collectionId: string, inlineObject20?: InlineObject20, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling postCollectionsCollectionRoutes.');
            }
            const localVarPath = `/collections/{collectionId}/routes`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject20 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject20 !== undefined ? inlineObject20 : {}) : (inlineObject20 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Collection by its ID.
         * @summary Update Collection
         * @param {string} collectionId 
         * @param {InlineObject23} [inlineObject23] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionsCollectionId: async (collectionId: string, inlineObject23?: InlineObject23, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling putCollectionsCollectionId.');
            }
            const localVarPath = `/collections/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject23 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject23 !== undefined ? inlineObject23 : {}) : (inlineObject23 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CollectionsApi - functional programming interface
 * @export
 */
export const CollectionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a Collection by its ID
         * @summary Delete Collection
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCollectionsCollectionId(collectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).deleteCollectionsCollectionId(collectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a paginated response of collections.
         * @summary Get Collections
         * @param {'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups'} [include] 
         * @param {string} [perPage] 
         * @param {string} [fullResponse] 
         * @param {string} [sort] 
         * @param {string} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollections(include?: 'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups', perPage?: string, fullResponse?: string, sort?: string, page?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionCollection>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).getCollections(include, perPage, fullResponse, sort, page, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a single Collection by its ID
         * @summary Single Collection
         * @param {string} collectionId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCollectionsCollectionId(collectionId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponse>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).getCollectionsCollectionId(collectionId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new collection.
         * @summary Create Collection
         * @param {InlineObject22} [inlineObject22] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollections(inlineObject22?: InlineObject22, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponse>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).postCollections(inlineObject22, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Syncs products with a collection.
         * @summary Update a collection\'s products
         * @param {string} collectionId 
         * @param {InlineObject21} [inlineObject21] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionsCollectionIdProducts(collectionId: string, inlineObject21?: InlineObject21, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponse>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).postCollectionsCollectionIdProducts(collectionId, inlineObject21, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This request will allow you to attach routes to a collection
         * @summary Update a collection\'s routes
         * @param {string} collectionId 
         * @param {InlineObject20} [inlineObject20] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCollectionsCollectionRoutes(collectionId: string, inlineObject20?: InlineObject20, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponse>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).postCollectionsCollectionRoutes(collectionId, inlineObject20, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Collection by its ID.
         * @summary Update Collection
         * @param {string} collectionId 
         * @param {InlineObject23} [inlineObject23] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCollectionsCollectionId(collectionId: string, inlineObject23?: InlineObject23, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CollectionResponse>> {
            const localVarAxiosArgs = await CollectionsApiAxiosParamCreator(configuration).putCollectionsCollectionId(collectionId, inlineObject23, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CollectionsApi - factory interface
 * @export
 */
export const CollectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a Collection by its ID
         * @summary Delete Collection
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionsCollectionId(collectionId: string, options?: any): AxiosPromise<void> {
            return CollectionsApiFp(configuration).deleteCollectionsCollectionId(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated response of collections.
         * @summary Get Collections
         * @param {'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups'} [include] 
         * @param {string} [perPage] 
         * @param {string} [fullResponse] 
         * @param {string} [sort] 
         * @param {string} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections(include?: 'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups', perPage?: string, fullResponse?: string, sort?: string, page?: string, options?: any): AxiosPromise<CollectionCollection> {
            return CollectionsApiFp(configuration).getCollections(include, perPage, fullResponse, sort, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single Collection by its ID
         * @summary Single Collection
         * @param {string} collectionId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollectionId(collectionId: string, include?: string, options?: any): AxiosPromise<CollectionResponse> {
            return CollectionsApiFp(configuration).getCollectionsCollectionId(collectionId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new collection.
         * @summary Create Collection
         * @param {InlineObject22} [inlineObject22] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollections(inlineObject22?: InlineObject22, options?: any): AxiosPromise<CollectionResponse> {
            return CollectionsApiFp(configuration).postCollections(inlineObject22, options).then((request) => request(axios, basePath));
        },
        /**
         * Syncs products with a collection.
         * @summary Update a collection\'s products
         * @param {string} collectionId 
         * @param {InlineObject21} [inlineObject21] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionIdProducts(collectionId: string, inlineObject21?: InlineObject21, options?: any): AxiosPromise<CollectionResponse> {
            return CollectionsApiFp(configuration).postCollectionsCollectionIdProducts(collectionId, inlineObject21, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will allow you to attach routes to a collection
         * @summary Update a collection\'s routes
         * @param {string} collectionId 
         * @param {InlineObject20} [inlineObject20] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionRoutes(collectionId: string, inlineObject20?: InlineObject20, options?: any): AxiosPromise<CollectionResponse> {
            return CollectionsApiFp(configuration).postCollectionsCollectionRoutes(collectionId, inlineObject20, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Collection by its ID.
         * @summary Update Collection
         * @param {string} collectionId 
         * @param {InlineObject23} [inlineObject23] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionsCollectionId(collectionId: string, inlineObject23?: InlineObject23, options?: any): AxiosPromise<CollectionResponse> {
            return CollectionsApiFp(configuration).putCollectionsCollectionId(collectionId, inlineObject23, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
export class CollectionsApi extends BaseAPI {
    /**
     * Delete a Collection by its ID
     * @summary Delete Collection
     * @param {string} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public deleteCollectionsCollectionId(collectionId: string, options?: any) {
        return CollectionsApiFp(this.configuration).deleteCollectionsCollectionId(collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated response of collections.
     * @summary Get Collections
     * @param {'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups'} [include] 
     * @param {string} [perPage] 
     * @param {string} [fullResponse] 
     * @param {string} [sort] 
     * @param {string} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollections(include?: 'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups', perPage?: string, fullResponse?: string, sort?: string, page?: string, options?: any) {
        return CollectionsApiFp(this.configuration).getCollections(include, perPage, fullResponse, sort, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single Collection by its ID
     * @summary Single Collection
     * @param {string} collectionId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public getCollectionsCollectionId(collectionId: string, include?: string, options?: any) {
        return CollectionsApiFp(this.configuration).getCollectionsCollectionId(collectionId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new collection.
     * @summary Create Collection
     * @param {InlineObject22} [inlineObject22] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public postCollections(inlineObject22?: InlineObject22, options?: any) {
        return CollectionsApiFp(this.configuration).postCollections(inlineObject22, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Syncs products with a collection.
     * @summary Update a collection\'s products
     * @param {string} collectionId 
     * @param {InlineObject21} [inlineObject21] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public postCollectionsCollectionIdProducts(collectionId: string, inlineObject21?: InlineObject21, options?: any) {
        return CollectionsApiFp(this.configuration).postCollectionsCollectionIdProducts(collectionId, inlineObject21, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This request will allow you to attach routes to a collection
     * @summary Update a collection\'s routes
     * @param {string} collectionId 
     * @param {InlineObject20} [inlineObject20] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public postCollectionsCollectionRoutes(collectionId: string, inlineObject20?: InlineObject20, options?: any) {
        return CollectionsApiFp(this.configuration).postCollectionsCollectionRoutes(collectionId, inlineObject20, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Collection by its ID.
     * @summary Update Collection
     * @param {string} collectionId 
     * @param {InlineObject23} [inlineObject23] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    public putCollectionsCollectionId(collectionId: string, inlineObject23?: InlineObject23, options?: any) {
        return CollectionsApiFp(this.configuration).putCollectionsCollectionId(collectionId, inlineObject23, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a paginated list of all channel
         * @summary Get all countries
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries: async (include?: string, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the country resource
         * @param {string} countryId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountriesCountryId: async (countryId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryId' is not null or undefined
            if (countryId === null || countryId === undefined) {
                throw new RequiredError('countryId','Required parameter countryId was null or undefined when calling getCountriesCountryId.');
            }
            const localVarPath = `/countries/{countryId}`
                .replace(`{${"countryId"}}`, encodeURIComponent(String(countryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the country resource
         * @param {string} countryId 
         * @param {boolean} [preferred] 
         * @param {boolean} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCountriesCountryId: async (countryId: string, preferred?: boolean, enabled?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'countryId' is not null or undefined
            if (countryId === null || countryId === undefined) {
                throw new RequiredError('countryId','Required parameter countryId was null or undefined when calling putCountriesCountryId.');
            }
            const localVarPath = `/countries/{countryId}`
                .replace(`{${"countryId"}}`, encodeURIComponent(String(countryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (preferred !== undefined) { 
                localVarFormParams.append('preferred', preferred as any);
            }
    
            if (enabled !== undefined) { 
                localVarFormParams.append('enabled', enabled as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets a paginated list of all channel
         * @summary Get all countries
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountries(include?: string, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryCollection>> {
            const localVarAxiosArgs = await CountriesApiAxiosParamCreator(configuration).getCountries(include, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the country resource
         * @param {string} countryId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountriesCountryId(countryId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryResponse>> {
            const localVarAxiosArgs = await CountriesApiAxiosParamCreator(configuration).getCountriesCountryId(countryId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update the country resource
         * @param {string} countryId 
         * @param {boolean} [preferred] 
         * @param {boolean} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCountriesCountryId(countryId: string, preferred?: boolean, enabled?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryResponse>> {
            const localVarAxiosArgs = await CountriesApiAxiosParamCreator(configuration).putCountriesCountryId(countryId, preferred, enabled, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets a paginated list of all channel
         * @summary Get all countries
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(include?: string, perPage?: number, options?: any): AxiosPromise<CountryCollection> {
            return CountriesApiFp(configuration).getCountries(include, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the country resource
         * @param {string} countryId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountriesCountryId(countryId: string, include?: string, options?: any): AxiosPromise<CountryResponse> {
            return CountriesApiFp(configuration).getCountriesCountryId(countryId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the country resource
         * @param {string} countryId 
         * @param {boolean} [preferred] 
         * @param {boolean} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCountriesCountryId(countryId: string, preferred?: boolean, enabled?: boolean, options?: any): AxiosPromise<CountryResponse> {
            return CountriesApiFp(configuration).putCountriesCountryId(countryId, preferred, enabled, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * Gets a paginated list of all channel
     * @summary Get all countries
     * @param {string} [include] Comma separated includes for the resource
     * @param {number} [perPage] How many results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountries(include?: string, perPage?: number, options?: any) {
        return CountriesApiFp(this.configuration).getCountries(include, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the country resource
     * @param {string} countryId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountriesCountryId(countryId: string, include?: string, options?: any) {
        return CountriesApiFp(this.configuration).getCountriesCountryId(countryId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the country resource
     * @param {string} countryId 
     * @param {boolean} [preferred] 
     * @param {boolean} [enabled] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public putCountriesCountryId(countryId: string, preferred?: boolean, enabled?: boolean, options?: any) {
        return CountriesApiFp(this.configuration).putCountriesCountryId(countryId, preferred, enabled, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CustomerGroupsApi - axios parameter creator
 * @export
 */
export const CustomerGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the customer group resource
         * @param {string} customerGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerGroupsCustomerGroupId: async (customerGroupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerGroupId' is not null or undefined
            if (customerGroupId === null || customerGroupId === undefined) {
                throw new RequiredError('customerGroupId','Required parameter customerGroupId was null or undefined when calling deleteCustomerGroupsCustomerGroupId.');
            }
            const localVarPath = `/customer-groups/{customerGroupId}`
                .replace(`{${"customerGroupId"}}`, encodeURIComponent(String(customerGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single customer group
         * @param {string} customerGroupId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroupCustomerGroupId: async (customerGroupId: string, includes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerGroupId' is not null or undefined
            if (customerGroupId === null || customerGroupId === undefined) {
                throw new RequiredError('customerGroupId','Required parameter customerGroupId was null or undefined when calling getCustomerGroupCustomerGroupId.');
            }
            const localVarPath = `/customer-groups/{customerGroupId}`
                .replace(`{${"customerGroupId"}}`, encodeURIComponent(String(customerGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a paginated list of all customer groups
         * @summary Get all customer groups
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroups: async (includes?: string, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customer-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new customer group
         * @summary Create a new customer group
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {boolean} [_default] 
         * @param {boolean} [system] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerGroups: async (handle?: string, name?: string, _default?: boolean, system?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customer-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (handle !== undefined) { 
                localVarFormParams.append('handle', handle as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (_default !== undefined) { 
                localVarFormParams.append('default', _default as any);
            }
    
            if (system !== undefined) { 
                localVarFormParams.append('system', system as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the customer group resource
         * @param {string} customerGroupId 
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {boolean} [_default] 
         * @param {boolean} [system] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomerGroupsCustomerGroupId: async (customerGroupId: string, handle?: string, name?: string, _default?: boolean, system?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerGroupId' is not null or undefined
            if (customerGroupId === null || customerGroupId === undefined) {
                throw new RequiredError('customerGroupId','Required parameter customerGroupId was null or undefined when calling putCustomerGroupsCustomerGroupId.');
            }
            const localVarPath = `/customer-groups/{customerGroupId}`
                .replace(`{${"customerGroupId"}}`, encodeURIComponent(String(customerGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (handle !== undefined) { 
                localVarFormParams.append('handle', handle as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (_default !== undefined) { 
                localVarFormParams.append('default', _default as any);
            }
    
            if (system !== undefined) { 
                localVarFormParams.append('system', system as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerGroupsApi - functional programming interface
 * @export
 */
export const CustomerGroupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the customer group resource
         * @param {string} customerGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomerGroupsCustomerGroupId(customerGroupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomerGroupsApiAxiosParamCreator(configuration).deleteCustomerGroupsCustomerGroupId(customerGroupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get a single customer group
         * @param {string} customerGroupId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerGroupCustomerGroupId(customerGroupId: string, includes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerGroupResponse>> {
            const localVarAxiosArgs = await CustomerGroupsApiAxiosParamCreator(configuration).getCustomerGroupCustomerGroupId(customerGroupId, includes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a paginated list of all customer groups
         * @summary Get all customer groups
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerGroups(includes?: string, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerGroupCollection>> {
            const localVarAxiosArgs = await CustomerGroupsApiAxiosParamCreator(configuration).getCustomerGroups(includes, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new customer group
         * @summary Create a new customer group
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {boolean} [_default] 
         * @param {boolean} [system] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomerGroups(handle?: string, name?: string, _default?: boolean, system?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerGroupResponse>> {
            const localVarAxiosArgs = await CustomerGroupsApiAxiosParamCreator(configuration).postCustomerGroups(handle, name, _default, system, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update the customer group resource
         * @param {string} customerGroupId 
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {boolean} [_default] 
         * @param {boolean} [system] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCustomerGroupsCustomerGroupId(customerGroupId: string, handle?: string, name?: string, _default?: boolean, system?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerGroupResponse>> {
            const localVarAxiosArgs = await CustomerGroupsApiAxiosParamCreator(configuration).putCustomerGroupsCustomerGroupId(customerGroupId, handle, name, _default, system, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CustomerGroupsApi - factory interface
 * @export
 */
export const CustomerGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete the customer group resource
         * @param {string} customerGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerGroupsCustomerGroupId(customerGroupId: string, options?: any): AxiosPromise<void> {
            return CustomerGroupsApiFp(configuration).deleteCustomerGroupsCustomerGroupId(customerGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single customer group
         * @param {string} customerGroupId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroupCustomerGroupId(customerGroupId: string, includes?: string, options?: any): AxiosPromise<CustomerGroupResponse> {
            return CustomerGroupsApiFp(configuration).getCustomerGroupCustomerGroupId(customerGroupId, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of all customer groups
         * @summary Get all customer groups
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroups(includes?: string, perPage?: number, options?: any): AxiosPromise<CustomerGroupCollection> {
            return CustomerGroupsApiFp(configuration).getCustomerGroups(includes, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new customer group
         * @summary Create a new customer group
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {boolean} [_default] 
         * @param {boolean} [system] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerGroups(handle?: string, name?: string, _default?: boolean, system?: boolean, options?: any): AxiosPromise<CustomerGroupResponse> {
            return CustomerGroupsApiFp(configuration).postCustomerGroups(handle, name, _default, system, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the customer group resource
         * @param {string} customerGroupId 
         * @param {string} [handle] 
         * @param {string} [name] 
         * @param {boolean} [_default] 
         * @param {boolean} [system] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomerGroupsCustomerGroupId(customerGroupId: string, handle?: string, name?: string, _default?: boolean, system?: boolean, options?: any): AxiosPromise<CustomerGroupResponse> {
            return CustomerGroupsApiFp(configuration).putCustomerGroupsCustomerGroupId(customerGroupId, handle, name, _default, system, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerGroupsApi - object-oriented interface
 * @export
 * @class CustomerGroupsApi
 * @extends {BaseAPI}
 */
export class CustomerGroupsApi extends BaseAPI {
    /**
     * 
     * @summary Delete the customer group resource
     * @param {string} customerGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    public deleteCustomerGroupsCustomerGroupId(customerGroupId: string, options?: any) {
        return CustomerGroupsApiFp(this.configuration).deleteCustomerGroupsCustomerGroupId(customerGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single customer group
     * @param {string} customerGroupId 
     * @param {string} [includes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    public getCustomerGroupCustomerGroupId(customerGroupId: string, includes?: string, options?: any) {
        return CustomerGroupsApiFp(this.configuration).getCustomerGroupCustomerGroupId(customerGroupId, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a paginated list of all customer groups
     * @summary Get all customer groups
     * @param {string} [includes] Comma separated includes for the resource
     * @param {number} [perPage] How many results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    public getCustomerGroups(includes?: string, perPage?: number, options?: any) {
        return CustomerGroupsApiFp(this.configuration).getCustomerGroups(includes, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new customer group
     * @summary Create a new customer group
     * @param {string} [handle] 
     * @param {string} [name] 
     * @param {boolean} [_default] 
     * @param {boolean} [system] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    public postCustomerGroups(handle?: string, name?: string, _default?: boolean, system?: boolean, options?: any) {
        return CustomerGroupsApiFp(this.configuration).postCustomerGroups(handle, name, _default, system, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the customer group resource
     * @param {string} customerGroupId 
     * @param {string} [handle] 
     * @param {string} [name] 
     * @param {boolean} [_default] 
     * @param {boolean} [system] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    public putCustomerGroupsCustomerGroupId(customerGroupId: string, handle?: string, name?: string, _default?: boolean, system?: boolean, options?: any) {
        return CustomerGroupsApiFp(this.configuration).putCustomerGroupsCustomerGroupId(customerGroupId, handle, name, _default, system, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the customer resource
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomersCustomerId: async (customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling deleteCustomersCustomerId.');
            }
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns any available customer fields which have been defined in the getcandy config.
         * @summary Get custom customer fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerFields: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers/fields`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a paginated list of all customers
         * @summary Get all customers
         * @param {string} [include] Comma separated include for the resource
         * @param {number} [perPage] How many results per page
         * @param {number} [counts] Comma seperated count include to show relation counts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (include?: string, perPage?: number, counts?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (counts !== undefined) {
                localVarQueryParameter['counts'] = counts;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the customer resource
         * @param {string} customerId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerId: async (customerId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomersCustomerId.');
            }
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach a user to a customer record
         * @param {string} customerId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerIdUsers: async (customerId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling getCustomersCustomerIdUsers.');
            }
            const localVarPath = `/customers/{customerId}/users`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns any available user fields which have been defined in the getcandy config.
         * @summary Get custom user fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFields: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/fields`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new customer
         * @summary Create a new customer
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {number} [contactNumber] 
         * @param {number} [altContactNumber] 
         * @param {string} [companyName] 
         * @param {string} [vatNo] 
         * @param {object} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers: async (firstname?: string, lastname?: string, contactNumber?: number, altContactNumber?: number, companyName?: string, vatNo?: string, fields?: object, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (firstname !== undefined) { 
                localVarFormParams.append('firstname', firstname as any);
            }
    
            if (lastname !== undefined) { 
                localVarFormParams.append('lastname', lastname as any);
            }
    
            if (contactNumber !== undefined) { 
                localVarFormParams.append('contact_number', contactNumber as any);
            }
    
            if (altContactNumber !== undefined) { 
                localVarFormParams.append('alt_contact_number', altContactNumber as any);
            }
    
            if (companyName !== undefined) { 
                localVarFormParams.append('company_name', companyName as any);
            }
    
            if (vatNo !== undefined) { 
                localVarFormParams.append('vat_no', vatNo as any);
            }
    
            if (fields !== undefined) { 
                localVarFormParams.append('fields', fields as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Attach customer groups to a customer
         * @param {string} customerId 
         * @param {AttachCustomerToGroupBody} [attachCustomerToGroupBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomersCustomerIdCustomerGroups: async (customerId: string, attachCustomerToGroupBody?: AttachCustomerToGroupBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling postCustomersCustomerIdCustomerGroups.');
            }
            const localVarPath = `/customers/{customerId}/customer-groups`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof attachCustomerToGroupBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(attachCustomerToGroupBody !== undefined ? attachCustomerToGroupBody : {}) : (attachCustomerToGroupBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the customer resource
         * @param {string} customerId 
         * @param {UpdateCustomerBody} [updateCustomerBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomersCustomerId: async (customerId: string, updateCustomerBody?: UpdateCustomerBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new RequiredError('customerId','Required parameter customerId was null or undefined when calling putCustomersCustomerId.');
            }
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof updateCustomerBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(updateCustomerBody !== undefined ? updateCustomerBody : {}) : (updateCustomerBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete the customer resource
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomersCustomerId(customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CustomersApiAxiosParamCreator(configuration).deleteCustomersCustomerId(customerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint returns any available customer fields which have been defined in the getcandy config.
         * @summary Get custom customer fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerFields(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerFieldsResponse>> {
            const localVarAxiosArgs = await CustomersApiAxiosParamCreator(configuration).getCustomerFields(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a paginated list of all customers
         * @summary Get all customers
         * @param {string} [include] Comma separated include for the resource
         * @param {number} [perPage] How many results per page
         * @param {number} [counts] Comma seperated count include to show relation counts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(include?: string, perPage?: number, counts?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCollection>> {
            const localVarAxiosArgs = await CustomersApiAxiosParamCreator(configuration).getCustomers(include, perPage, counts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get the customer resource
         * @param {string} customerId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomersCustomerId(customerId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerResponse>> {
            const localVarAxiosArgs = await CustomersApiAxiosParamCreator(configuration).getCustomersCustomerId(customerId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Attach a user to a customer record
         * @param {string} customerId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomersCustomerIdUsers(customerId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerResponse>> {
            const localVarAxiosArgs = await CustomersApiAxiosParamCreator(configuration).getCustomersCustomerIdUsers(customerId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint returns any available user fields which have been defined in the getcandy config.
         * @summary Get custom user fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersFields(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFieldsResponse>> {
            const localVarAxiosArgs = await CustomersApiAxiosParamCreator(configuration).getUsersFields(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new customer
         * @summary Create a new customer
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {number} [contactNumber] 
         * @param {number} [altContactNumber] 
         * @param {string} [companyName] 
         * @param {string} [vatNo] 
         * @param {object} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomers(firstname?: string, lastname?: string, contactNumber?: number, altContactNumber?: number, companyName?: string, vatNo?: string, fields?: object, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Customer>> {
            const localVarAxiosArgs = await CustomersApiAxiosParamCreator(configuration).postCustomers(firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Attach customer groups to a customer
         * @param {string} customerId 
         * @param {AttachCustomerToGroupBody} [attachCustomerToGroupBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCustomersCustomerIdCustomerGroups(customerId: string, attachCustomerToGroupBody?: AttachCustomerToGroupBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerResponse>> {
            const localVarAxiosArgs = await CustomersApiAxiosParamCreator(configuration).postCustomersCustomerIdCustomerGroups(customerId, attachCustomerToGroupBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Update the customer resource
         * @param {string} customerId 
         * @param {UpdateCustomerBody} [updateCustomerBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putCustomersCustomerId(customerId: string, updateCustomerBody?: UpdateCustomerBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerResponse>> {
            const localVarAxiosArgs = await CustomersApiAxiosParamCreator(configuration).putCustomersCustomerId(customerId, updateCustomerBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary Delete the customer resource
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomersCustomerId(customerId: string, options?: any): AxiosPromise<void> {
            return CustomersApiFp(configuration).deleteCustomersCustomerId(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns any available customer fields which have been defined in the getcandy config.
         * @summary Get custom customer fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerFields(options?: any): AxiosPromise<CustomerFieldsResponse> {
            return CustomersApiFp(configuration).getCustomerFields(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of all customers
         * @summary Get all customers
         * @param {string} [include] Comma separated include for the resource
         * @param {number} [perPage] How many results per page
         * @param {number} [counts] Comma seperated count include to show relation counts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(include?: string, perPage?: number, counts?: number, options?: any): AxiosPromise<CustomerCollection> {
            return CustomersApiFp(configuration).getCustomers(include, perPage, counts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the customer resource
         * @param {string} customerId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerId(customerId: string, include?: string, options?: any): AxiosPromise<CustomerResponse> {
            return CustomersApiFp(configuration).getCustomersCustomerId(customerId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach a user to a customer record
         * @param {string} customerId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerIdUsers(customerId: string, include?: string, options?: any): AxiosPromise<CustomerResponse> {
            return CustomersApiFp(configuration).getCustomersCustomerIdUsers(customerId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns any available user fields which have been defined in the getcandy config.
         * @summary Get custom user fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFields(options?: any): AxiosPromise<UserFieldsResponse> {
            return CustomersApiFp(configuration).getUsersFields(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new customer
         * @summary Create a new customer
         * @param {string} [firstname] 
         * @param {string} [lastname] 
         * @param {number} [contactNumber] 
         * @param {number} [altContactNumber] 
         * @param {string} [companyName] 
         * @param {string} [vatNo] 
         * @param {object} [fields] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers(firstname?: string, lastname?: string, contactNumber?: number, altContactNumber?: number, companyName?: string, vatNo?: string, fields?: object, options?: any): AxiosPromise<Customer> {
            return CustomersApiFp(configuration).postCustomers(firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Attach customer groups to a customer
         * @param {string} customerId 
         * @param {AttachCustomerToGroupBody} [attachCustomerToGroupBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomersCustomerIdCustomerGroups(customerId: string, attachCustomerToGroupBody?: AttachCustomerToGroupBody, options?: any): AxiosPromise<CustomerResponse> {
            return CustomersApiFp(configuration).postCustomersCustomerIdCustomerGroups(customerId, attachCustomerToGroupBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the customer resource
         * @param {string} customerId 
         * @param {UpdateCustomerBody} [updateCustomerBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomersCustomerId(customerId: string, updateCustomerBody?: UpdateCustomerBody, options?: any): AxiosPromise<CustomerResponse> {
            return CustomersApiFp(configuration).putCustomersCustomerId(customerId, updateCustomerBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * 
     * @summary Delete the customer resource
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public deleteCustomersCustomerId(customerId: string, options?: any) {
        return CustomersApiFp(this.configuration).deleteCustomersCustomerId(customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns any available customer fields which have been defined in the getcandy config.
     * @summary Get custom customer fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomerFields(options?: any) {
        return CustomersApiFp(this.configuration).getCustomerFields(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a paginated list of all customers
     * @summary Get all customers
     * @param {string} [include] Comma separated include for the resource
     * @param {number} [perPage] How many results per page
     * @param {number} [counts] Comma seperated count include to show relation counts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomers(include?: string, perPage?: number, counts?: number, options?: any) {
        return CustomersApiFp(this.configuration).getCustomers(include, perPage, counts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the customer resource
     * @param {string} customerId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomersCustomerId(customerId: string, include?: string, options?: any) {
        return CustomersApiFp(this.configuration).getCustomersCustomerId(customerId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach a user to a customer record
     * @param {string} customerId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomersCustomerIdUsers(customerId: string, include?: string, options?: any) {
        return CustomersApiFp(this.configuration).getCustomersCustomerIdUsers(customerId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns any available user fields which have been defined in the getcandy config.
     * @summary Get custom user fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getUsersFields(options?: any) {
        return CustomersApiFp(this.configuration).getUsersFields(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new customer
     * @summary Create a new customer
     * @param {string} [firstname] 
     * @param {string} [lastname] 
     * @param {number} [contactNumber] 
     * @param {number} [altContactNumber] 
     * @param {string} [companyName] 
     * @param {string} [vatNo] 
     * @param {object} [fields] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public postCustomers(firstname?: string, lastname?: string, contactNumber?: number, altContactNumber?: number, companyName?: string, vatNo?: string, fields?: object, options?: any) {
        return CustomersApiFp(this.configuration).postCustomers(firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Attach customer groups to a customer
     * @param {string} customerId 
     * @param {AttachCustomerToGroupBody} [attachCustomerToGroupBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public postCustomersCustomerIdCustomerGroups(customerId: string, attachCustomerToGroupBody?: AttachCustomerToGroupBody, options?: any) {
        return CustomersApiFp(this.configuration).postCustomersCustomerIdCustomerGroups(customerId, attachCustomerToGroupBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the customer resource
     * @param {string} customerId 
     * @param {UpdateCustomerBody} [updateCustomerBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public putCustomersCustomerId(customerId: string, updateCustomerBody?: UpdateCustomerBody, options?: any) {
        return CustomersApiFp(this.configuration).putCustomersCustomerId(customerId, updateCustomerBody, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DiscountsApi - axios parameter creator
 * @export
 */
export const DiscountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Discount
         * @summary Delete Discount
         * @param {string} discountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountId: async (discountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'discountId' is not null or undefined
            if (discountId === null || discountId === undefined) {
                throw new RequiredError('discountId','Required parameter discountId was null or undefined when calling deleteDiscountsDiscountId.');
            }
            const localVarPath = `/discounts/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of Discounts
         * @summary Get Discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/discounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Discount by it\'s ID.
         * @summary Get a Discount
         * @param {string} discountId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscountsDiscountId: async (discountId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'discountId' is not null or undefined
            if (discountId === null || discountId === undefined) {
                throw new RequiredError('discountId','Required parameter discountId was null or undefined when calling getDiscountsDiscountId.');
            }
            const localVarPath = `/discounts/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Discount.
         * @summary Create Discount
         * @param {InlineObject24} [inlineObject24] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscounts: async (inlineObject24?: InlineObject24, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/discounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject24 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject24 !== undefined ? inlineObject24 : {}) : (inlineObject24 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Discount
         * @summary Update Discount
         * @param {string} discountId 
         * @param {InlineObject25} [inlineObject25] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDiscountsDiscountId: async (discountId: string, inlineObject25?: InlineObject25, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'discountId' is not null or undefined
            if (discountId === null || discountId === undefined) {
                throw new RequiredError('discountId','Required parameter discountId was null or undefined when calling putDiscountsDiscountId.');
            }
            const localVarPath = `/discounts/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject25 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject25 !== undefined ? inlineObject25 : {}) : (inlineObject25 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscountsApi - functional programming interface
 * @export
 */
export const DiscountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a Discount
         * @summary Delete Discount
         * @param {string} discountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDiscountsDiscountId(discountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DiscountsApiAxiosParamCreator(configuration).deleteDiscountsDiscountId(discountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of Discounts
         * @summary Get Discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscounts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountCollection>> {
            const localVarAxiosArgs = await DiscountsApiAxiosParamCreator(configuration).getDiscounts(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a Discount by it\'s ID.
         * @summary Get a Discount
         * @param {string} discountId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiscountsDiscountId(discountId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountResponse>> {
            const localVarAxiosArgs = await DiscountsApiAxiosParamCreator(configuration).getDiscountsDiscountId(discountId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new Discount.
         * @summary Create Discount
         * @param {InlineObject24} [inlineObject24] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDiscounts(inlineObject24?: InlineObject24, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountResponse>> {
            const localVarAxiosArgs = await DiscountsApiAxiosParamCreator(configuration).postDiscounts(inlineObject24, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a Discount
         * @summary Update Discount
         * @param {string} discountId 
         * @param {InlineObject25} [inlineObject25] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDiscountsDiscountId(discountId: string, inlineObject25?: InlineObject25, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscountResponse>> {
            const localVarAxiosArgs = await DiscountsApiAxiosParamCreator(configuration).putDiscountsDiscountId(discountId, inlineObject25, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DiscountsApi - factory interface
 * @export
 */
export const DiscountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes a Discount
         * @summary Delete Discount
         * @param {string} discountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountId(discountId: string, options?: any): AxiosPromise<void> {
            return DiscountsApiFp(configuration).deleteDiscountsDiscountId(discountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Discounts
         * @summary Get Discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts(options?: any): AxiosPromise<DiscountCollection> {
            return DiscountsApiFp(configuration).getDiscounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Discount by it\'s ID.
         * @summary Get a Discount
         * @param {string} discountId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscountsDiscountId(discountId: string, include?: string, options?: any): AxiosPromise<DiscountResponse> {
            return DiscountsApiFp(configuration).getDiscountsDiscountId(discountId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Discount.
         * @summary Create Discount
         * @param {InlineObject24} [inlineObject24] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscounts(inlineObject24?: InlineObject24, options?: any): AxiosPromise<DiscountResponse> {
            return DiscountsApiFp(configuration).postDiscounts(inlineObject24, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Discount
         * @summary Update Discount
         * @param {string} discountId 
         * @param {InlineObject25} [inlineObject25] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDiscountsDiscountId(discountId: string, inlineObject25?: InlineObject25, options?: any): AxiosPromise<DiscountResponse> {
            return DiscountsApiFp(configuration).putDiscountsDiscountId(discountId, inlineObject25, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiscountsApi - object-oriented interface
 * @export
 * @class DiscountsApi
 * @extends {BaseAPI}
 */
export class DiscountsApi extends BaseAPI {
    /**
     * Deletes a Discount
     * @summary Delete Discount
     * @param {string} discountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public deleteDiscountsDiscountId(discountId: string, options?: any) {
        return DiscountsApiFp(this.configuration).deleteDiscountsDiscountId(discountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of Discounts
     * @summary Get Discounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public getDiscounts(options?: any) {
        return DiscountsApiFp(this.configuration).getDiscounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Discount by it\'s ID.
     * @summary Get a Discount
     * @param {string} discountId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public getDiscountsDiscountId(discountId: string, include?: string, options?: any) {
        return DiscountsApiFp(this.configuration).getDiscountsDiscountId(discountId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new Discount.
     * @summary Create Discount
     * @param {InlineObject24} [inlineObject24] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public postDiscounts(inlineObject24?: InlineObject24, options?: any) {
        return DiscountsApiFp(this.configuration).postDiscounts(inlineObject24, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Discount
     * @summary Update Discount
     * @param {string} discountId 
     * @param {InlineObject25} [inlineObject25] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public putDiscountsDiscountId(discountId: string, inlineObject25?: InlineObject25, options?: any) {
        return DiscountsApiFp(this.configuration).putDiscountsDiscountId(discountId, inlineObject25, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LanguagesApi - axios parameter creator
 * @export
 */
export const LanguagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Language by its ID
         * @summary Delete Language
         * @param {string} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanguagesLanguageId: async (languageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new RequiredError('languageId','Required parameter languageId was null or undefined when calling deleteLanguagesLanguageId.');
            }
            const localVarPath = `/languages/{languageId}`
                .replace(`{${"languageId"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of Languages
         * @summary Get Languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/languages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Language by ID
         * @summary Get Language
         * @param {string} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguagesLanguageId: async (languageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new RequiredError('languageId','Required parameter languageId was null or undefined when calling getLanguagesLanguageId.');
            }
            const localVarPath = `/languages/{languageId}`
                .replace(`{${"languageId"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new language
         * @summary Create Language
         * @param {string} name 
         * @param {string} lang 
         * @param {string} iso Unique
         * @param {boolean} [enabled] 
         * @param {boolean} [_default] 
         * @param {boolean} [current] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLanguages: async (name: string, lang: string, iso: string, enabled?: boolean, _default?: boolean, current?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postLanguages.');
            }
            // verify required parameter 'lang' is not null or undefined
            if (lang === null || lang === undefined) {
                throw new RequiredError('lang','Required parameter lang was null or undefined when calling postLanguages.');
            }
            // verify required parameter 'iso' is not null or undefined
            if (iso === null || iso === undefined) {
                throw new RequiredError('iso','Required parameter iso was null or undefined when calling postLanguages.');
            }
            const localVarPath = `/languages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (lang !== undefined) { 
                localVarFormParams.append('lang', lang as any);
            }
    
            if (iso !== undefined) { 
                localVarFormParams.append('iso', iso as any);
            }
    
            if (enabled !== undefined) { 
                localVarFormParams.append('enabled', enabled as any);
            }
    
            if (_default !== undefined) { 
                localVarFormParams.append('default', _default as any);
            }
    
            if (current !== undefined) { 
                localVarFormParams.append('current', current as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Language using it\'s ID
         * @summary Update Language
         * @param {string} languageId 
         * @param {Language} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLanguagesLanguageId: async (languageId: string, language?: Language, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new RequiredError('languageId','Required parameter languageId was null or undefined when calling putLanguagesLanguageId.');
            }
            const localVarPath = `/languages/{languageId}`
                .replace(`{${"languageId"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof language !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(language !== undefined ? language : {}) : (language || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguagesApi - functional programming interface
 * @export
 */
export const LanguagesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a Language by its ID
         * @summary Delete Language
         * @param {string} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLanguagesLanguageId(languageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await LanguagesApiAxiosParamCreator(configuration).deleteLanguagesLanguageId(languageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of Languages
         * @summary Get Languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLanguages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageCollection>> {
            const localVarAxiosArgs = await LanguagesApiAxiosParamCreator(configuration).getLanguages(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Language by ID
         * @summary Get Language
         * @param {string} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLanguagesLanguageId(languageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageResponse>> {
            const localVarAxiosArgs = await LanguagesApiAxiosParamCreator(configuration).getLanguagesLanguageId(languageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new language
         * @summary Create Language
         * @param {string} name 
         * @param {string} lang 
         * @param {string} iso Unique
         * @param {boolean} [enabled] 
         * @param {boolean} [_default] 
         * @param {boolean} [current] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postLanguages(name: string, lang: string, iso: string, enabled?: boolean, _default?: boolean, current?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageResponse>> {
            const localVarAxiosArgs = await LanguagesApiAxiosParamCreator(configuration).postLanguages(name, lang, iso, enabled, _default, current, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Language using it\'s ID
         * @summary Update Language
         * @param {string} languageId 
         * @param {Language} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLanguagesLanguageId(languageId: string, language?: Language, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LanguageResponse>> {
            const localVarAxiosArgs = await LanguagesApiAxiosParamCreator(configuration).putLanguagesLanguageId(languageId, language, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LanguagesApi - factory interface
 * @export
 */
export const LanguagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a Language by its ID
         * @summary Delete Language
         * @param {string} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanguagesLanguageId(languageId: string, options?: any): AxiosPromise<void> {
            return LanguagesApiFp(configuration).deleteLanguagesLanguageId(languageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Languages
         * @summary Get Languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages(options?: any): AxiosPromise<LanguageCollection> {
            return LanguagesApiFp(configuration).getLanguages(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Language by ID
         * @summary Get Language
         * @param {string} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguagesLanguageId(languageId: string, options?: any): AxiosPromise<LanguageResponse> {
            return LanguagesApiFp(configuration).getLanguagesLanguageId(languageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new language
         * @summary Create Language
         * @param {string} name 
         * @param {string} lang 
         * @param {string} iso Unique
         * @param {boolean} [enabled] 
         * @param {boolean} [_default] 
         * @param {boolean} [current] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLanguages(name: string, lang: string, iso: string, enabled?: boolean, _default?: boolean, current?: boolean, options?: any): AxiosPromise<LanguageResponse> {
            return LanguagesApiFp(configuration).postLanguages(name, lang, iso, enabled, _default, current, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Language using it\'s ID
         * @summary Update Language
         * @param {string} languageId 
         * @param {Language} [language] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLanguagesLanguageId(languageId: string, language?: Language, options?: any): AxiosPromise<LanguageResponse> {
            return LanguagesApiFp(configuration).putLanguagesLanguageId(languageId, language, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
export class LanguagesApi extends BaseAPI {
    /**
     * Delete a Language by its ID
     * @summary Delete Language
     * @param {string} languageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public deleteLanguagesLanguageId(languageId: string, options?: any) {
        return LanguagesApiFp(this.configuration).deleteLanguagesLanguageId(languageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of Languages
     * @summary Get Languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public getLanguages(options?: any) {
        return LanguagesApiFp(this.configuration).getLanguages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Language by ID
     * @summary Get Language
     * @param {string} languageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public getLanguagesLanguageId(languageId: string, options?: any) {
        return LanguagesApiFp(this.configuration).getLanguagesLanguageId(languageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new language
     * @summary Create Language
     * @param {string} name 
     * @param {string} lang 
     * @param {string} iso Unique
     * @param {boolean} [enabled] 
     * @param {boolean} [_default] 
     * @param {boolean} [current] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public postLanguages(name: string, lang: string, iso: string, enabled?: boolean, _default?: boolean, current?: boolean, options?: any) {
        return LanguagesApiFp(this.configuration).postLanguages(name, lang, iso, enabled, _default, current, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Language using it\'s ID
     * @summary Update Language
     * @param {string} languageId 
     * @param {Language} [language] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public putLanguagesLanguageId(languageId: string, language?: Language, options?: any) {
        return LanguagesApiFp(this.configuration).putLanguagesLanguageId(languageId, language, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LayoutsApi - axios parameter creator
 * @export
 */
export const LayoutsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of Layouts
         * @summary Get Layouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLayouts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/layouts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LayoutsApi - functional programming interface
 * @export
 */
export const LayoutsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of Layouts
         * @summary Get Layouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLayouts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LayoutCollection>> {
            const localVarAxiosArgs = await LayoutsApiAxiosParamCreator(configuration).getLayouts(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LayoutsApi - factory interface
 * @export
 */
export const LayoutsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get a paginated list of Layouts
         * @summary Get Layouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLayouts(options?: any): AxiosPromise<LayoutCollection> {
            return LayoutsApiFp(configuration).getLayouts(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LayoutsApi - object-oriented interface
 * @export
 * @class LayoutsApi
 * @extends {BaseAPI}
 */
export class LayoutsApi extends BaseAPI {
    /**
     * Get a paginated list of Layouts
     * @summary Get Layouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutsApi
     */
    public getLayouts(options?: any) {
        return LayoutsApiFp(this.configuration).getLayouts(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an order line from an order
         * @summary Delete an order line
         * @param {string} orderLineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrdersLinesOrderId: async (orderLineId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderLineId' is not null or undefined
            if (orderLineId === null || orderLineId === undefined) {
                throw new RequiredError('orderLineId','Required parameter orderLineId was null or undefined when calling deleteOrdersLinesOrderId.');
            }
            const localVarPath = `/orders/lines/{orderLineId}`
                .replace(`{${"orderLineId"}}`, encodeURIComponent(String(orderLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you\'re an admin user you will be able to see all orders, otherwise only the current users orders will be returned.
         * @summary Get orders
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (include?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export orders into a base64 encoded string
         * @summary Get Order export
         * @param {'1sfe534r4ref:934redfk'} orders Colon seperated order IDs
         * @param {string} format The export format, must be present in config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBulk: async (orders: '1sfe534r4ref:934redfk', format: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orders' is not null or undefined
            if (orders === null || orders === undefined) {
                throw new RequiredError('orders','Required parameter orders was null or undefined when calling getOrdersBulk.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new RequiredError('format','Required parameter format was null or undefined when calling getOrdersBulk.');
            }
            const localVarPath = `/orders/bulk`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will get a HTML email preview for an order status, this is useful if you want to be able to see what email will be sent out for the corresponding Order status.  Mailers for each order status should be stored in the getcandy config under `orders.mailers`
         * @summary Get order status preview email
         * @param {string} id An order id to use for the template
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersEmailPreviewStatus: async (id: string, status: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrdersEmailPreviewStatus.');
            }
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new RequiredError('status','Required parameter status was null or undefined when calling getOrdersEmailPreviewStatus.');
            }
            const localVarPath = `/orders/email-preview/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an orders invoice
         * @summary Get order invoice
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdInvoice: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrdersIdInvoice.');
            }
            const localVarPath = `/orders/{orderId}/invoice`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return a list of all ShippingMethod\'s that are available for this order.
         * @summary Get Order Shipping Methods
         * @param {string} orderId 
         * @param {string} [include] The available resources to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdShippingMethods: async (orderId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrdersIdShippingMethods.');
            }
            const localVarPath = `/orders/{orderId}/shipping/methods`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an Order by it\'s ID.  You must be an admin or owner to retrieve the order, otherwise you\'ll get a 404.
         * @summary Get Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersOrderId: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrdersOrderId.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all order types currently in the system
         * @summary Get order types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Order from a Basket instance
         * @summary Create Order
         * @param {CreateOrderBody} [createOrderBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders: async (createOrderBody?: CreateOrderBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createOrderBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createOrderBody !== undefined ? createOrderBody : {}) : (createOrderBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to bulk update a field across multiple Orders.  You must have the correct priviledges to perform this action.
         * @summary Bulk update orders
         * @param {InlineObject3} [inlineObject3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersBulk: async (inlineObject3?: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/bulk`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject3 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject3 !== undefined ? inlineObject3 : {}) : (inlineObject3 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets an order to be expired. You must have the correct priviledges to perform this action. Once an order is expired, it will no longer appear in results unless performed by an admin or in the hub.
         * @summary Expire an Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderIdExpire: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling postOrdersOrderIdExpire.');
            }
            const localVarPath = `/orders/{orderId}/expire`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Processes an order on the API
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersProcess: async (inlineObject2?: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/process`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject2 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject2 !== undefined ? inlineObject2 : {}) : (inlineObject2 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add contact details to an order
         * @summary Add contact details
         * @param {string} orderId 
         * @param {InlineObject5} [inlineObject5] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdContact: async (orderId: string, inlineObject5?: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling putOrdersIdContact.');
            }
            const localVarPath = `/orders/{orderId}/contact`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject5 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject5 !== undefined ? inlineObject5 : {}) : (inlineObject5 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds an order line to an order
         * @summary Add order line
         * @param {string} orderId 
         * @param {InlineObject6} [inlineObject6] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdLines: async (orderId: string, inlineObject6?: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling putOrdersIdLines.');
            }
            const localVarPath = `/orders/{orderId}/lines`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject6 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject6 !== undefined ? inlineObject6 : {}) : (inlineObject6 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an orders shipping address
         * @summary Update shipping address
         * @param {string} orderId 
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingAddress: async (orderId: string, address?: Address, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling putOrdersIdShippingAddress.');
            }
            const localVarPath = `/orders/{orderId}/shipping/address`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof address !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(address !== undefined ? address : {}) : (address || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a shipping cost to an Order
         * @summary Add shipping cost
         * @param {string} orderId 
         * @param {string} [include] Related resources to include in response
         * @param {InlineObject4} [inlineObject4] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingCost: async (orderId: string, include?: string, inlineObject4?: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling putOrdersIdShippingCost.');
            }
            const localVarPath = `/orders/{orderId}/shipping/cost`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject4 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject4 !== undefined ? inlineObject4 : {}) : (inlineObject4 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an Order
         * @summary Update Order
         * @param {string} orderId 
         * @param {string} [include] 
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderId: async (orderId: string, include?: string, inlineObject1?: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling putOrdersOrderId.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject1 !== undefined ? inlineObject1 : {}) : (inlineObject1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an orders billing address
         * @summary Update billing address
         * @param {string} orderId 
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderIdBillingAddress: async (orderId: string, address?: Address, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling putOrdersOrderIdBillingAddress.');
            }
            const localVarPath = `/orders/{orderId}/billing/address`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof address !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(address !== undefined ? address : {}) : (address || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes an order line from an order
         * @summary Delete an order line
         * @param {string} orderLineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrdersLinesOrderId(orderLineId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).deleteOrdersLinesOrderId(orderLineId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * If you\'re an admin user you will be able to see all orders, otherwise only the current users orders will be returned.
         * @summary Get orders
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderCollection>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).getOrders(include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Export orders into a base64 encoded string
         * @summary Get Order export
         * @param {'1sfe534r4ref:934redfk'} orders Colon seperated order IDs
         * @param {string} format The export format, must be present in config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersBulk(orders: '1sfe534r4ref:934redfk', format: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderExportResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).getOrdersBulk(orders, format, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint will get a HTML email preview for an order status, this is useful if you want to be able to see what email will be sent out for the corresponding Order status.  Mailers for each order status should be stored in the getcandy config under `orders.mailers`
         * @summary Get order status preview email
         * @param {string} id An order id to use for the template
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersEmailPreviewStatus(id: string, status: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmailPreviewResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).getOrdersEmailPreviewStatus(id, status, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an orders invoice
         * @summary Get order invoice
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersIdInvoice(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).getOrdersIdInvoice(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This will return a list of all ShippingMethod\'s that are available for this order.
         * @summary Get Order Shipping Methods
         * @param {string} orderId 
         * @param {string} [include] The available resources to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersIdShippingMethods(orderId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingPriceCollection>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).getOrdersIdShippingMethods(orderId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an Order by it\'s ID.  You must be an admin or owner to retrieve the order, otherwise you\'ll get a 404.
         * @summary Get Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersOrderId(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).getOrdersOrderId(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns all order types currently in the system
         * @summary Get order types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderTypeCollection>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).getOrdersTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create an Order from a Basket instance
         * @summary Create Order
         * @param {CreateOrderBody} [createOrderBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrders(createOrderBody?: CreateOrderBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).postOrders(createOrderBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows you to bulk update a field across multiple Orders.  You must have the correct priviledges to perform this action.
         * @summary Bulk update orders
         * @param {InlineObject3} [inlineObject3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersBulk(inlineObject3?: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).postOrdersBulk(inlineObject3, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets an order to be expired. You must have the correct priviledges to perform this action. Once an order is expired, it will no longer appear in results unless performed by an admin or in the hub.
         * @summary Expire an Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersOrderIdExpire(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).postOrdersOrderIdExpire(orderId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Processes an order on the API
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postOrdersProcess(inlineObject2?: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).postOrdersProcess(inlineObject2, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add contact details to an order
         * @summary Add contact details
         * @param {string} orderId 
         * @param {InlineObject5} [inlineObject5] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putOrdersIdContact(orderId: string, inlineObject5?: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).putOrdersIdContact(orderId, inlineObject5, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds an order line to an order
         * @summary Add order line
         * @param {string} orderId 
         * @param {InlineObject6} [inlineObject6] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putOrdersIdLines(orderId: string, inlineObject6?: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).putOrdersIdLines(orderId, inlineObject6, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an orders shipping address
         * @summary Update shipping address
         * @param {string} orderId 
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putOrdersIdShippingAddress(orderId: string, address?: Address, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).putOrdersIdShippingAddress(orderId, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Adds a shipping cost to an Order
         * @summary Add shipping cost
         * @param {string} orderId 
         * @param {string} [include] Related resources to include in response
         * @param {InlineObject4} [inlineObject4] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putOrdersIdShippingCost(orderId: string, include?: string, inlineObject4?: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).putOrdersIdShippingCost(orderId, include, inlineObject4, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an Order
         * @summary Update Order
         * @param {string} orderId 
         * @param {string} [include] 
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putOrdersOrderId(orderId: string, include?: string, inlineObject1?: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).putOrdersOrderId(orderId, include, inlineObject1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update an orders billing address
         * @summary Update billing address
         * @param {string} orderId 
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putOrdersOrderIdBillingAddress(orderId: string, address?: Address, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await OrdersApiAxiosParamCreator(configuration).putOrdersOrderIdBillingAddress(orderId, address, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes an order line from an order
         * @summary Delete an order line
         * @param {string} orderLineId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrdersLinesOrderId(orderLineId: string, options?: any): AxiosPromise<void> {
            return OrdersApiFp(configuration).deleteOrdersLinesOrderId(orderLineId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you\'re an admin user you will be able to see all orders, otherwise only the current users orders will be returned.
         * @summary Get orders
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(include?: string, options?: any): AxiosPromise<OrderCollection> {
            return OrdersApiFp(configuration).getOrders(include, options).then((request) => request(axios, basePath));
        },
        /**
         * Export orders into a base64 encoded string
         * @summary Get Order export
         * @param {'1sfe534r4ref:934redfk'} orders Colon seperated order IDs
         * @param {string} format The export format, must be present in config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBulk(orders: '1sfe534r4ref:934redfk', format: string, options?: any): AxiosPromise<OrderExportResponse> {
            return OrdersApiFp(configuration).getOrdersBulk(orders, format, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will get a HTML email preview for an order status, this is useful if you want to be able to see what email will be sent out for the corresponding Order status.  Mailers for each order status should be stored in the getcandy config under `orders.mailers`
         * @summary Get order status preview email
         * @param {string} id An order id to use for the template
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersEmailPreviewStatus(id: string, status: string, options?: any): AxiosPromise<EmailPreviewResponse> {
            return OrdersApiFp(configuration).getOrdersEmailPreviewStatus(id, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an orders invoice
         * @summary Get order invoice
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdInvoice(orderId: string, options?: any): AxiosPromise<InvoiceResponse> {
            return OrdersApiFp(configuration).getOrdersIdInvoice(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return a list of all ShippingMethod\'s that are available for this order.
         * @summary Get Order Shipping Methods
         * @param {string} orderId 
         * @param {string} [include] The available resources to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdShippingMethods(orderId: string, include?: string, options?: any): AxiosPromise<ShippingPriceCollection> {
            return OrdersApiFp(configuration).getOrdersIdShippingMethods(orderId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Order by it\'s ID.  You must be an admin or owner to retrieve the order, otherwise you\'ll get a 404.
         * @summary Get Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersOrderId(orderId: string, options?: any): AxiosPromise<OrderResponse> {
            return OrdersApiFp(configuration).getOrdersOrderId(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all order types currently in the system
         * @summary Get order types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersTypes(options?: any): AxiosPromise<OrderTypeCollection> {
            return OrdersApiFp(configuration).getOrdersTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Create an Order from a Basket instance
         * @summary Create Order
         * @param {CreateOrderBody} [createOrderBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders(createOrderBody?: CreateOrderBody, options?: any): AxiosPromise<OrderResponse> {
            return OrdersApiFp(configuration).postOrders(createOrderBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to bulk update a field across multiple Orders.  You must have the correct priviledges to perform this action.
         * @summary Bulk update orders
         * @param {InlineObject3} [inlineObject3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersBulk(inlineObject3?: InlineObject3, options?: any): AxiosPromise<void> {
            return OrdersApiFp(configuration).postOrdersBulk(inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets an order to be expired. You must have the correct priviledges to perform this action. Once an order is expired, it will no longer appear in results unless performed by an admin or in the hub.
         * @summary Expire an Order
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderIdExpire(orderId: string, options?: any): AxiosPromise<void> {
            return OrdersApiFp(configuration).postOrdersOrderIdExpire(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Processes an order on the API
         * @param {InlineObject2} [inlineObject2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersProcess(inlineObject2?: InlineObject2, options?: any): AxiosPromise<OrderResponse> {
            return OrdersApiFp(configuration).postOrdersProcess(inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * Add contact details to an order
         * @summary Add contact details
         * @param {string} orderId 
         * @param {InlineObject5} [inlineObject5] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdContact(orderId: string, inlineObject5?: InlineObject5, options?: any): AxiosPromise<OrderResponse> {
            return OrdersApiFp(configuration).putOrdersIdContact(orderId, inlineObject5, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an order line to an order
         * @summary Add order line
         * @param {string} orderId 
         * @param {InlineObject6} [inlineObject6] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdLines(orderId: string, inlineObject6?: InlineObject6, options?: any): AxiosPromise<OrderResponse> {
            return OrdersApiFp(configuration).putOrdersIdLines(orderId, inlineObject6, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an orders shipping address
         * @summary Update shipping address
         * @param {string} orderId 
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingAddress(orderId: string, address?: Address, options?: any): AxiosPromise<OrderResponse> {
            return OrdersApiFp(configuration).putOrdersIdShippingAddress(orderId, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a shipping cost to an Order
         * @summary Add shipping cost
         * @param {string} orderId 
         * @param {string} [include] Related resources to include in response
         * @param {InlineObject4} [inlineObject4] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingCost(orderId: string, include?: string, inlineObject4?: InlineObject4, options?: any): AxiosPromise<OrderResponse> {
            return OrdersApiFp(configuration).putOrdersIdShippingCost(orderId, include, inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an Order
         * @summary Update Order
         * @param {string} orderId 
         * @param {string} [include] 
         * @param {InlineObject1} [inlineObject1] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderId(orderId: string, include?: string, inlineObject1?: InlineObject1, options?: any): AxiosPromise<OrderResponse> {
            return OrdersApiFp(configuration).putOrdersOrderId(orderId, include, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an orders billing address
         * @summary Update billing address
         * @param {string} orderId 
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderIdBillingAddress(orderId: string, address?: Address, options?: any): AxiosPromise<OrderResponse> {
            return OrdersApiFp(configuration).putOrdersOrderIdBillingAddress(orderId, address, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Deletes an order line from an order
     * @summary Delete an order line
     * @param {string} orderLineId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public deleteOrdersLinesOrderId(orderLineId: string, options?: any) {
        return OrdersApiFp(this.configuration).deleteOrdersLinesOrderId(orderLineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If you\'re an admin user you will be able to see all orders, otherwise only the current users orders will be returned.
     * @summary Get orders
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrders(include?: string, options?: any) {
        return OrdersApiFp(this.configuration).getOrders(include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export orders into a base64 encoded string
     * @summary Get Order export
     * @param {'1sfe534r4ref:934redfk'} orders Colon seperated order IDs
     * @param {string} format The export format, must be present in config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersBulk(orders: '1sfe534r4ref:934redfk', format: string, options?: any) {
        return OrdersApiFp(this.configuration).getOrdersBulk(orders, format, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will get a HTML email preview for an order status, this is useful if you want to be able to see what email will be sent out for the corresponding Order status.  Mailers for each order status should be stored in the getcandy config under `orders.mailers`
     * @summary Get order status preview email
     * @param {string} id An order id to use for the template
     * @param {string} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersEmailPreviewStatus(id: string, status: string, options?: any) {
        return OrdersApiFp(this.configuration).getOrdersEmailPreviewStatus(id, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an orders invoice
     * @summary Get order invoice
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersIdInvoice(orderId: string, options?: any) {
        return OrdersApiFp(this.configuration).getOrdersIdInvoice(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return a list of all ShippingMethod\'s that are available for this order.
     * @summary Get Order Shipping Methods
     * @param {string} orderId 
     * @param {string} [include] The available resources to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersIdShippingMethods(orderId: string, include?: string, options?: any) {
        return OrdersApiFp(this.configuration).getOrdersIdShippingMethods(orderId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an Order by it\'s ID.  You must be an admin or owner to retrieve the order, otherwise you\'ll get a 404.
     * @summary Get Order
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersOrderId(orderId: string, options?: any) {
        return OrdersApiFp(this.configuration).getOrdersOrderId(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all order types currently in the system
     * @summary Get order types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrdersTypes(options?: any) {
        return OrdersApiFp(this.configuration).getOrdersTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an Order from a Basket instance
     * @summary Create Order
     * @param {CreateOrderBody} [createOrderBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public postOrders(createOrderBody?: CreateOrderBody, options?: any) {
        return OrdersApiFp(this.configuration).postOrders(createOrderBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to bulk update a field across multiple Orders.  You must have the correct priviledges to perform this action.
     * @summary Bulk update orders
     * @param {InlineObject3} [inlineObject3] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public postOrdersBulk(inlineObject3?: InlineObject3, options?: any) {
        return OrdersApiFp(this.configuration).postOrdersBulk(inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets an order to be expired. You must have the correct priviledges to perform this action. Once an order is expired, it will no longer appear in results unless performed by an admin or in the hub.
     * @summary Expire an Order
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public postOrdersOrderIdExpire(orderId: string, options?: any) {
        return OrdersApiFp(this.configuration).postOrdersOrderIdExpire(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Processes an order on the API
     * @param {InlineObject2} [inlineObject2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public postOrdersProcess(inlineObject2?: InlineObject2, options?: any) {
        return OrdersApiFp(this.configuration).postOrdersProcess(inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add contact details to an order
     * @summary Add contact details
     * @param {string} orderId 
     * @param {InlineObject5} [inlineObject5] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public putOrdersIdContact(orderId: string, inlineObject5?: InlineObject5, options?: any) {
        return OrdersApiFp(this.configuration).putOrdersIdContact(orderId, inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds an order line to an order
     * @summary Add order line
     * @param {string} orderId 
     * @param {InlineObject6} [inlineObject6] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public putOrdersIdLines(orderId: string, inlineObject6?: InlineObject6, options?: any) {
        return OrdersApiFp(this.configuration).putOrdersIdLines(orderId, inlineObject6, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an orders shipping address
     * @summary Update shipping address
     * @param {string} orderId 
     * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public putOrdersIdShippingAddress(orderId: string, address?: Address, options?: any) {
        return OrdersApiFp(this.configuration).putOrdersIdShippingAddress(orderId, address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a shipping cost to an Order
     * @summary Add shipping cost
     * @param {string} orderId 
     * @param {string} [include] Related resources to include in response
     * @param {InlineObject4} [inlineObject4] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public putOrdersIdShippingCost(orderId: string, include?: string, inlineObject4?: InlineObject4, options?: any) {
        return OrdersApiFp(this.configuration).putOrdersIdShippingCost(orderId, include, inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an Order
     * @summary Update Order
     * @param {string} orderId 
     * @param {string} [include] 
     * @param {InlineObject1} [inlineObject1] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public putOrdersOrderId(orderId: string, include?: string, inlineObject1?: InlineObject1, options?: any) {
        return OrdersApiFp(this.configuration).putOrdersOrderId(orderId, include, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an orders billing address
     * @summary Update billing address
     * @param {string} orderId 
     * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public putOrdersOrderIdBillingAddress(orderId: string, address?: Address, options?: any) {
        return OrdersApiFp(this.configuration).putOrdersOrderIdBillingAddress(orderId, address, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * PaymentsApi - axios parameter creator
 * @export
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the default, configured payment provider.
         * @summary Get Payment Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsProvider: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments/provider`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of available Payment Types in the system
         * @summary Payment types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsTypes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments/types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a ThreeD secure request and process the transaaction, if your payment provider supports it.
         * @summary Threed Secure Payment
         * @param {InlineObject28} [inlineObject28] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPayments3dSecure: async (inlineObject28?: InlineObject28, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/payments/3d-secure`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject28 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject28 !== undefined ? inlineObject28 : {}) : (inlineObject28 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund a transaction
         * @summary Refund a payment
         * @param {string} transactionId 
         * @param {number} [amount] If left blank, the full amount will be refunded
         * @param {string} [notes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsIdRefund: async (transactionId: string, amount?: number, notes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling postPaymentsIdRefund.');
            }
            const localVarPath = `/payments/{transactionId}/refund`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (amount !== undefined) { 
                localVarFormParams.append('amount', amount as any);
            }
    
            if (notes !== undefined) { 
                localVarFormParams.append('notes', notes as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Voids a payment in the system.
         * @summary Void a payment
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsTransactionIdVoid: async (transactionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new RequiredError('transactionId','Required parameter transactionId was null or undefined when calling postPaymentsTransactionIdVoid.');
            }
            const localVarPath = `/payments/{transactionId}/void`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 * @export
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets the default, configured payment provider.
         * @summary Get Payment Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentsProvider(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentProviderResponse>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getPaymentsProvider(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of available Payment Types in the system
         * @summary Payment types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentsTypes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentTypeCollection>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).getPaymentsTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Validate a ThreeD secure request and process the transaaction, if your payment provider supports it.
         * @summary Threed Secure Payment
         * @param {InlineObject28} [inlineObject28] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPayments3dSecure(inlineObject28?: InlineObject28, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).postPayments3dSecure(inlineObject28, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Refund a transaction
         * @summary Refund a payment
         * @param {string} transactionId 
         * @param {number} [amount] If left blank, the full amount will be refunded
         * @param {string} [notes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPaymentsIdRefund(transactionId: string, amount?: number, notes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).postPaymentsIdRefund(transactionId, amount, notes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Voids a payment in the system.
         * @summary Void a payment
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postPaymentsTransactionIdVoid(transactionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionResponse>> {
            const localVarAxiosArgs = await PaymentsApiAxiosParamCreator(configuration).postPaymentsTransactionIdVoid(transactionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PaymentsApi - factory interface
 * @export
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets the default, configured payment provider.
         * @summary Get Payment Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsProvider(options?: any): AxiosPromise<PaymentProviderResponse> {
            return PaymentsApiFp(configuration).getPaymentsProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of available Payment Types in the system
         * @summary Payment types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsTypes(options?: any): AxiosPromise<PaymentTypeCollection> {
            return PaymentsApiFp(configuration).getPaymentsTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate a ThreeD secure request and process the transaaction, if your payment provider supports it.
         * @summary Threed Secure Payment
         * @param {InlineObject28} [inlineObject28] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPayments3dSecure(inlineObject28?: InlineObject28, options?: any): AxiosPromise<OrderResponse> {
            return PaymentsApiFp(configuration).postPayments3dSecure(inlineObject28, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a transaction
         * @summary Refund a payment
         * @param {string} transactionId 
         * @param {number} [amount] If left blank, the full amount will be refunded
         * @param {string} [notes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsIdRefund(transactionId: string, amount?: number, notes?: string, options?: any): AxiosPromise<TransactionResponse> {
            return PaymentsApiFp(configuration).postPaymentsIdRefund(transactionId, amount, notes, options).then((request) => request(axios, basePath));
        },
        /**
         * Voids a payment in the system.
         * @summary Void a payment
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsTransactionIdVoid(transactionId: string, options?: any): AxiosPromise<TransactionResponse> {
            return PaymentsApiFp(configuration).postPaymentsTransactionIdVoid(transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
export class PaymentsApi extends BaseAPI {
    /**
     * Gets the default, configured payment provider.
     * @summary Get Payment Provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPaymentsProvider(options?: any) {
        return PaymentsApiFp(this.configuration).getPaymentsProvider(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of available Payment Types in the system
     * @summary Payment types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public getPaymentsTypes(options?: any) {
        return PaymentsApiFp(this.configuration).getPaymentsTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate a ThreeD secure request and process the transaaction, if your payment provider supports it.
     * @summary Threed Secure Payment
     * @param {InlineObject28} [inlineObject28] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public postPayments3dSecure(inlineObject28?: InlineObject28, options?: any) {
        return PaymentsApiFp(this.configuration).postPayments3dSecure(inlineObject28, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refund a transaction
     * @summary Refund a payment
     * @param {string} transactionId 
     * @param {number} [amount] If left blank, the full amount will be refunded
     * @param {string} [notes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public postPaymentsIdRefund(transactionId: string, amount?: number, notes?: string, options?: any) {
        return PaymentsApiFp(this.configuration).postPaymentsIdRefund(transactionId, amount, notes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Voids a payment in the system.
     * @summary Void a payment
     * @param {string} transactionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    public postPaymentsTransactionIdVoid(transactionId: string, options?: any) {
        return PaymentsApiFp(this.configuration).postPaymentsTransactionIdVoid(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProductFamiliesApi - axios parameter creator
 * @export
 */
export const ProductFamiliesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Sends a request to delete a product family
         * @summary Delete product family
         * @param {string} productFamilyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFamiliesProductFamilyId: async (productFamilyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productFamilyId' is not null or undefined
            if (productFamilyId === null || productFamilyId === undefined) {
                throw new RequiredError('productFamilyId','Required parameter productFamilyId was null or undefined when calling deleteProductFamiliesProductFamilyId.');
            }
            const localVarPath = `/product-families/{productFamilyId}`
                .replace(`{${"productFamilyId"}}`, encodeURIComponent(String(productFamilyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all product families.
         * @summary Get product families
         * @param {string} [include] Define included relationships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamilies: async (include?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-families`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single product family based on ID.
         * @summary Get a product family
         * @param {string} productFamilyId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamiliesProductFamilyId: async (productFamilyId: string, includes?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productFamilyId' is not null or undefined
            if (productFamilyId === null || productFamilyId === undefined) {
                throw new RequiredError('productFamilyId','Required parameter productFamilyId was null or undefined when calling getProductFamiliesProductFamilyId.');
            }
            const localVarPath = `/product-families/{productFamilyId}`
                .replace(`{${"productFamilyId"}}`, encodeURIComponent(String(productFamilyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new product family.
         * @summary Create product family
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductFamilies: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/product-families`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a product family
         * @summary Update product family
         * @param {string} productFamilyId 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductFamiliesProductFamilyId: async (productFamilyId: string, inlineObject?: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productFamilyId' is not null or undefined
            if (productFamilyId === null || productFamilyId === undefined) {
                throw new RequiredError('productFamilyId','Required parameter productFamilyId was null or undefined when calling putProductFamiliesProductFamilyId.');
            }
            const localVarPath = `/product-families/{productFamilyId}`
                .replace(`{${"productFamilyId"}}`, encodeURIComponent(String(productFamilyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject !== undefined ? inlineObject : {}) : (inlineObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductFamiliesApi - functional programming interface
 * @export
 */
export const ProductFamiliesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Sends a request to delete a product family
         * @summary Delete product family
         * @param {string} productFamilyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductFamiliesProductFamilyId(productFamilyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductFamiliesApiAxiosParamCreator(configuration).deleteProductFamiliesProductFamilyId(productFamilyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of all product families.
         * @summary Get product families
         * @param {string} [include] Define included relationships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductFamilies(include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductFamilyCollection>> {
            const localVarAxiosArgs = await ProductFamiliesApiAxiosParamCreator(configuration).getProductFamilies(include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single product family based on ID.
         * @summary Get a product family
         * @param {string} productFamilyId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductFamiliesProductFamilyId(productFamilyId: string, includes?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductFamilyResponse>> {
            const localVarAxiosArgs = await ProductFamiliesApiAxiosParamCreator(configuration).getProductFamiliesProductFamilyId(productFamilyId, includes, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new product family.
         * @summary Create product family
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductFamilies(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductFamilyResponse>> {
            const localVarAxiosArgs = await ProductFamiliesApiAxiosParamCreator(configuration).postProductFamilies(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a product family
         * @summary Update product family
         * @param {string} productFamilyId 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProductFamiliesProductFamilyId(productFamilyId: string, inlineObject?: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductFamilyResponse>> {
            const localVarAxiosArgs = await ProductFamiliesApiAxiosParamCreator(configuration).putProductFamiliesProductFamilyId(productFamilyId, inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProductFamiliesApi - factory interface
 * @export
 */
export const ProductFamiliesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Sends a request to delete a product family
         * @summary Delete product family
         * @param {string} productFamilyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFamiliesProductFamilyId(productFamilyId: string, options?: any): AxiosPromise<void> {
            return ProductFamiliesApiFp(configuration).deleteProductFamiliesProductFamilyId(productFamilyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all product families.
         * @summary Get product families
         * @param {string} [include] Define included relationships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamilies(include?: string, options?: any): AxiosPromise<ProductFamilyCollection> {
            return ProductFamiliesApiFp(configuration).getProductFamilies(include, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single product family based on ID.
         * @summary Get a product family
         * @param {string} productFamilyId 
         * @param {string} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamiliesProductFamilyId(productFamilyId: string, includes?: string, options?: any): AxiosPromise<ProductFamilyResponse> {
            return ProductFamiliesApiFp(configuration).getProductFamiliesProductFamilyId(productFamilyId, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new product family.
         * @summary Create product family
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductFamilies(options?: any): AxiosPromise<ProductFamilyResponse> {
            return ProductFamiliesApiFp(configuration).postProductFamilies(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a product family
         * @summary Update product family
         * @param {string} productFamilyId 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductFamiliesProductFamilyId(productFamilyId: string, inlineObject?: InlineObject, options?: any): AxiosPromise<ProductFamilyResponse> {
            return ProductFamiliesApiFp(configuration).putProductFamiliesProductFamilyId(productFamilyId, inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductFamiliesApi - object-oriented interface
 * @export
 * @class ProductFamiliesApi
 * @extends {BaseAPI}
 */
export class ProductFamiliesApi extends BaseAPI {
    /**
     * Sends a request to delete a product family
     * @summary Delete product family
     * @param {string} productFamilyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    public deleteProductFamiliesProductFamilyId(productFamilyId: string, options?: any) {
        return ProductFamiliesApiFp(this.configuration).deleteProductFamiliesProductFamilyId(productFamilyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all product families.
     * @summary Get product families
     * @param {string} [include] Define included relationships
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    public getProductFamilies(include?: string, options?: any) {
        return ProductFamiliesApiFp(this.configuration).getProductFamilies(include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single product family based on ID.
     * @summary Get a product family
     * @param {string} productFamilyId 
     * @param {string} [includes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    public getProductFamiliesProductFamilyId(productFamilyId: string, includes?: string, options?: any) {
        return ProductFamiliesApiFp(this.configuration).getProductFamiliesProductFamilyId(productFamilyId, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new product family.
     * @summary Create product family
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    public postProductFamilies(options?: any) {
        return ProductFamiliesApiFp(this.configuration).postProductFamilies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a product family
     * @summary Update product family
     * @param {string} productFamilyId 
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    public putProductFamiliesProductFamilyId(productFamilyId: string, inlineObject?: InlineObject, options?: any) {
        return ProductFamiliesApiFp(this.configuration).putProductFamiliesProductFamilyId(productFamilyId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProductVariantsApi - axios parameter creator
 * @export
 */
export const ProductVariantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of all product variants in the system
         * @summary Get Product Variants
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariants: async (include?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/variants`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a product variant by it\'s ID
         * @summary Get Product Variant
         * @param {string} productVariantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariantsProductVariantId: async (productVariantId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productVariantId' is not null or undefined
            if (productVariantId === null || productVariantId === undefined) {
                throw new RequiredError('productVariantId','Required parameter productVariantId was null or undefined when calling getProductsVariantsProductVariantId.');
            }
            const localVarPath = `/products/variants/{productVariantId}`
                .replace(`{${"productVariantId"}}`, encodeURIComponent(String(productVariantId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request to update a product variants inventory.
         * @summary Update ProductVariant Inventory
         * @param {string} productVariantId 
         * @param {InlineObject7} [inlineObject7] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsVariantsProductVariantIdInventory: async (productVariantId: string, inlineObject7?: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productVariantId' is not null or undefined
            if (productVariantId === null || productVariantId === undefined) {
                throw new RequiredError('productVariantId','Required parameter productVariantId was null or undefined when calling putProductsVariantsProductVariantIdInventory.');
            }
            const localVarPath = `/products/variants/{productVariantId}/inventory`
                .replace(`{${"productVariantId"}}`, encodeURIComponent(String(productVariantId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject7 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject7 !== undefined ? inlineObject7 : {}) : (inlineObject7 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductVariantsApi - functional programming interface
 * @export
 */
export const ProductVariantsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a paginated list of all product variants in the system
         * @summary Get Product Variants
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsVariants(include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVariantCollection>> {
            const localVarAxiosArgs = await ProductVariantsApiAxiosParamCreator(configuration).getProductsVariants(include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a product variant by it\'s ID
         * @summary Get Product Variant
         * @param {string} productVariantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsVariantsProductVariantId(productVariantId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVariantResponse>> {
            const localVarAxiosArgs = await ProductVariantsApiAxiosParamCreator(configuration).getProductsVariantsProductVariantId(productVariantId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request to update a product variants inventory.
         * @summary Update ProductVariant Inventory
         * @param {string} productVariantId 
         * @param {InlineObject7} [inlineObject7] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProductsVariantsProductVariantIdInventory(productVariantId: string, inlineObject7?: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVariantResponse>> {
            const localVarAxiosArgs = await ProductVariantsApiAxiosParamCreator(configuration).putProductsVariantsProductVariantIdInventory(productVariantId, inlineObject7, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProductVariantsApi - factory interface
 * @export
 */
export const ProductVariantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get a paginated list of all product variants in the system
         * @summary Get Product Variants
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariants(include?: string, options?: any): AxiosPromise<ProductVariantCollection> {
            return ProductVariantsApiFp(configuration).getProductsVariants(include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a product variant by it\'s ID
         * @summary Get Product Variant
         * @param {string} productVariantId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariantsProductVariantId(productVariantId: string, options?: any): AxiosPromise<ProductVariantResponse> {
            return ProductVariantsApiFp(configuration).getProductsVariantsProductVariantId(productVariantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to update a product variants inventory.
         * @summary Update ProductVariant Inventory
         * @param {string} productVariantId 
         * @param {InlineObject7} [inlineObject7] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsVariantsProductVariantIdInventory(productVariantId: string, inlineObject7?: InlineObject7, options?: any): AxiosPromise<ProductVariantResponse> {
            return ProductVariantsApiFp(configuration).putProductsVariantsProductVariantIdInventory(productVariantId, inlineObject7, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductVariantsApi - object-oriented interface
 * @export
 * @class ProductVariantsApi
 * @extends {BaseAPI}
 */
export class ProductVariantsApi extends BaseAPI {
    /**
     * Get a paginated list of all product variants in the system
     * @summary Get Product Variants
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductVariantsApi
     */
    public getProductsVariants(include?: string, options?: any) {
        return ProductVariantsApiFp(this.configuration).getProductsVariants(include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a product variant by it\'s ID
     * @summary Get Product Variant
     * @param {string} productVariantId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductVariantsApi
     */
    public getProductsVariantsProductVariantId(productVariantId: string, options?: any) {
        return ProductVariantsApiFp(this.configuration).getProductsVariantsProductVariantId(productVariantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request to update a product variants inventory.
     * @summary Update ProductVariant Inventory
     * @param {string} productVariantId 
     * @param {InlineObject7} [inlineObject7] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductVariantsApi
     */
    public putProductsVariantsProductVariantIdInventory(productVariantId: string, inlineObject7?: InlineObject7, options?: any) {
        return ProductVariantsApiFp(this.configuration).putProductsVariantsProductVariantIdInventory(productVariantId, inlineObject7, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory: async (productId: string, categoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductCategoriesCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling deleteProductsProductCategoriesCategory.');
            }
            const localVarPath = `/products/{productId}/categories/{categoryId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach: async (productId: string, collectionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductCollectionsDetach.');
            }
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new RequiredError('collectionId','Required parameter collectionId was null or undefined when calling deleteProductsProductCollectionsDetach.');
            }
            const localVarPath = `/products/{productId}/collections/{collectionId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductCustomerGroups.');
            }
            const localVarPath = `/products/{productId}/customer-groups`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes product associations
         * @summary 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProductsProductIdAssociations.');
            }
            const localVarPath = `/products/{productId}/associations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include] 
         * @param {boolean} [paginated] 
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (include?: string, paginated?: boolean, ids?: string, limit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }

            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId 
         * @param {string} [include] 
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId: async (productId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (exclTax !== undefined) {
                localVarQueryParameter['excl_tax'] = exclTax;
            }

            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }

            if (optionData !== undefined) {
                localVarQueryParameter['option_data'] = optionData;
            }

            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductsProductIdDrafts.');
            }
            const localVarPath = `/products/{productId}/drafts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended: async (basketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new RequiredError('basketId','Required parameter basketId was null or undefined when calling getProductsRecommended.');
            }
            const localVarPath = `/products/recommended`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (basketId !== undefined) {
                localVarQueryParameter['basket_id'] = basketId;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId 
         * @param {InlineObject10} [inlineObject10] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects: async (productId: string, inlineObject10?: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductRedirects.');
            }
            const localVarPath = `/products/{productId}/redirects`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject10 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject10 !== undefined ? inlineObject10 : {}) : (inlineObject10 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId 
         * @param {InlineObject9} [inlineObject9] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls: async (productId: string, inlineObject9?: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductUrls.');
            }
            const localVarPath = `/products/{productId}/urls`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject9 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject9 !== undefined ? inlineObject9 : {}) : (inlineObject9 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name 
         * @param {string} url 
         * @param {number} stock 
         * @param {string} familyId 
         * @param {number} price 
         * @param {string} sku 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts: async (name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling postProducts.');
            }
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new RequiredError('url','Required parameter url was null or undefined when calling postProducts.');
            }
            // verify required parameter 'stock' is not null or undefined
            if (stock === null || stock === undefined) {
                throw new RequiredError('stock','Required parameter stock was null or undefined when calling postProducts.');
            }
            // verify required parameter 'familyId' is not null or undefined
            if (familyId === null || familyId === undefined) {
                throw new RequiredError('familyId','Required parameter familyId was null or undefined when calling postProducts.');
            }
            // verify required parameter 'price' is not null or undefined
            if (price === null || price === undefined) {
                throw new RequiredError('price','Required parameter price was null or undefined when calling postProducts.');
            }
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new RequiredError('sku','Required parameter sku was null or undefined when calling postProducts.');
            }
            const localVarPath = `/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (url !== undefined) { 
                localVarFormParams.append('url', url as any);
            }
    
            if (stock !== undefined) { 
                localVarFormParams.append('stock', stock as any);
            }
    
            if (familyId !== undefined) { 
                localVarFormParams.append('family_id', familyId as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (sku !== undefined) { 
                localVarFormParams.append('sku', sku as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsIdDrafts.');
            }
            const localVarPath = `/products/{productId}/drafts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish: async (productId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsIdPublish.');
            }
            const localVarPath = `/products/{productId}/publish`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId 
         * @param {InlineObject15} [inlineObject15] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations: async (productId: string, inlineObject15?: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductAssociations.');
            }
            const localVarPath = `/products/{productId}/associations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject15 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject15 !== undefined ? inlineObject15 : {}) : (inlineObject15 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId 
         * @param {InlineObject11} [inlineObject11] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes: async (productId: string, inlineObject11?: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductAttributes.');
            }
            const localVarPath = `/products/{productId}/attributes`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject11 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject11 !== undefined ? inlineObject11 : {}) : (inlineObject11 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId 
         * @param {InlineObject13} [inlineObject13] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories: async (productId: string, inlineObject13?: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductCategories.');
            }
            const localVarPath = `/products/{productId}/categories`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject13 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject13 !== undefined ? inlineObject13 : {}) : (inlineObject13 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId 
         * @param {InlineObject14} [inlineObject14] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels: async (productId: string, inlineObject14?: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductChannels.');
            }
            const localVarPath = `/products/{productId}/channels`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject14 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject14 !== undefined ? inlineObject14 : {}) : (inlineObject14 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId 
         * @param {InlineObject16} [inlineObject16] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups: async (productId: string, inlineObject16?: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductCustomerGroups.');
            }
            const localVarPath = `/products/{productId}/customer-groups`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject16 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject16 !== undefined ? inlineObject16 : {}) : (inlineObject16 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId 
         * @param {InlineObject12} [inlineObject12] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections: async (productId: string, inlineObject12?: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductIdCollections.');
            }
            const localVarPath = `/products/{productId}/collections`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject12 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject12 !== undefined ? inlineObject12 : {}) : (inlineObject12 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId 
         * @param {InlineObject8} [inlineObject8] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate: async (productId: string, inlineObject8?: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling postProductsProductIdDuplicate.');
            }
            const localVarPath = `/products/{productId}/duplicate`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject8 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject8 !== undefined ? inlineObject8 : {}) : (inlineObject8 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId 
         * @param {ProductUpdateBody} [productUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId: async (productId: string, productUpdateBody?: ProductUpdateBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling putProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof productUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(productUpdateBody !== undefined ? productUpdateBody : {}) : (productUpdateBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductCategoriesCategory(productId: string, categoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductCollectionsDetach(productId: string, collectionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductCustomerGroups(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductCustomerGroups(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductId(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductId(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes product associations
         * @summary 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductsProductIdAssociations(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).deleteProductsProductIdAssociations(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include] 
         * @param {boolean} [paginated] 
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(include?: string, paginated?: boolean, ids?: string, limit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCollection>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProducts(include, paginated, ids, limit, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId 
         * @param {string} [include] 
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsProductId(productId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsProductIdDrafts(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductsProductIdDrafts(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsRecommended(basketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductRecommendationCollection>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).getProductsRecommended(basketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId 
         * @param {InlineObject10} [inlineObject10] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductRedirects(productId: string, inlineObject10?: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductRedirects(productId, inlineObject10, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId 
         * @param {InlineObject9} [inlineObject9] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductUrls(productId: string, inlineObject9?: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductUrls(productId, inlineObject9, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name 
         * @param {string} url 
         * @param {number} stock 
         * @param {string} familyId 
         * @param {number} price 
         * @param {string} sku 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProducts(name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProducts(name, url, stock, familyId, price, sku, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsIdDrafts(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsIdDrafts(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsIdPublish(productId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsIdPublish(productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId 
         * @param {InlineObject15} [inlineObject15] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductAssociations(productId: string, inlineObject15?: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductAssociations(productId, inlineObject15, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId 
         * @param {InlineObject11} [inlineObject11] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductAttributes(productId: string, inlineObject11?: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductAttributes(productId, inlineObject11, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId 
         * @param {InlineObject13} [inlineObject13] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductCategories(productId: string, inlineObject13?: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductCategories(productId, inlineObject13, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId 
         * @param {InlineObject14} [inlineObject14] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductChannels(productId: string, inlineObject14?: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductChannels(productId, inlineObject14, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId 
         * @param {InlineObject16} [inlineObject16] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductCustomerGroups(productId: string, inlineObject16?: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductCustomerGroups(productId, inlineObject16, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId 
         * @param {InlineObject12} [inlineObject12] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductIdCollections(productId: string, inlineObject12?: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductIdCollections(productId, inlineObject12, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId 
         * @param {InlineObject8} [inlineObject8] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProductsProductIdDuplicate(productId: string, inlineObject8?: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).postProductsProductIdDuplicate(productId, inlineObject8, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId 
         * @param {ProductUpdateBody} [productUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProductsProductId(productId: string, productUpdateBody?: ProductUpdateBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await ProductsApiAxiosParamCreator(configuration).putProductsProductId(productId, productUpdateBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId 
         * @param {string} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory(productId: string, categoryId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId 
         * @param {string} collectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach(productId: string, collectionId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups(productId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductCustomerGroups(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId(productId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductId(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes product associations
         * @summary 
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations(productId: string, options?: any): AxiosPromise<void> {
            return ProductsApiFp(configuration).deleteProductsProductIdAssociations(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include] 
         * @param {boolean} [paginated] 
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(include?: string, paginated?: boolean, ids?: string, limit?: number, options?: any): AxiosPromise<ProductCollection> {
            return ProductsApiFp(configuration).getProducts(include, paginated, ids, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId 
         * @param {string} [include] 
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId(productId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts(productId: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).getProductsProductIdDrafts(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended(basketId: string, options?: any): AxiosPromise<ProductRecommendationCollection> {
            return ProductsApiFp(configuration).getProductsRecommended(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId 
         * @param {InlineObject10} [inlineObject10] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects(productId: string, inlineObject10?: InlineObject10, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductRedirects(productId, inlineObject10, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId 
         * @param {InlineObject9} [inlineObject9] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls(productId: string, inlineObject9?: InlineObject9, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductUrls(productId, inlineObject9, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name 
         * @param {string} url 
         * @param {number} stock 
         * @param {string} familyId 
         * @param {number} price 
         * @param {string} sku 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts(name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProducts(name, url, stock, familyId, price, sku, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts(productId: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsIdDrafts(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish(productId: string, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsIdPublish(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId 
         * @param {InlineObject15} [inlineObject15] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations(productId: string, inlineObject15?: InlineObject15, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductAssociations(productId, inlineObject15, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId 
         * @param {InlineObject11} [inlineObject11] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes(productId: string, inlineObject11?: InlineObject11, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductAttributes(productId, inlineObject11, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId 
         * @param {InlineObject13} [inlineObject13] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories(productId: string, inlineObject13?: InlineObject13, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductCategories(productId, inlineObject13, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId 
         * @param {InlineObject14} [inlineObject14] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels(productId: string, inlineObject14?: InlineObject14, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductChannels(productId, inlineObject14, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId 
         * @param {InlineObject16} [inlineObject16] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups(productId: string, inlineObject16?: InlineObject16, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductCustomerGroups(productId, inlineObject16, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId 
         * @param {InlineObject12} [inlineObject12] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections(productId: string, inlineObject12?: InlineObject12, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductIdCollections(productId, inlineObject12, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId 
         * @param {InlineObject8} [inlineObject8] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate(productId: string, inlineObject8?: InlineObject8, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).postProductsProductIdDuplicate(productId, inlineObject8, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId 
         * @param {ProductUpdateBody} [productUpdateBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId(productId: string, productUpdateBody?: ProductUpdateBody, options?: any): AxiosPromise<ProductResponse> {
            return ProductsApiFp(configuration).putProductsProductId(productId, productUpdateBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Detaches a category from a product. Does not delete the category.
     * @summary Detach category
     * @param {string} productId 
     * @param {string} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductCategoriesCategory(productId: string, categoryId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches a collection from a product. Does not delete the collection.
     * @summary Detach collection
     * @param {string} productId 
     * @param {string} collectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductCollectionsDetach(productId: string, collectionId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detaches customer groups from a product
     * @summary Detach customer groups
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductCustomerGroups(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductCustomerGroups(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
     * @summary Delete Product
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductId(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductId(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes product associations
     * @summary 
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public deleteProductsProductIdAssociations(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).deleteProductsProductIdAssociations(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a paginated list of products.
     * @summary Get Products
     * @param {string} [include] 
     * @param {boolean} [paginated] 
     * @param {string} [ids] Return only the selected IDs
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProducts(include?: string, paginated?: boolean, ids?: string, limit?: number, options?: any) {
        return ProductsApiFp(this.configuration).getProducts(include, paginated, ids, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a product by it\'s given ID
     * @summary Get Product
     * @param {string} productId 
     * @param {string} [include] 
     * @param {string} [exclTax] Prices shouldn\&#39;t include tax
     * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
     * @param {string} [optionData] Include option data
     * @param {string} [draft] Show draft if exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductsProductId(productId: string, include?: string, exclTax?: string, fullResponse?: string, optionData?: string, draft?: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a draft for a product.  If a draft already exists, that current draft will be returned.
     * @summary Create draft
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductsProductIdDrafts(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductsProductIdDrafts(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
     * @summary Get recommended products
     * @param {string} basketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductsRecommended(basketId: string, options?: any) {
        return ProductsApiFp(this.configuration).getProductsRecommended(basketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and syncs a new product route.
     * @summary Create Product redirect
     * @param {string} productId 
     * @param {InlineObject10} [inlineObject10] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductRedirects(productId: string, inlineObject10?: InlineObject10, options?: any) {
        return ProductsApiFp(this.configuration).postProductRedirects(productId, inlineObject10, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and syncs a new product route.
     * @summary Create Product route
     * @param {string} productId 
     * @param {InlineObject9} [inlineObject9] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductUrls(productId: string, inlineObject9?: InlineObject9, options?: any) {
        return ProductsApiFp(this.configuration).postProductUrls(productId, inlineObject9, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create Product
     * @param {ShippingShippingMethodIdName} name 
     * @param {string} url 
     * @param {number} stock 
     * @param {string} familyId 
     * @param {number} price 
     * @param {string} sku 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProducts(name: ShippingShippingMethodIdName, url: string, stock: number, familyId: string, price: number, sku: string, include?: string, options?: any) {
        return ProductsApiFp(this.configuration).postProducts(name, url, stock, familyId, price, sku, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a draft product from an existing product.
     * @summary Create Draft
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsIdDrafts(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).postProductsIdDrafts(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Publish a draft from a Product
     * @summary Publish Draft
     * @param {string} productId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsIdPublish(productId: string, options?: any) {
        return ProductsApiFp(this.configuration).postProductsIdPublish(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates product associations
     * @summary Update product associations
     * @param {string} productId 
     * @param {InlineObject15} [inlineObject15] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductAssociations(productId: string, inlineObject15?: InlineObject15, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductAssociations(productId, inlineObject15, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows you to sync up the attributes which are directly associated to this product.
     * @summary Update Product attributes
     * @param {string} productId 
     * @param {InlineObject11} [inlineObject11] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductAttributes(productId: string, inlineObject11?: InlineObject11, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductAttributes(productId, inlineObject11, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync product categories
     * @summary Update Product categories
     * @param {string} productId 
     * @param {InlineObject13} [inlineObject13] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductCategories(productId: string, inlineObject13?: InlineObject13, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductCategories(productId, inlineObject13, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sync product Channels
     * @summary Update Product channels
     * @param {string} productId 
     * @param {InlineObject14} [inlineObject14] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductChannels(productId: string, inlineObject14?: InlineObject14, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductChannels(productId, inlineObject14, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a products customer groups
     * @summary Update customer groups
     * @param {string} productId 
     * @param {InlineObject16} [inlineObject16] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductCustomerGroups(productId: string, inlineObject16?: InlineObject16, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductCustomerGroups(productId, inlineObject16, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a products collections.
     * @summary Update Product collections
     * @param {string} productId 
     * @param {InlineObject12} [inlineObject12] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductIdCollections(productId: string, inlineObject12?: InlineObject12, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductIdCollections(productId, inlineObject12, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
     * @summary Duplicate Product
     * @param {string} productId 
     * @param {InlineObject8} [inlineObject8] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public postProductsProductIdDuplicate(productId: string, inlineObject8?: InlineObject8, options?: any) {
        return ProductsApiFp(this.configuration).postProductsProductIdDuplicate(productId, inlineObject8, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a product by it\'s ID
     * @summary Update Product
     * @param {string} productId 
     * @param {ProductUpdateBody} [productUpdateBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public putProductsProductId(productId: string, productUpdateBody?: ProductUpdateBody, options?: any) {
        return ProductsApiFp(this.configuration).putProductsProductId(productId, productUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RecycleBinApi - axios parameter creator
 * @export
 */
export const RecycleBinApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove a recycle bin item  > This will also hard delete the model associated with the recycle bin item, this action is not reversable and will cause loss of data.
         * @summary Delete item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecycleBinItemId: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling deleteRecycleBinItemId.');
            }
            const localVarPath = `/recycle-bin/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all recycle bin items.
         * @summary Get records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/recycle-bin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a recycle bin item.
         * @summary Get item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBinItemId: async (itemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new RequiredError('itemId','Required parameter itemId was null or undefined when calling getRecycleBinItemId.');
            }
            const localVarPath = `/recycle-bin/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecycleBinApi - functional programming interface
 * @export
 */
export const RecycleBinApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Remove a recycle bin item  > This will also hard delete the model associated with the recycle bin item, this action is not reversable and will cause loss of data.
         * @summary Delete item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRecycleBinItemId(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RecycleBinApiAxiosParamCreator(configuration).deleteRecycleBinItemId(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of all recycle bin items.
         * @summary Get records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecycleBin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecycleBinCollection>> {
            const localVarAxiosArgs = await RecycleBinApiAxiosParamCreator(configuration).getRecycleBin(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieves a recycle bin item.
         * @summary Get item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecycleBinItemId(itemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecycleBinResponse>> {
            const localVarAxiosArgs = await RecycleBinApiAxiosParamCreator(configuration).getRecycleBinItemId(itemId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RecycleBinApi - factory interface
 * @export
 */
export const RecycleBinApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Remove a recycle bin item  > This will also hard delete the model associated with the recycle bin item, this action is not reversable and will cause loss of data.
         * @summary Delete item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecycleBinItemId(itemId: string, options?: any): AxiosPromise<void> {
            return RecycleBinApiFp(configuration).deleteRecycleBinItemId(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all recycle bin items.
         * @summary Get records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBin(options?: any): AxiosPromise<RecycleBinCollection> {
            return RecycleBinApiFp(configuration).getRecycleBin(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a recycle bin item.
         * @summary Get item
         * @param {string} itemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBinItemId(itemId: string, options?: any): AxiosPromise<RecycleBinResponse> {
            return RecycleBinApiFp(configuration).getRecycleBinItemId(itemId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecycleBinApi - object-oriented interface
 * @export
 * @class RecycleBinApi
 * @extends {BaseAPI}
 */
export class RecycleBinApi extends BaseAPI {
    /**
     * Remove a recycle bin item  > This will also hard delete the model associated with the recycle bin item, this action is not reversable and will cause loss of data.
     * @summary Delete item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecycleBinApi
     */
    public deleteRecycleBinItemId(itemId: string, options?: any) {
        return RecycleBinApiFp(this.configuration).deleteRecycleBinItemId(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all recycle bin items.
     * @summary Get records
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecycleBinApi
     */
    public getRecycleBin(options?: any) {
        return RecycleBinApiFp(this.configuration).getRecycleBin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a recycle bin item.
     * @summary Get item
     * @param {string} itemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecycleBinApi
     */
    public getRecycleBinItemId(itemId: string, options?: any) {
        return RecycleBinApiFp(this.configuration).getRecycleBinItemId(itemId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets best selling products grouped by month.
         * @summary Get best selling products
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsBestSellers: async (from?: string, to?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/products/best-sellers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns metric (KPI) data for either sales or orders.
         * @summary Get metric data
         * @param {'sales' | 'orders'} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsMetricsSubject: async (subject: 'sales' | 'orders', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subject' is not null or undefined
            if (subject === null || subject === undefined) {
                throw new RequiredError('subject','Required parameter subject was null or undefined when calling getReportsMetricsSubject.');
            }
            const localVarPath = `/reports/metrics/{subject}`
                .replace(`{${"subject"}}`, encodeURIComponent(String(subject)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a report for orders between a given date range
         * @summary Get sales report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrders: async (from?: string, to?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of order averages between a given date range.
         * @summary Get order averages
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'daily' | 'yearly' | 'monthly'} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersAverages: async (from?: string, to?: string, mode?: 'weekly' | 'daily' | 'yearly' | 'monthly', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/orders/averages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a monthly grouped list of new/returning and total customers.
         * @summary Get Customer Report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersCustomers: async (from?: string, to?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/reports/orders/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoints returns sales report figures.  > Currently this provides data suitable for chartjs.org but this is subject to change and be more decoupled in a future release.
         * @summary Get sales report
         * @param {string} from The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'monthly' | 'daily'} [mode] The dataset mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsSales: async (from: string, to?: string, mode?: 'weekly' | 'monthly' | 'daily', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new RequiredError('from','Required parameter from was null or undefined when calling getReportsSales.');
            }
            const localVarPath = `/reports/sales`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets best selling products grouped by month.
         * @summary Get best selling products
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsBestSellers(from?: string, to?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).getProductsBestSellers(from, to, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns metric (KPI) data for either sales or orders.
         * @summary Get metric data
         * @param {'sales' | 'orders'} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportsMetricsSubject(subject: 'sales' | 'orders', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).getReportsMetricsSubject(subject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a report for orders between a given date range
         * @summary Get sales report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportsOrders(from?: string, to?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2002>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).getReportsOrders(from, to, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an array of order averages between a given date range.
         * @summary Get order averages
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'daily' | 'yearly' | 'monthly'} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportsOrdersAverages(from?: string, to?: string, mode?: 'weekly' | 'daily' | 'yearly' | 'monthly', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2004>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).getReportsOrdersAverages(from, to, mode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a monthly grouped list of new/returning and total customers.
         * @summary Get Customer Report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportsOrdersCustomers(from?: string, to?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).getReportsOrdersCustomers(from, to, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoints returns sales report figures.  > Currently this provides data suitable for chartjs.org but this is subject to change and be more decoupled in a future release.
         * @summary Get sales report
         * @param {string} from The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'monthly' | 'daily'} [mode] The dataset mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReportsSales(from: string, to?: string, mode?: 'weekly' | 'monthly' | 'daily', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).getReportsSales(from, to, mode, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets best selling products grouped by month.
         * @summary Get best selling products
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsBestSellers(from?: string, to?: string, options?: any): AxiosPromise<InlineResponse2005> {
            return ReportsApiFp(configuration).getProductsBestSellers(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metric (KPI) data for either sales or orders.
         * @summary Get metric data
         * @param {'sales' | 'orders'} subject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsMetricsSubject(subject: 'sales' | 'orders', options?: any): AxiosPromise<InlineResponse2006> {
            return ReportsApiFp(configuration).getReportsMetricsSubject(subject, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a report for orders between a given date range
         * @summary Get sales report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrders(from?: string, to?: string, options?: any): AxiosPromise<Array<InlineResponse2002>> {
            return ReportsApiFp(configuration).getReportsOrders(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of order averages between a given date range.
         * @summary Get order averages
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'daily' | 'yearly' | 'monthly'} [mode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersAverages(from?: string, to?: string, mode?: 'weekly' | 'daily' | 'yearly' | 'monthly', options?: any): AxiosPromise<Array<InlineResponse2004>> {
            return ReportsApiFp(configuration).getReportsOrdersAverages(from, to, mode, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a monthly grouped list of new/returning and total customers.
         * @summary Get Customer Report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersCustomers(from?: string, to?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return ReportsApiFp(configuration).getReportsOrdersCustomers(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoints returns sales report figures.  > Currently this provides data suitable for chartjs.org but this is subject to change and be more decoupled in a future release.
         * @summary Get sales report
         * @param {string} from The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'monthly' | 'daily'} [mode] The dataset mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsSales(from: string, to?: string, mode?: 'weekly' | 'monthly' | 'daily', options?: any): AxiosPromise<InlineResponse2001> {
            return ReportsApiFp(configuration).getReportsSales(from, to, mode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * Gets best selling products grouped by month.
     * @summary Get best selling products
     * @param {string} [from] The from date
     * @param {string} [to] The to date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getProductsBestSellers(from?: string, to?: string, options?: any) {
        return ReportsApiFp(this.configuration).getProductsBestSellers(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns metric (KPI) data for either sales or orders.
     * @summary Get metric data
     * @param {'sales' | 'orders'} subject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReportsMetricsSubject(subject: 'sales' | 'orders', options?: any) {
        return ReportsApiFp(this.configuration).getReportsMetricsSubject(subject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a report for orders between a given date range
     * @summary Get sales report
     * @param {string} [from] The from date
     * @param {string} [to] The to date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReportsOrders(from?: string, to?: string, options?: any) {
        return ReportsApiFp(this.configuration).getReportsOrders(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an array of order averages between a given date range.
     * @summary Get order averages
     * @param {string} [from] The from date
     * @param {string} [to] The to date
     * @param {'weekly' | 'daily' | 'yearly' | 'monthly'} [mode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReportsOrdersAverages(from?: string, to?: string, mode?: 'weekly' | 'daily' | 'yearly' | 'monthly', options?: any) {
        return ReportsApiFp(this.configuration).getReportsOrdersAverages(from, to, mode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a monthly grouped list of new/returning and total customers.
     * @summary Get Customer Report
     * @param {string} [from] The from date
     * @param {string} [to] The to date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReportsOrdersCustomers(from?: string, to?: string, options?: any) {
        return ReportsApiFp(this.configuration).getReportsOrdersCustomers(from, to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoints returns sales report figures.  > Currently this provides data suitable for chartjs.org but this is subject to change and be more decoupled in a future release.
     * @summary Get sales report
     * @param {string} from The from date
     * @param {string} [to] The to date
     * @param {'weekly' | 'monthly' | 'daily'} [mode] The dataset mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public getReportsSales(from: string, to?: string, mode?: 'weekly' | 'monthly' | 'daily', options?: any) {
        return ReportsApiFp(this.configuration).getReportsSales(from, to, mode, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information about the API
         * @summary Get root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns information about the API
         * @summary Get root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RootResponse>> {
            const localVarAxiosArgs = await RootApiAxiosParamCreator(configuration).get(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns information about the API
         * @summary Get root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: any): AxiosPromise<RootResponse> {
            return RootApiFp(configuration).get(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {
    /**
     * Returns information about the API
     * @summary Get root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    public get(options?: any) {
        return RootApiFp(this.configuration).get(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RoutesApi - axios parameter creator
 * @export
 */
export const RoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a Router by its ID
         * @summary Delete Route
         * @param {string} routeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoutesRouteId: async (routeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling deleteRoutesRouteId.');
            }
            const localVarPath = `/routes/{routeId}`
                .replace(`{${"routeId"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of Routes
         * @summary Get Routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/routes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Route by ID
         * @summary Get Route
         * @param {string} routeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesRouteId: async (routeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling getRoutesRouteId.');
            }
            const localVarPath = `/routes/{routeId}`
                .replace(`{${"routeId"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Route by searching via slug or path
         * @summary Search for Route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesSearch: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/routes/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Route using it\'s ID
         * @summary Update Route
         * @param {string} routeId 
         * @param {Route} [route] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRoutesRouteId: async (routeId: string, route?: Route, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new RequiredError('routeId','Required parameter routeId was null or undefined when calling putRoutesRouteId.');
            }
            const localVarPath = `/routes/{routeId}`
                .replace(`{${"routeId"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof route !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(route !== undefined ? route : {}) : (route || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutesApi - functional programming interface
 * @export
 */
export const RoutesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a Router by its ID
         * @summary Delete Route
         * @param {string} routeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoutesRouteId(routeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RoutesApiAxiosParamCreator(configuration).deleteRoutesRouteId(routeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of Routes
         * @summary Get Routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteCollection>> {
            const localVarAxiosArgs = await RoutesApiAxiosParamCreator(configuration).getRoutes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Route by ID
         * @summary Get Route
         * @param {string} routeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutesRouteId(routeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteResponse>> {
            const localVarAxiosArgs = await RoutesApiAxiosParamCreator(configuration).getRoutesRouteId(routeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a Route by searching via slug or path
         * @summary Search for Route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutesSearch(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteResponse>> {
            const localVarAxiosArgs = await RoutesApiAxiosParamCreator(configuration).getRoutesSearch(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a Route using it\'s ID
         * @summary Update Route
         * @param {string} routeId 
         * @param {Route} [route] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putRoutesRouteId(routeId: string, route?: Route, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteResponse>> {
            const localVarAxiosArgs = await RoutesApiAxiosParamCreator(configuration).putRoutesRouteId(routeId, route, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoutesApi - factory interface
 * @export
 */
export const RoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a Router by its ID
         * @summary Delete Route
         * @param {string} routeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoutesRouteId(routeId: string, options?: any): AxiosPromise<void> {
            return RoutesApiFp(configuration).deleteRoutesRouteId(routeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Routes
         * @summary Get Routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes(options?: any): AxiosPromise<RouteCollection> {
            return RoutesApiFp(configuration).getRoutes(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Route by ID
         * @summary Get Route
         * @param {string} routeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesRouteId(routeId: string, options?: any): AxiosPromise<RouteResponse> {
            return RoutesApiFp(configuration).getRoutesRouteId(routeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Route by searching via slug or path
         * @summary Search for Route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesSearch(options?: any): AxiosPromise<RouteResponse> {
            return RoutesApiFp(configuration).getRoutesSearch(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Route using it\'s ID
         * @summary Update Route
         * @param {string} routeId 
         * @param {Route} [route] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRoutesRouteId(routeId: string, route?: Route, options?: any): AxiosPromise<RouteResponse> {
            return RoutesApiFp(configuration).putRoutesRouteId(routeId, route, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
export class RoutesApi extends BaseAPI {
    /**
     * Delete a Router by its ID
     * @summary Delete Route
     * @param {string} routeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public deleteRoutesRouteId(routeId: string, options?: any) {
        return RoutesApiFp(this.configuration).deleteRoutesRouteId(routeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of Routes
     * @summary Get Routes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRoutes(options?: any) {
        return RoutesApiFp(this.configuration).getRoutes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Route by ID
     * @summary Get Route
     * @param {string} routeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRoutesRouteId(routeId: string, options?: any) {
        return RoutesApiFp(this.configuration).getRoutesRouteId(routeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Route by searching via slug or path
     * @summary Search for Route
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRoutesSearch(options?: any) {
        return RoutesApiFp(this.configuration).getRoutesSearch(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Route using it\'s ID
     * @summary Update Route
     * @param {string} routeId 
     * @param {Route} [route] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public putRoutesRouteId(routeId: string, route?: Route, options?: any) {
        return RoutesApiFp(this.configuration).putRoutesRouteId(routeId, route, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a saved search entry by ID.
         * @summary Delete saved search
         * @param {string} savedSearchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchesSavedSearchId: async (savedSearchId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedSearchId' is not null or undefined
            if (savedSearchId === null || savedSearchId === undefined) {
                throw new RequiredError('savedSearchId','Required parameter savedSearchId was null or undefined when calling deleteSavedSearchesSavedSearchId.');
            }
            const localVarPath = `/saved-searches/{savedSearchId}`
                .replace(`{${"savedSearchId"}}`, encodeURIComponent(String(savedSearchId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of current saved searches for products
         * @summary Get saved searches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearches: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/saved-searches/product`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search across products or categories  You can filter across attributes by adding key=value to the search query, for filtering multiple values use key=value1:value2
         * @summary Search GetCandy
         * @param {string} [channel] 
         * @param {string} [category] 
         * @param {number} [page] 
         * @param {'categories' | 'products'} [searchType] 
         * @param {string} [term] 
         * @param {boolean} [rank] Whether to rank results based on config
         * @param {boolean} [idsOnly] Will only return result ID\&#39;s, good for performance
         * @param {string} [include] 
         * @param {string} [sort] 
         * @param {boolean} [fullResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch: async (channel?: string, category?: string, page?: number, searchType?: 'categories' | 'products', term?: string, rank?: boolean, idsOnly?: boolean, include?: string, sort?: string, fullResponse?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (rank !== undefined) {
                localVarQueryParameter['rank'] = rank;
            }

            if (idsOnly !== undefined) {
                localVarQueryParameter['ids_only'] = idsOnly;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get saved search
         * @param {string} savedSearchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchesSavedSearchIdGet: async (savedSearchId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'savedSearchId' is not null or undefined
            if (savedSearchId === null || savedSearchId === undefined) {
                throw new RequiredError('savedSearchId','Required parameter savedSearchId was null or undefined when calling savedSearchesSavedSearchIdGet.');
            }
            const localVarPath = `/saved-searches/{savedSearchId}`
                .replace(`{${"savedSearchId"}}`, encodeURIComponent(String(savedSearchId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a saved search entry by ID.
         * @summary Delete saved search
         * @param {string} savedSearchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedSearchesSavedSearchId(savedSearchId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).deleteSavedSearchesSavedSearchId(savedSearchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of current saved searches for products
         * @summary Get saved searches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSavedSearches(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearchCollection>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).getSavedSearches(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Search across products or categories  You can filter across attributes by adding key=value to the search query, for filtering multiple values use key=value1:value2
         * @summary Search GetCandy
         * @param {string} [channel] 
         * @param {string} [category] 
         * @param {number} [page] 
         * @param {'categories' | 'products'} [searchType] 
         * @param {string} [term] 
         * @param {boolean} [rank] Whether to rank results based on config
         * @param {boolean} [idsOnly] Will only return result ID\&#39;s, good for performance
         * @param {string} [include] 
         * @param {string} [sort] 
         * @param {boolean} [fullResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSearch(channel?: string, category?: string, page?: number, searchType?: 'categories' | 'products', term?: string, rank?: boolean, idsOnly?: boolean, include?: string, sort?: string, fullResponse?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponse>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).getSearch(channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Get saved search
         * @param {string} savedSearchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async savedSearchesSavedSearchIdGet(savedSearchId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearchResponse>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).savedSearchesSavedSearchIdGet(savedSearchId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a saved search entry by ID.
         * @summary Delete saved search
         * @param {string} savedSearchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchesSavedSearchId(savedSearchId: string, options?: any): AxiosPromise<void> {
            return SearchApiFp(configuration).deleteSavedSearchesSavedSearchId(savedSearchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of current saved searches for products
         * @summary Get saved searches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearches(options?: any): AxiosPromise<SavedSearchCollection> {
            return SearchApiFp(configuration).getSavedSearches(options).then((request) => request(axios, basePath));
        },
        /**
         * Search across products or categories  You can filter across attributes by adding key=value to the search query, for filtering multiple values use key=value1:value2
         * @summary Search GetCandy
         * @param {string} [channel] 
         * @param {string} [category] 
         * @param {number} [page] 
         * @param {'categories' | 'products'} [searchType] 
         * @param {string} [term] 
         * @param {boolean} [rank] Whether to rank results based on config
         * @param {boolean} [idsOnly] Will only return result ID\&#39;s, good for performance
         * @param {string} [include] 
         * @param {string} [sort] 
         * @param {boolean} [fullResponse] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(channel?: string, category?: string, page?: number, searchType?: 'categories' | 'products', term?: string, rank?: boolean, idsOnly?: boolean, include?: string, sort?: string, fullResponse?: boolean, options?: any): AxiosPromise<SearchResponse> {
            return SearchApiFp(configuration).getSearch(channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get saved search
         * @param {string} savedSearchId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchesSavedSearchIdGet(savedSearchId: string, options?: any): AxiosPromise<SavedSearchResponse> {
            return SearchApiFp(configuration).savedSearchesSavedSearchIdGet(savedSearchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Delete a saved search entry by ID.
     * @summary Delete saved search
     * @param {string} savedSearchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public deleteSavedSearchesSavedSearchId(savedSearchId: string, options?: any) {
        return SearchApiFp(this.configuration).deleteSavedSearchesSavedSearchId(savedSearchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of current saved searches for products
     * @summary Get saved searches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getSavedSearches(options?: any) {
        return SearchApiFp(this.configuration).getSavedSearches(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search across products or categories  You can filter across attributes by adding key=value to the search query, for filtering multiple values use key=value1:value2
     * @summary Search GetCandy
     * @param {string} [channel] 
     * @param {string} [category] 
     * @param {number} [page] 
     * @param {'categories' | 'products'} [searchType] 
     * @param {string} [term] 
     * @param {boolean} [rank] Whether to rank results based on config
     * @param {boolean} [idsOnly] Will only return result ID\&#39;s, good for performance
     * @param {string} [include] 
     * @param {string} [sort] 
     * @param {boolean} [fullResponse] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public getSearch(channel?: string, category?: string, page?: number, searchType?: 'categories' | 'products', term?: string, rank?: boolean, idsOnly?: boolean, include?: string, sort?: string, fullResponse?: boolean, options?: any) {
        return SearchApiFp(this.configuration).getSearch(channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get saved search
     * @param {string} savedSearchId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public savedSearchesSavedSearchIdGet(savedSearchId: string, options?: any) {
        return SearchApiFp(this.configuration).savedSearchesSavedSearchIdGet(savedSearchId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves settings that have been defined in the database.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get specific settings.
         * @summary Get setting
         * @param {string} handle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsHandle: async (handle: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'handle' is not null or undefined
            if (handle === null || handle === undefined) {
                throw new RequiredError('handle','Required parameter handle was null or undefined when calling getSettingsHandle.');
            }
            const localVarPath = `/settings/{handle}`
                .replace(`{${"handle"}}`, encodeURIComponent(String(handle)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves settings that have been defined in the database.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettings(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingCollection>> {
            const localVarAxiosArgs = await SettingsApiAxiosParamCreator(configuration).getSettings(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get specific settings.
         * @summary Get setting
         * @param {string} handle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettingsHandle(handle: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingResponse>> {
            const localVarAxiosArgs = await SettingsApiAxiosParamCreator(configuration).getSettingsHandle(handle, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Retrieves settings that have been defined in the database.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options?: any): AxiosPromise<SettingCollection> {
            return SettingsApiFp(configuration).getSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Get specific settings.
         * @summary Get setting
         * @param {string} handle 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsHandle(handle: string, options?: any): AxiosPromise<SettingResponse> {
            return SettingsApiFp(configuration).getSettingsHandle(handle, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * Retrieves settings that have been defined in the database.
     * @summary Get settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSettings(options?: any) {
        return SettingsApiFp(this.configuration).getSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get specific settings.
     * @summary Get setting
     * @param {string} handle 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getSettingsHandle(handle: string, options?: any) {
        return SettingsApiFp(this.configuration).getSettingsHandle(handle, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ShippingApi - axios parameter creator
 * @export
 */
export const ShippingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a shipping method.
         * @summary Delete shipping method
         * @param {string} shippingMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingShippingMethodId: async (shippingMethodId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new RequiredError('shippingMethodId','Required parameter shippingMethodId was null or undefined when calling deleteShippingShippingMethodId.');
            }
            const localVarPath = `/shipping/{shippingMethodId}`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of shipping methods
         * @summary Get shipping methods
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipping: async (perPage?: number, include?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/shipping`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a shipping method by it\'s ID.
         * @summary Get shipping methods
         * @param {string} shippingMethodId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingShippingMethodId: async (shippingMethodId: string, include?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new RequiredError('shippingMethodId','Required parameter shippingMethodId was null or undefined when calling getShippingShippingMethodId.');
            }
            const localVarPath = `/shipping/{shippingMethodId}`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of shipping zones.
         * @summary Get Shipping Zones
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZones: async (include?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/shipping/zones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a shipping zone by it\'s ID.
         * @summary Get Shipping Zone
         * @param {string} shippingZoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZonesShippingZoneId: async (shippingZoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingZoneId' is not null or undefined
            if (shippingZoneId === null || shippingZoneId === undefined) {
                throw new RequiredError('shippingZoneId','Required parameter shippingZoneId was null or undefined when calling getShippingZonesShippingZoneId.');
            }
            const localVarPath = `/shipping/zones/{shippingZoneId}`
                .replace(`{${"shippingZoneId"}}`, encodeURIComponent(String(shippingZoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new shipping method.
         * @summary Create shipping method
         * @param {InlineObject29} [inlineObject29] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShipping: async (inlineObject29?: InlineObject29, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/shipping`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject29 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject29 !== undefined ? inlineObject29 : {}) : (inlineObject29 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a price to a shipping method.
         * @summary Add shipping price
         * @param {string} shippingMethodId 
         * @param {InlineObject32} [inlineObject32] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingIdPrices: async (shippingMethodId: string, inlineObject32?: InlineObject32, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new RequiredError('shippingMethodId','Required parameter shippingMethodId was null or undefined when calling postShippingIdPrices.');
            }
            const localVarPath = `/shipping/{shippingMethodId}/prices`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject32 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject32 !== undefined ? inlineObject32 : {}) : (inlineObject32 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new shipping zone
         * @summary Create Shipping Zone
         * @param {InlineObject31} [inlineObject31] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingZones: async (inlineObject31?: InlineObject31, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/shipping/zones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject31 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject31 !== undefined ? inlineObject31 : {}) : (inlineObject31 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update shipping method users
         * @summary Update shipping method users
         * @param {string} id 
         * @param {InlineObject35} [inlineObject35] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingIdUsers: async (id: string, inlineObject35?: InlineObject35, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putShippingIdUsers.');
            }
            const localVarPath = `/shipping/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject35 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject35 !== undefined ? inlineObject35 : {}) : (inlineObject35 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a shipping price
         * @summary Update shipping price
         * @param {string} shippingPriceId 
         * @param {InlineObject33} [inlineObject33] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingPricesShippingPriceId: async (shippingPriceId: string, inlineObject33?: InlineObject33, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingPriceId' is not null or undefined
            if (shippingPriceId === null || shippingPriceId === undefined) {
                throw new RequiredError('shippingPriceId','Required parameter shippingPriceId was null or undefined when calling putShippingPricesShippingPriceId.');
            }
            const localVarPath = `/shipping/prices/{shippingPriceId}`
                .replace(`{${"shippingPriceId"}}`, encodeURIComponent(String(shippingPriceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject33 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject33 !== undefined ? inlineObject33 : {}) : (inlineObject33 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update shipping method by it\'s ID
         * @summary Update shipping method
         * @param {string} shippingMethodId 
         * @param {InlineObject30} [inlineObject30] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodId: async (shippingMethodId: string, inlineObject30?: InlineObject30, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new RequiredError('shippingMethodId','Required parameter shippingMethodId was null or undefined when calling putShippingShippingMethodId.');
            }
            const localVarPath = `/shipping/{shippingMethodId}`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject30 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject30 !== undefined ? inlineObject30 : {}) : (inlineObject30 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a shipping method\'s zones.
         * @summary Update shipping method zones
         * @param {string} shippingMethodId 
         * @param {InlineObject34} [inlineObject34] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodIdZones: async (shippingMethodId: string, inlineObject34?: InlineObject34, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new RequiredError('shippingMethodId','Required parameter shippingMethodId was null or undefined when calling putShippingShippingMethodIdZones.');
            }
            const localVarPath = `/shipping/{shippingMethodId}/zones`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject34 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject34 !== undefined ? inlineObject34 : {}) : (inlineObject34 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShippingApi - functional programming interface
 * @export
 */
export const ShippingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a shipping method.
         * @summary Delete shipping method
         * @param {string} shippingMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteShippingShippingMethodId(shippingMethodId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).deleteShippingShippingMethodId(shippingMethodId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of shipping methods
         * @summary Get shipping methods
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShipping(perPage?: number, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingMethodCollection>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).getShipping(perPage, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a shipping method by it\'s ID.
         * @summary Get shipping methods
         * @param {string} shippingMethodId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingShippingMethodId(shippingMethodId: string, include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingMethodResponse>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).getShippingShippingMethodId(shippingMethodId, include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a paginated list of shipping zones.
         * @summary Get Shipping Zones
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingZones(include?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingZoneCollection>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).getShippingZones(include, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a shipping zone by it\'s ID.
         * @summary Get Shipping Zone
         * @param {string} shippingZoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingZonesShippingZoneId(shippingZoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingZoneResponse>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).getShippingZonesShippingZoneId(shippingZoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new shipping method.
         * @summary Create shipping method
         * @param {InlineObject29} [inlineObject29] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postShipping(inlineObject29?: InlineObject29, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).postShipping(inlineObject29, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Add a price to a shipping method.
         * @summary Add shipping price
         * @param {string} shippingMethodId 
         * @param {InlineObject32} [inlineObject32] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postShippingIdPrices(shippingMethodId: string, inlineObject32?: InlineObject32, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingPriceResponse>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).postShippingIdPrices(shippingMethodId, inlineObject32, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new shipping zone
         * @summary Create Shipping Zone
         * @param {InlineObject31} [inlineObject31] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postShippingZones(inlineObject31?: InlineObject31, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingZoneResponse>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).postShippingZones(inlineObject31, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update shipping method users
         * @summary Update shipping method users
         * @param {string} id 
         * @param {InlineObject35} [inlineObject35] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putShippingIdUsers(id: string, inlineObject35?: InlineObject35, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingMethodResponse>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).putShippingIdUsers(id, inlineObject35, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a shipping price
         * @summary Update shipping price
         * @param {string} shippingPriceId 
         * @param {InlineObject33} [inlineObject33] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putShippingPricesShippingPriceId(shippingPriceId: string, inlineObject33?: InlineObject33, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingPriceResponse>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).putShippingPricesShippingPriceId(shippingPriceId, inlineObject33, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update shipping method by it\'s ID
         * @summary Update shipping method
         * @param {string} shippingMethodId 
         * @param {InlineObject30} [inlineObject30] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putShippingShippingMethodId(shippingMethodId: string, inlineObject30?: InlineObject30, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingMethodResponse>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).putShippingShippingMethodId(shippingMethodId, inlineObject30, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a shipping method\'s zones.
         * @summary Update shipping method zones
         * @param {string} shippingMethodId 
         * @param {InlineObject34} [inlineObject34] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putShippingShippingMethodIdZones(shippingMethodId: string, inlineObject34?: InlineObject34, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingMethodResponse>> {
            const localVarAxiosArgs = await ShippingApiAxiosParamCreator(configuration).putShippingShippingMethodIdZones(shippingMethodId, inlineObject34, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ShippingApi - factory interface
 * @export
 */
export const ShippingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes a shipping method.
         * @summary Delete shipping method
         * @param {string} shippingMethodId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingShippingMethodId(shippingMethodId: string, options?: any): AxiosPromise<void> {
            return ShippingApiFp(configuration).deleteShippingShippingMethodId(shippingMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of shipping methods
         * @summary Get shipping methods
         * @param {number} [perPage] 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipping(perPage?: number, include?: string, options?: any): AxiosPromise<ShippingMethodCollection> {
            return ShippingApiFp(configuration).getShipping(perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a shipping method by it\'s ID.
         * @summary Get shipping methods
         * @param {string} shippingMethodId 
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingShippingMethodId(shippingMethodId: string, include?: string, options?: any): AxiosPromise<ShippingMethodResponse> {
            return ShippingApiFp(configuration).getShippingShippingMethodId(shippingMethodId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of shipping zones.
         * @summary Get Shipping Zones
         * @param {string} [include] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZones(include?: string, options?: any): AxiosPromise<ShippingZoneCollection> {
            return ShippingApiFp(configuration).getShippingZones(include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a shipping zone by it\'s ID.
         * @summary Get Shipping Zone
         * @param {string} shippingZoneId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZonesShippingZoneId(shippingZoneId: string, options?: any): AxiosPromise<ShippingZoneResponse> {
            return ShippingApiFp(configuration).getShippingZonesShippingZoneId(shippingZoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shipping method.
         * @summary Create shipping method
         * @param {InlineObject29} [inlineObject29] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShipping(inlineObject29?: InlineObject29, options?: any): AxiosPromise<InlineResponse2007> {
            return ShippingApiFp(configuration).postShipping(inlineObject29, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a price to a shipping method.
         * @summary Add shipping price
         * @param {string} shippingMethodId 
         * @param {InlineObject32} [inlineObject32] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingIdPrices(shippingMethodId: string, inlineObject32?: InlineObject32, options?: any): AxiosPromise<ShippingPriceResponse> {
            return ShippingApiFp(configuration).postShippingIdPrices(shippingMethodId, inlineObject32, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shipping zone
         * @summary Create Shipping Zone
         * @param {InlineObject31} [inlineObject31] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingZones(inlineObject31?: InlineObject31, options?: any): AxiosPromise<ShippingZoneResponse> {
            return ShippingApiFp(configuration).postShippingZones(inlineObject31, options).then((request) => request(axios, basePath));
        },
        /**
         * Update shipping method users
         * @summary Update shipping method users
         * @param {string} id 
         * @param {InlineObject35} [inlineObject35] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingIdUsers(id: string, inlineObject35?: InlineObject35, options?: any): AxiosPromise<ShippingMethodResponse> {
            return ShippingApiFp(configuration).putShippingIdUsers(id, inlineObject35, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a shipping price
         * @summary Update shipping price
         * @param {string} shippingPriceId 
         * @param {InlineObject33} [inlineObject33] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingPricesShippingPriceId(shippingPriceId: string, inlineObject33?: InlineObject33, options?: any): AxiosPromise<ShippingPriceResponse> {
            return ShippingApiFp(configuration).putShippingPricesShippingPriceId(shippingPriceId, inlineObject33, options).then((request) => request(axios, basePath));
        },
        /**
         * Update shipping method by it\'s ID
         * @summary Update shipping method
         * @param {string} shippingMethodId 
         * @param {InlineObject30} [inlineObject30] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodId(shippingMethodId: string, inlineObject30?: InlineObject30, options?: any): AxiosPromise<ShippingMethodResponse> {
            return ShippingApiFp(configuration).putShippingShippingMethodId(shippingMethodId, inlineObject30, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a shipping method\'s zones.
         * @summary Update shipping method zones
         * @param {string} shippingMethodId 
         * @param {InlineObject34} [inlineObject34] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodIdZones(shippingMethodId: string, inlineObject34?: InlineObject34, options?: any): AxiosPromise<ShippingMethodResponse> {
            return ShippingApiFp(configuration).putShippingShippingMethodIdZones(shippingMethodId, inlineObject34, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShippingApi - object-oriented interface
 * @export
 * @class ShippingApi
 * @extends {BaseAPI}
 */
export class ShippingApi extends BaseAPI {
    /**
     * Deletes a shipping method.
     * @summary Delete shipping method
     * @param {string} shippingMethodId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public deleteShippingShippingMethodId(shippingMethodId: string, options?: any) {
        return ShippingApiFp(this.configuration).deleteShippingShippingMethodId(shippingMethodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of shipping methods
     * @summary Get shipping methods
     * @param {number} [perPage] 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public getShipping(perPage?: number, include?: string, options?: any) {
        return ShippingApiFp(this.configuration).getShipping(perPage, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a shipping method by it\'s ID.
     * @summary Get shipping methods
     * @param {string} shippingMethodId 
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public getShippingShippingMethodId(shippingMethodId: string, include?: string, options?: any) {
        return ShippingApiFp(this.configuration).getShippingShippingMethodId(shippingMethodId, include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of shipping zones.
     * @summary Get Shipping Zones
     * @param {string} [include] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public getShippingZones(include?: string, options?: any) {
        return ShippingApiFp(this.configuration).getShippingZones(include, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a shipping zone by it\'s ID.
     * @summary Get Shipping Zone
     * @param {string} shippingZoneId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public getShippingZonesShippingZoneId(shippingZoneId: string, options?: any) {
        return ShippingApiFp(this.configuration).getShippingZonesShippingZoneId(shippingZoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new shipping method.
     * @summary Create shipping method
     * @param {InlineObject29} [inlineObject29] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public postShipping(inlineObject29?: InlineObject29, options?: any) {
        return ShippingApiFp(this.configuration).postShipping(inlineObject29, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a price to a shipping method.
     * @summary Add shipping price
     * @param {string} shippingMethodId 
     * @param {InlineObject32} [inlineObject32] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public postShippingIdPrices(shippingMethodId: string, inlineObject32?: InlineObject32, options?: any) {
        return ShippingApiFp(this.configuration).postShippingIdPrices(shippingMethodId, inlineObject32, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new shipping zone
     * @summary Create Shipping Zone
     * @param {InlineObject31} [inlineObject31] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public postShippingZones(inlineObject31?: InlineObject31, options?: any) {
        return ShippingApiFp(this.configuration).postShippingZones(inlineObject31, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update shipping method users
     * @summary Update shipping method users
     * @param {string} id 
     * @param {InlineObject35} [inlineObject35] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public putShippingIdUsers(id: string, inlineObject35?: InlineObject35, options?: any) {
        return ShippingApiFp(this.configuration).putShippingIdUsers(id, inlineObject35, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a shipping price
     * @summary Update shipping price
     * @param {string} shippingPriceId 
     * @param {InlineObject33} [inlineObject33] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public putShippingPricesShippingPriceId(shippingPriceId: string, inlineObject33?: InlineObject33, options?: any) {
        return ShippingApiFp(this.configuration).putShippingPricesShippingPriceId(shippingPriceId, inlineObject33, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update shipping method by it\'s ID
     * @summary Update shipping method
     * @param {string} shippingMethodId 
     * @param {InlineObject30} [inlineObject30] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public putShippingShippingMethodId(shippingMethodId: string, inlineObject30?: InlineObject30, options?: any) {
        return ShippingApiFp(this.configuration).putShippingShippingMethodId(shippingMethodId, inlineObject30, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a shipping method\'s zones.
     * @summary Update shipping method zones
     * @param {string} shippingMethodId 
     * @param {InlineObject34} [inlineObject34] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    public putShippingShippingMethodIdZones(shippingMethodId: string, inlineObject34?: InlineObject34, options?: any) {
        return ShippingApiFp(this.configuration).putShippingShippingMethodIdZones(shippingMethodId, inlineObject34, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a tag by it\'s ID
         * @summary Delete a tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsTagId: async (tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling deleteTagsTagId.');
            }
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get paginated list of tags
         * @summary Get all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a tag by it\'s ID
         * @summary Get a tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsTagId: async (tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling getTagsTagId.');
            }
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new tag
         * @summary 
         * @param {InlineObject36} [inlineObject36] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTags: async (inlineObject36?: InlineObject36, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject36 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject36 !== undefined ? inlineObject36 : {}) : (inlineObject36 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a tag by it\'s ID
         * @summary Update a tag
         * @param {string} tagId 
         * @param {InlineObject37} [inlineObject37] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTagsTagId: async (tagId: string, inlineObject37?: InlineObject37, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling putTagsTagId.');
            }
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject37 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject37 !== undefined ? inlineObject37 : {}) : (inlineObject37 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a tag by it\'s ID
         * @summary Delete a tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTagsTagId(tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TagsApiAxiosParamCreator(configuration).deleteTagsTagId(tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get paginated list of tags
         * @summary Get all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTags(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagCollection>> {
            const localVarAxiosArgs = await TagsApiAxiosParamCreator(configuration).getTags(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a tag by it\'s ID
         * @summary Get a tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTagsTagId(tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
            const localVarAxiosArgs = await TagsApiAxiosParamCreator(configuration).getTagsTagId(tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new tag
         * @summary 
         * @param {InlineObject36} [inlineObject36] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTags(inlineObject36?: InlineObject36, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
            const localVarAxiosArgs = await TagsApiAxiosParamCreator(configuration).postTags(inlineObject36, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a tag by it\'s ID
         * @summary Update a tag
         * @param {string} tagId 
         * @param {InlineObject37} [inlineObject37] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTagsTagId(tagId: string, inlineObject37?: InlineObject37, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagResponse>> {
            const localVarAxiosArgs = await TagsApiAxiosParamCreator(configuration).putTagsTagId(tagId, inlineObject37, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes a tag by it\'s ID
         * @summary Delete a tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsTagId(tagId: string, options?: any): AxiosPromise<void> {
            return TagsApiFp(configuration).deleteTagsTagId(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get paginated list of tags
         * @summary Get all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options?: any): AxiosPromise<TagCollection> {
            return TagsApiFp(configuration).getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a tag by it\'s ID
         * @summary Get a tag
         * @param {string} tagId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsTagId(tagId: string, options?: any): AxiosPromise<TagResponse> {
            return TagsApiFp(configuration).getTagsTagId(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tag
         * @summary 
         * @param {InlineObject36} [inlineObject36] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTags(inlineObject36?: InlineObject36, options?: any): AxiosPromise<TagResponse> {
            return TagsApiFp(configuration).postTags(inlineObject36, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a tag by it\'s ID
         * @summary Update a tag
         * @param {string} tagId 
         * @param {InlineObject37} [inlineObject37] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTagsTagId(tagId: string, inlineObject37?: InlineObject37, options?: any): AxiosPromise<TagResponse> {
            return TagsApiFp(configuration).putTagsTagId(tagId, inlineObject37, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Deletes a tag by it\'s ID
     * @summary Delete a tag
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public deleteTagsTagId(tagId: string, options?: any) {
        return TagsApiFp(this.configuration).deleteTagsTagId(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get paginated list of tags
     * @summary Get all tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTags(options?: any) {
        return TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a tag by it\'s ID
     * @summary Get a tag
     * @param {string} tagId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public getTagsTagId(tagId: string, options?: any) {
        return TagsApiFp(this.configuration).getTagsTagId(tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new tag
     * @summary 
     * @param {InlineObject36} [inlineObject36] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public postTags(inlineObject36?: InlineObject36, options?: any) {
        return TagsApiFp(this.configuration).postTags(inlineObject36, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a tag by it\'s ID
     * @summary Update a tag
     * @param {string} tagId 
     * @param {InlineObject37} [inlineObject37] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public putTagsTagId(tagId: string, inlineObject37?: InlineObject37, options?: any) {
        return TagsApiFp(this.configuration).putTagsTagId(tagId, inlineObject37, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * TaxesApi - axios parameter creator
 * @export
 */
export const TaxesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a tax record by it\'s ID.
         * @summary Delete tax record
         * @param {string} taxId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxesTaxId: async (taxId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxId' is not null or undefined
            if (taxId === null || taxId === undefined) {
                throw new RequiredError('taxId','Required parameter taxId was null or undefined when calling deleteTaxesTaxId.');
            }
            const localVarPath = `/taxes/{taxId}`
                .replace(`{${"taxId"}}`, encodeURIComponent(String(taxId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of taxes
         * @summary Get taxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxes: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/taxes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a tax record by it\'s ID
         * @summary Get tax record
         * @param {string} taxId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxesTaxId: async (taxId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxId' is not null or undefined
            if (taxId === null || taxId === undefined) {
                throw new RequiredError('taxId','Required parameter taxId was null or undefined when calling getTaxesTaxId.');
            }
            const localVarPath = `/taxes/{taxId}`
                .replace(`{${"taxId"}}`, encodeURIComponent(String(taxId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new tax resource.
         * @summary Create tax
         * @param {InlineObject18} [inlineObject18] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxes: async (inlineObject18?: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/taxes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject18 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject18 !== undefined ? inlineObject18 : {}) : (inlineObject18 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a tax record by it\'s ID
         * @summary Update tax record
         * @param {string} taxId 
         * @param {InlineObject19} [inlineObject19] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaxesTaxId: async (taxId: string, inlineObject19?: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taxId' is not null or undefined
            if (taxId === null || taxId === undefined) {
                throw new RequiredError('taxId','Required parameter taxId was null or undefined when calling putTaxesTaxId.');
            }
            const localVarPath = `/taxes/{taxId}`
                .replace(`{${"taxId"}}`, encodeURIComponent(String(taxId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject19 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject19 !== undefined ? inlineObject19 : {}) : (inlineObject19 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxesApi - functional programming interface
 * @export
 */
export const TaxesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a tax record by it\'s ID.
         * @summary Delete tax record
         * @param {string} taxId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaxesTaxId(taxId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await TaxesApiAxiosParamCreator(configuration).deleteTaxesTaxId(taxId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a paginated list of taxes
         * @summary Get taxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaxes(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxCollection>> {
            const localVarAxiosArgs = await TaxesApiAxiosParamCreator(configuration).getTaxes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a tax record by it\'s ID
         * @summary Get tax record
         * @param {string} taxId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaxesTaxId(taxId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxResponse>> {
            const localVarAxiosArgs = await TaxesApiAxiosParamCreator(configuration).getTaxesTaxId(taxId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new tax resource.
         * @summary Create tax
         * @param {InlineObject18} [inlineObject18] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTaxes(inlineObject18?: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxResponse>> {
            const localVarAxiosArgs = await TaxesApiAxiosParamCreator(configuration).postTaxes(inlineObject18, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a tax record by it\'s ID
         * @summary Update tax record
         * @param {string} taxId 
         * @param {InlineObject19} [inlineObject19] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putTaxesTaxId(taxId: string, inlineObject19?: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxResponse>> {
            const localVarAxiosArgs = await TaxesApiAxiosParamCreator(configuration).putTaxesTaxId(taxId, inlineObject19, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * TaxesApi - factory interface
 * @export
 */
export const TaxesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a tax record by it\'s ID.
         * @summary Delete tax record
         * @param {string} taxId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxesTaxId(taxId: string, options?: any): AxiosPromise<void> {
            return TaxesApiFp(configuration).deleteTaxesTaxId(taxId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of taxes
         * @summary Get taxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxes(options?: any): AxiosPromise<TaxCollection> {
            return TaxesApiFp(configuration).getTaxes(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a tax record by it\'s ID
         * @summary Get tax record
         * @param {string} taxId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxesTaxId(taxId: string, options?: any): AxiosPromise<TaxResponse> {
            return TaxesApiFp(configuration).getTaxesTaxId(taxId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tax resource.
         * @summary Create tax
         * @param {InlineObject18} [inlineObject18] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxes(inlineObject18?: InlineObject18, options?: any): AxiosPromise<TaxResponse> {
            return TaxesApiFp(configuration).postTaxes(inlineObject18, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tax record by it\'s ID
         * @summary Update tax record
         * @param {string} taxId 
         * @param {InlineObject19} [inlineObject19] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaxesTaxId(taxId: string, inlineObject19?: InlineObject19, options?: any): AxiosPromise<TaxResponse> {
            return TaxesApiFp(configuration).putTaxesTaxId(taxId, inlineObject19, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaxesApi - object-oriented interface
 * @export
 * @class TaxesApi
 * @extends {BaseAPI}
 */
export class TaxesApi extends BaseAPI {
    /**
     * Delete a tax record by it\'s ID.
     * @summary Delete tax record
     * @param {string} taxId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    public deleteTaxesTaxId(taxId: string, options?: any) {
        return TaxesApiFp(this.configuration).deleteTaxesTaxId(taxId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a paginated list of taxes
     * @summary Get taxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    public getTaxes(options?: any) {
        return TaxesApiFp(this.configuration).getTaxes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a tax record by it\'s ID
     * @summary Get tax record
     * @param {string} taxId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    public getTaxesTaxId(taxId: string, options?: any) {
        return TaxesApiFp(this.configuration).getTaxesTaxId(taxId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new tax resource.
     * @summary Create tax
     * @param {InlineObject18} [inlineObject18] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    public postTaxes(inlineObject18?: InlineObject18, options?: any) {
        return TaxesApiFp(this.configuration).postTaxes(inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a tax record by it\'s ID
     * @summary Update tax record
     * @param {string} taxId 
     * @param {InlineObject19} [inlineObject19] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    public putTaxesTaxId(taxId: string, inlineObject19?: InlineObject19, options?: any) {
        return TaxesApiFp(this.configuration).putTaxesTaxId(taxId, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a user by their given ID.
         * @summary 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserId: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUsersUserId.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a paginated list of all users
         * @summary Get all users
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (include?: string, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the user associated to the access token.
         * @summary Get the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCurrent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/current`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user by their given ID.
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserId: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUsersUserId.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows the current user to update their password.
         * @summary Reset  password
         * @param {AccountPasswordResetBody} [accountPasswordResetBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountPassword: async (accountPasswordResetBody?: AccountPasswordResetBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof accountPasswordResetBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(accountPasswordResetBody !== undefined ? accountPasswordResetBody : {}) : (accountPasswordResetBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user resource
         * @summary Create a new user
         * @param {CreateUserBody} [createUserBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers: async (createUserBody?: CreateUserBody, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof createUserBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(createUserBody !== undefined ? createUserBody : {}) : (createUserBody || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a user record from their ID.
         * @summary 
         * @param {string} userId 
         * @param {InlineObject26} [inlineObject26] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserId: async (userId: string, inlineObject26?: InlineObject26, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling putUsersUserId.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject26 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject26 !== undefined ? inlineObject26 : {}) : (inlineObject26 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a user by their given ID.
         * @summary 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersUserId(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).deleteUsersUserId(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a paginated list of all users
         * @summary Get all users
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(include?: string, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCollection>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUsers(include, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the user associated to the access token.
         * @summary Get the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersCurrent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUsersCurrent(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a user by their given ID.
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUserId(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUsersUserId(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Allows the current user to update their password.
         * @summary Reset  password
         * @param {AccountPasswordResetBody} [accountPasswordResetBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccountPassword(accountPasswordResetBody?: AccountPasswordResetBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).postAccountPassword(accountPasswordResetBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new user resource
         * @summary Create a new user
         * @param {CreateUserBody} [createUserBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsers(createUserBody?: CreateUserBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).postUsers(createUserBody, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a user record from their ID.
         * @summary 
         * @param {string} userId 
         * @param {InlineObject26} [inlineObject26] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersUserId(userId: string, inlineObject26?: InlineObject26, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).putUsersUserId(userId, inlineObject26, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete a user by their given ID.
         * @summary 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserId(userId: string, options?: any): AxiosPromise<void> {
            return UsersApiFp(configuration).deleteUsersUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of all users
         * @summary Get all users
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(include?: string, perPage?: number, options?: any): AxiosPromise<UserCollection> {
            return UsersApiFp(configuration).getUsers(include, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user associated to the access token.
         * @summary Get the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCurrent(options?: any): AxiosPromise<UserResponse> {
            return UsersApiFp(configuration).getUsersCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user by their given ID.
         * @summary Get user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserId(userId: string, options?: any): AxiosPromise<UserResponse> {
            return UsersApiFp(configuration).getUsersUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows the current user to update their password.
         * @summary Reset  password
         * @param {AccountPasswordResetBody} [accountPasswordResetBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountPassword(accountPasswordResetBody?: AccountPasswordResetBody, options?: any): AxiosPromise<Message> {
            return UsersApiFp(configuration).postAccountPassword(accountPasswordResetBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user resource
         * @summary Create a new user
         * @param {CreateUserBody} [createUserBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(createUserBody?: CreateUserBody, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).postUsers(createUserBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a user record from their ID.
         * @summary 
         * @param {string} userId 
         * @param {InlineObject26} [inlineObject26] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserId(userId: string, inlineObject26?: InlineObject26, options?: any): AxiosPromise<UserResponse> {
            return UsersApiFp(configuration).putUsersUserId(userId, inlineObject26, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Delete a user by their given ID.
     * @summary 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUsersUserId(userId: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUsersUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a paginated list of all users
     * @summary Get all users
     * @param {string} [include] Comma separated includes for the resource
     * @param {number} [perPage] How many results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(include?: string, perPage?: number, options?: any) {
        return UsersApiFp(this.configuration).getUsers(include, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the user associated to the access token.
     * @summary Get the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersCurrent(options?: any) {
        return UsersApiFp(this.configuration).getUsersCurrent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user by their given ID.
     * @summary Get user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsersUserId(userId: string, options?: any) {
        return UsersApiFp(this.configuration).getUsersUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows the current user to update their password.
     * @summary Reset  password
     * @param {AccountPasswordResetBody} [accountPasswordResetBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postAccountPassword(accountPasswordResetBody?: AccountPasswordResetBody, options?: any) {
        return UsersApiFp(this.configuration).postAccountPassword(accountPasswordResetBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user resource
     * @summary Create a new user
     * @param {CreateUserBody} [createUserBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public postUsers(createUserBody?: CreateUserBody, options?: any) {
        return UsersApiFp(this.configuration).postUsers(createUserBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a user record from their ID.
     * @summary 
     * @param {string} userId 
     * @param {InlineObject26} [inlineObject26] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public putUsersUserId(userId: string, inlineObject26?: InlineObject26, options?: any) {
        return UsersApiFp(this.configuration).putUsersUserId(userId, inlineObject26, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VersioningApi - axios parameter creator
 * @export
 */
export const VersioningApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Restores a model version
         * @summary Restore model
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVersionsModelIdRestore: async (modelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new RequiredError('modelId','Required parameter modelId was null or undefined when calling postVersionsModelIdRestore.');
            }
            const localVarPath = `/versions/{modelId}/restore`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersioningApi - functional programming interface
 * @export
 */
export const VersioningApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Restores a model version
         * @summary Restore model
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postVersionsModelIdRestore(modelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await VersioningApiAxiosParamCreator(configuration).postVersionsModelIdRestore(modelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VersioningApi - factory interface
 * @export
 */
export const VersioningApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Restores a model version
         * @summary Restore model
         * @param {string} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVersionsModelIdRestore(modelId: string, options?: any): AxiosPromise<object> {
            return VersioningApiFp(configuration).postVersionsModelIdRestore(modelId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersioningApi - object-oriented interface
 * @export
 * @class VersioningApi
 * @extends {BaseAPI}
 */
export class VersioningApi extends BaseAPI {
    /**
     * Restores a model version
     * @summary Restore model
     * @param {string} modelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersioningApi
     */
    public postVersionsModelIdRestore(modelId: string, options?: any) {
        return VersioningApiFp(this.configuration).postVersionsModelIdRestore(modelId, options).then((request) => request(this.axios, this.basePath));
    }

}



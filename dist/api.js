"use strict";
// tslint:disable
/**
 * GetCandy
 * The GetCandy API
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@getcandy.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VersioningApi = exports.VersioningApiFactory = exports.VersioningApiFp = exports.VersioningApiAxiosParamCreator = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.TaxesApi = exports.TaxesApiFactory = exports.TaxesApiFp = exports.TaxesApiAxiosParamCreator = exports.TagsApi = exports.TagsApiFactory = exports.TagsApiFp = exports.TagsApiAxiosParamCreator = exports.ShippingApi = exports.ShippingApiFactory = exports.ShippingApiFp = exports.ShippingApiAxiosParamCreator = exports.SettingsApi = exports.SettingsApiFactory = exports.SettingsApiFp = exports.SettingsApiAxiosParamCreator = exports.SearchApi = exports.SearchApiFactory = exports.SearchApiFp = exports.SearchApiAxiosParamCreator = exports.RoutesApi = exports.RoutesApiFactory = exports.RoutesApiFp = exports.RoutesApiAxiosParamCreator = exports.RootApi = exports.RootApiFactory = exports.RootApiFp = exports.RootApiAxiosParamCreator = exports.ReportsApi = exports.ReportsApiFactory = exports.ReportsApiFp = exports.ReportsApiAxiosParamCreator = exports.RecycleBinApi = exports.RecycleBinApiFactory = exports.RecycleBinApiFp = exports.RecycleBinApiAxiosParamCreator = exports.ProductsApi = exports.ProductsApiFactory = exports.ProductsApiFp = exports.ProductsApiAxiosParamCreator = exports.ProductVariantsApi = exports.ProductVariantsApiFactory = exports.ProductVariantsApiFp = exports.ProductVariantsApiAxiosParamCreator = exports.ProductFamiliesApi = exports.ProductFamiliesApiFactory = exports.ProductFamiliesApiFp = exports.ProductFamiliesApiAxiosParamCreator = exports.PaymentsApi = exports.PaymentsApiFactory = exports.PaymentsApiFp = exports.PaymentsApiAxiosParamCreator = exports.OrdersApi = exports.OrdersApiFactory = exports.OrdersApiFp = exports.OrdersApiAxiosParamCreator = exports.LayoutsApi = exports.LayoutsApiFactory = exports.LayoutsApiFp = exports.LayoutsApiAxiosParamCreator = exports.LanguagesApi = exports.LanguagesApiFactory = exports.LanguagesApiFp = exports.LanguagesApiAxiosParamCreator = exports.DiscountsApi = exports.DiscountsApiFactory = exports.DiscountsApiFp = exports.DiscountsApiAxiosParamCreator = exports.CustomersApi = exports.CustomersApiFactory = exports.CustomersApiFp = exports.CustomersApiAxiosParamCreator = exports.CustomerGroupsApi = exports.CustomerGroupsApiFactory = exports.CustomerGroupsApiFp = exports.CustomerGroupsApiAxiosParamCreator = exports.CurrenciesApi = exports.CurrenciesApiFactory = exports.CurrenciesApiFp = exports.CurrenciesApiAxiosParamCreator = exports.CountriesApi = exports.CountriesApiFactory = exports.CountriesApiFp = exports.CountriesApiAxiosParamCreator = exports.CollectionsApi = exports.CollectionsApiFactory = exports.CollectionsApiFp = exports.CollectionsApiAxiosParamCreator = exports.ChannelsApi = exports.ChannelsApiFactory = exports.ChannelsApiFp = exports.ChannelsApiAxiosParamCreator = exports.CategoriesApi = exports.CategoriesApiFactory = exports.CategoriesApiFp = exports.CategoriesApiAxiosParamCreator = exports.BasketsApi = exports.BasketsApiFactory = exports.BasketsApiFp = exports.BasketsApiAxiosParamCreator = exports.AttributesApi = exports.AttributesApiFactory = exports.AttributesApiFp = exports.AttributesApiAxiosParamCreator = exports.AssociationsApi = exports.AssociationsApiFactory = exports.AssociationsApiFp = exports.AssociationsApiAxiosParamCreator = exports.AssetsApi = exports.AssetsApiFactory = exports.AssetsApiFp = exports.AssetsApiAxiosParamCreator = exports.AddressesApi = exports.AddressesApiFactory = exports.AddressesApiFp = exports.AddressesApiAxiosParamCreator = exports.AccountApi = exports.AccountApiFactory = exports.AccountApiFp = exports.AccountApiAxiosParamCreator = exports.InlineObject26TypeEnum = void 0;
const globalImportUrl = require("url");
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("./base");
/**
    * @export
    * @enum {string}
    */
var InlineObject26TypeEnum;
(function (InlineObject26TypeEnum) {
    InlineObject26TypeEnum["Standard"] = "standard";
    InlineObject26TypeEnum["Dhl"] = "dhl";
    InlineObject26TypeEnum["Regional"] = "regional";
})(InlineObject26TypeEnum = exports.InlineObject26TypeEnum || (exports.InlineObject26TypeEnum = {}));
/**
 * AccountApi - axios parameter creator
 * @export
 */
exports.AccountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Allows the current user to update their password.
         * @summary Reset password
         * @param {AccountPasswordResetBody} [accountPasswordResetBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountPassword: (accountPasswordResetBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/account/password`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof accountPasswordResetBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(accountPasswordResetBody !== undefined ? accountPasswordResetBody : {}) : (accountPasswordResetBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AccountApi - functional programming interface
 * @export
 */
exports.AccountApiFp = function (configuration) {
    return {
        /**
         * Allows the current user to update their password.
         * @summary Reset password
         * @param {AccountPasswordResetBody} [accountPasswordResetBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountPassword(accountPasswordResetBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AccountApiAxiosParamCreator(configuration).postAccountPassword(accountPasswordResetBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AccountApi - factory interface
 * @export
 */
exports.AccountApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Allows the current user to update their password.
         * @summary Reset password
         * @param {AccountPasswordResetBody} [accountPasswordResetBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccountPassword(accountPasswordResetBody, options) {
            return exports.AccountApiFp(configuration).postAccountPassword(accountPasswordResetBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
class AccountApi extends base_1.BaseAPI {
    /**
     * Allows the current user to update their password.
     * @summary Reset password
     * @param {AccountPasswordResetBody} [accountPasswordResetBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    postAccountPassword(accountPasswordResetBody, options) {
        return exports.AccountApiFp(this.configuration).postAccountPassword(accountPasswordResetBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountApi = AccountApi;
/**
 * AddressesApi - axios parameter creator
 * @export
 */
exports.AddressesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete an existing address
         * @summary
         * @param {string} addressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddressesAddressId: (addressId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'addressId' is not null or undefined
            if (addressId === null || addressId === undefined) {
                throw new base_1.RequiredError('addressId', 'Required parameter addressId was null or undefined when calling deleteAddressesAddressId.');
            }
            const localVarPath = `/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to create a new address
         * @summary Create new address
         * @param {string} firstname
         * @param {string} lastname
         * @param {string} address
         * @param {string} city
         * @param {string} state
         * @param {string} postalCode
         * @param {string} countryId
         * @param {string} [salutation]
         * @param {string} [companyName]
         * @param {string} [email]
         * @param {string} [phone]
         * @param {string} [addressTwo]
         * @param {string} [addressThree]
         * @param {boolean} [shipping]
         * @param {string} [userId]
         * @param {string} [customerId]
         * @param {boolean} [billing]
         * @param {boolean} [_default]
         * @param {string} [lastUsedAt]
         * @param {string} [deliveryInstructions]
         * @param {Array<object>} [meta]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddresses: (firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, customerId, billing, _default, lastUsedAt, deliveryInstructions, meta, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'firstname' is not null or undefined
            if (firstname === null || firstname === undefined) {
                throw new base_1.RequiredError('firstname', 'Required parameter firstname was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'lastname' is not null or undefined
            if (lastname === null || lastname === undefined) {
                throw new base_1.RequiredError('lastname', 'Required parameter lastname was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'address' is not null or undefined
            if (address === null || address === undefined) {
                throw new base_1.RequiredError('address', 'Required parameter address was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'city' is not null or undefined
            if (city === null || city === undefined) {
                throw new base_1.RequiredError('city', 'Required parameter city was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'state' is not null or undefined
            if (state === null || state === undefined) {
                throw new base_1.RequiredError('state', 'Required parameter state was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'postalCode' is not null or undefined
            if (postalCode === null || postalCode === undefined) {
                throw new base_1.RequiredError('postalCode', 'Required parameter postalCode was null or undefined when calling postAddresses.');
            }
            // verify required parameter 'countryId' is not null or undefined
            if (countryId === null || countryId === undefined) {
                throw new base_1.RequiredError('countryId', 'Required parameter countryId was null or undefined when calling postAddresses.');
            }
            const localVarPath = `/addresses`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (salutation !== undefined) {
                localVarFormParams.append('salutation', salutation);
            }
            if (firstname !== undefined) {
                localVarFormParams.append('firstname', firstname);
            }
            if (lastname !== undefined) {
                localVarFormParams.append('lastname', lastname);
            }
            if (companyName !== undefined) {
                localVarFormParams.append('company_name', companyName);
            }
            if (email !== undefined) {
                localVarFormParams.append('email', email);
            }
            if (phone !== undefined) {
                localVarFormParams.append('phone', phone);
            }
            if (address !== undefined) {
                localVarFormParams.append('address', address);
            }
            if (addressTwo !== undefined) {
                localVarFormParams.append('address_two', addressTwo);
            }
            if (addressThree !== undefined) {
                localVarFormParams.append('address_three', addressThree);
            }
            if (city !== undefined) {
                localVarFormParams.append('city', city);
            }
            if (state !== undefined) {
                localVarFormParams.append('state', state);
            }
            if (postalCode !== undefined) {
                localVarFormParams.append('postal_code', postalCode);
            }
            if (countryId !== undefined) {
                localVarFormParams.append('country_id', countryId);
            }
            if (shipping !== undefined) {
                localVarFormParams.append('shipping', shipping);
            }
            if (userId !== undefined) {
                localVarFormParams.append('user_id', userId);
            }
            if (customerId !== undefined) {
                localVarFormParams.append('customer_id', customerId);
            }
            if (billing !== undefined) {
                localVarFormParams.append('billing', billing);
            }
            if (_default !== undefined) {
                localVarFormParams.append('default', _default);
            }
            if (lastUsedAt !== undefined) {
                localVarFormParams.append('last_used_at', lastUsedAt);
            }
            if (deliveryInstructions !== undefined) {
                localVarFormParams.append('delivery_instructions', deliveryInstructions);
            }
            if (meta) {
                localVarFormParams.append('meta', meta.join(base_1.COLLECTION_FORMATS.csv));
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to update an existing address
         * @summary Update existing address
         * @param {string} addressId
         * @param {UpdateAddressBody} [updateAddressBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAddresses: (addressId, updateAddressBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'addressId' is not null or undefined
            if (addressId === null || addressId === undefined) {
                throw new base_1.RequiredError('addressId', 'Required parameter addressId was null or undefined when calling putAddresses.');
            }
            const localVarPath = `/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/javascript';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof updateAddressBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateAddressBody !== undefined ? updateAddressBody : {}) : (updateAddressBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AddressesApi - functional programming interface
 * @export
 */
exports.AddressesApiFp = function (configuration) {
    return {
        /**
         * Delete an existing address
         * @summary
         * @param {string} addressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddressesAddressId(addressId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AddressesApiAxiosParamCreator(configuration).deleteAddressesAddressId(addressId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint allows you to create a new address
         * @summary Create new address
         * @param {string} firstname
         * @param {string} lastname
         * @param {string} address
         * @param {string} city
         * @param {string} state
         * @param {string} postalCode
         * @param {string} countryId
         * @param {string} [salutation]
         * @param {string} [companyName]
         * @param {string} [email]
         * @param {string} [phone]
         * @param {string} [addressTwo]
         * @param {string} [addressThree]
         * @param {boolean} [shipping]
         * @param {string} [userId]
         * @param {string} [customerId]
         * @param {boolean} [billing]
         * @param {boolean} [_default]
         * @param {string} [lastUsedAt]
         * @param {string} [deliveryInstructions]
         * @param {Array<object>} [meta]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddresses(firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, customerId, billing, _default, lastUsedAt, deliveryInstructions, meta, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AddressesApiAxiosParamCreator(configuration).postAddresses(firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, customerId, billing, _default, lastUsedAt, deliveryInstructions, meta, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint allows you to update an existing address
         * @summary Update existing address
         * @param {string} addressId
         * @param {UpdateAddressBody} [updateAddressBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAddresses(addressId, updateAddressBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AddressesApiAxiosParamCreator(configuration).putAddresses(addressId, updateAddressBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AddressesApi - factory interface
 * @export
 */
exports.AddressesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete an existing address
         * @summary
         * @param {string} addressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddressesAddressId(addressId, options) {
            return exports.AddressesApiFp(configuration).deleteAddressesAddressId(addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to create a new address
         * @summary Create new address
         * @param {string} firstname
         * @param {string} lastname
         * @param {string} address
         * @param {string} city
         * @param {string} state
         * @param {string} postalCode
         * @param {string} countryId
         * @param {string} [salutation]
         * @param {string} [companyName]
         * @param {string} [email]
         * @param {string} [phone]
         * @param {string} [addressTwo]
         * @param {string} [addressThree]
         * @param {boolean} [shipping]
         * @param {string} [userId]
         * @param {string} [customerId]
         * @param {boolean} [billing]
         * @param {boolean} [_default]
         * @param {string} [lastUsedAt]
         * @param {string} [deliveryInstructions]
         * @param {Array<object>} [meta]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAddresses(firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, customerId, billing, _default, lastUsedAt, deliveryInstructions, meta, options) {
            return exports.AddressesApiFp(configuration).postAddresses(firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, customerId, billing, _default, lastUsedAt, deliveryInstructions, meta, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to update an existing address
         * @summary Update existing address
         * @param {string} addressId
         * @param {UpdateAddressBody} [updateAddressBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAddresses(addressId, updateAddressBody, options) {
            return exports.AddressesApiFp(configuration).putAddresses(addressId, updateAddressBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AddressesApi - object-oriented interface
 * @export
 * @class AddressesApi
 * @extends {BaseAPI}
 */
class AddressesApi extends base_1.BaseAPI {
    /**
     * Delete an existing address
     * @summary
     * @param {string} addressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    deleteAddressesAddressId(addressId, options) {
        return exports.AddressesApiFp(this.configuration).deleteAddressesAddressId(addressId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to create a new address
     * @summary Create new address
     * @param {string} firstname
     * @param {string} lastname
     * @param {string} address
     * @param {string} city
     * @param {string} state
     * @param {string} postalCode
     * @param {string} countryId
     * @param {string} [salutation]
     * @param {string} [companyName]
     * @param {string} [email]
     * @param {string} [phone]
     * @param {string} [addressTwo]
     * @param {string} [addressThree]
     * @param {boolean} [shipping]
     * @param {string} [userId]
     * @param {string} [customerId]
     * @param {boolean} [billing]
     * @param {boolean} [_default]
     * @param {string} [lastUsedAt]
     * @param {string} [deliveryInstructions]
     * @param {Array<object>} [meta]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    postAddresses(firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, customerId, billing, _default, lastUsedAt, deliveryInstructions, meta, options) {
        return exports.AddressesApiFp(this.configuration).postAddresses(firstname, lastname, address, city, state, postalCode, countryId, salutation, companyName, email, phone, addressTwo, addressThree, shipping, userId, customerId, billing, _default, lastUsedAt, deliveryInstructions, meta, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to update an existing address
     * @summary Update existing address
     * @param {string} addressId
     * @param {UpdateAddressBody} [updateAddressBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressesApi
     */
    putAddresses(addressId, updateAddressBody, options) {
        return exports.AddressesApiFp(this.configuration).putAddresses(addressId, updateAddressBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AddressesApi = AddressesApi;
/**
 * AssetsApi - axios parameter creator
 * @export
 */
exports.AssetsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Upload an asset to a model
         * @summary Create Asset
         * @param {string} [mimeType] Required when passing url
         * @param {string} [url] External URL to file to upload, required without file
         * @param {object} [file]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssets: (mimeType, url, file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/assets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (mimeType !== undefined) {
                localVarFormParams.append('mime_type', mimeType);
            }
            if (url !== undefined) {
                localVarFormParams.append('url', url);
            }
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detaches any assets from a given model. Useful if you want to remove certain assets from a product (or another model) without deleting the asset itself.
         * @summary Detach an asset from it\'s model
         * @param {string} assetId The hashed asset id
         * @param {string} ownerId The hashed owner id
         * @param {AssetDetachBody} [assetDetachBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsAssetIdDetachOwnerId: (assetId, ownerId, assetDetachBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'assetId' is not null or undefined
            if (assetId === null || assetId === undefined) {
                throw new base_1.RequiredError('assetId', 'Required parameter assetId was null or undefined when calling postAssetsAssetIdDetachOwnerId.');
            }
            // verify required parameter 'ownerId' is not null or undefined
            if (ownerId === null || ownerId === undefined) {
                throw new base_1.RequiredError('ownerId', 'Required parameter ownerId was null or undefined when calling postAssetsAssetIdDetachOwnerId.');
            }
            const localVarPath = `/assets/{assetId}/detach/{ownerId}`
                .replace(`{${"assetId"}}`, encodeURIComponent(String(assetId)))
                .replace(`{${"ownerId"}}`, encodeURIComponent(String(ownerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof assetDetachBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(assetDetachBody !== undefined ? assetDetachBody : {}) : (assetDetachBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to upload an asset without having to attach it to a model. This is good for one time uploads where you just want to get back a URL
         * @summary Simple asset upload
         * @param {object} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsSimple: (file, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new base_1.RequiredError('file', 'Required parameter file was null or undefined when calling postAssetsSimple.');
            }
            const localVarPath = `/assets/simple`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update all assets in the given array of ids.
         * @summary Update Assets
         * @param {UpdateAssetBody} [updateAssetBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssets: (updateAssetBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/assets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof updateAssetBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateAssetBody !== undefined ? updateAssetBody : {}) : (updateAssetBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AssetsApi - functional programming interface
 * @export
 */
exports.AssetsApiFp = function (configuration) {
    return {
        /**
         * Upload an asset to a model
         * @summary Create Asset
         * @param {string} [mimeType] Required when passing url
         * @param {string} [url] External URL to file to upload, required without file
         * @param {object} [file]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssets(mimeType, url, file, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AssetsApiAxiosParamCreator(configuration).postAssets(mimeType, url, file, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Detaches any assets from a given model. Useful if you want to remove certain assets from a product (or another model) without deleting the asset itself.
         * @summary Detach an asset from it\'s model
         * @param {string} assetId The hashed asset id
         * @param {string} ownerId The hashed owner id
         * @param {AssetDetachBody} [assetDetachBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsAssetIdDetachOwnerId(assetId, ownerId, assetDetachBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AssetsApiAxiosParamCreator(configuration).postAssetsAssetIdDetachOwnerId(assetId, ownerId, assetDetachBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint allows you to upload an asset without having to attach it to a model. This is good for one time uploads where you just want to get back a URL
         * @summary Simple asset upload
         * @param {object} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsSimple(file, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AssetsApiAxiosParamCreator(configuration).postAssetsSimple(file, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update all assets in the given array of ids.
         * @summary Update Assets
         * @param {UpdateAssetBody} [updateAssetBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssets(updateAssetBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AssetsApiAxiosParamCreator(configuration).putAssets(updateAssetBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AssetsApi - factory interface
 * @export
 */
exports.AssetsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Upload an asset to a model
         * @summary Create Asset
         * @param {string} [mimeType] Required when passing url
         * @param {string} [url] External URL to file to upload, required without file
         * @param {object} [file]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssets(mimeType, url, file, options) {
            return exports.AssetsApiFp(configuration).postAssets(mimeType, url, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches any assets from a given model. Useful if you want to remove certain assets from a product (or another model) without deleting the asset itself.
         * @summary Detach an asset from it\'s model
         * @param {string} assetId The hashed asset id
         * @param {string} ownerId The hashed owner id
         * @param {AssetDetachBody} [assetDetachBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsAssetIdDetachOwnerId(assetId, ownerId, assetDetachBody, options) {
            return exports.AssetsApiFp(configuration).postAssetsAssetIdDetachOwnerId(assetId, ownerId, assetDetachBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to upload an asset without having to attach it to a model. This is good for one time uploads where you just want to get back a URL
         * @summary Simple asset upload
         * @param {object} file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetsSimple(file, options) {
            return exports.AssetsApiFp(configuration).postAssetsSimple(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all assets in the given array of ids.
         * @summary Update Assets
         * @param {UpdateAssetBody} [updateAssetBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssets(updateAssetBody, options) {
            return exports.AssetsApiFp(configuration).putAssets(updateAssetBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
class AssetsApi extends base_1.BaseAPI {
    /**
     * Upload an asset to a model
     * @summary Create Asset
     * @param {string} [mimeType] Required when passing url
     * @param {string} [url] External URL to file to upload, required without file
     * @param {object} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    postAssets(mimeType, url, file, options) {
        return exports.AssetsApiFp(this.configuration).postAssets(mimeType, url, file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detaches any assets from a given model. Useful if you want to remove certain assets from a product (or another model) without deleting the asset itself.
     * @summary Detach an asset from it\'s model
     * @param {string} assetId The hashed asset id
     * @param {string} ownerId The hashed owner id
     * @param {AssetDetachBody} [assetDetachBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    postAssetsAssetIdDetachOwnerId(assetId, ownerId, assetDetachBody, options) {
        return exports.AssetsApiFp(this.configuration).postAssetsAssetIdDetachOwnerId(assetId, ownerId, assetDetachBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to upload an asset without having to attach it to a model. This is good for one time uploads where you just want to get back a URL
     * @summary Simple asset upload
     * @param {object} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    postAssetsSimple(file, options) {
        return exports.AssetsApiFp(this.configuration).postAssetsSimple(file, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update all assets in the given array of ids.
     * @summary Update Assets
     * @param {UpdateAssetBody} [updateAssetBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    putAssets(updateAssetBody, options) {
        return exports.AssetsApiFp(this.configuration).putAssets(updateAssetBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AssetsApi = AssetsApi;
/**
 * AssociationsApi - axios parameter creator
 * @export
 */
exports.AssociationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a paginated response of association groups available in the system
         * @summary Paginated array of association groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssociationsGroups: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/associations/groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AssociationsApi - functional programming interface
 * @export
 */
exports.AssociationsApiFp = function (configuration) {
    return {
        /**
         * Returns a paginated response of association groups available in the system
         * @summary Paginated array of association groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssociationsGroups(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AssociationsApiAxiosParamCreator(configuration).getAssociationsGroups(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AssociationsApi - factory interface
 * @export
 */
exports.AssociationsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns a paginated response of association groups available in the system
         * @summary Paginated array of association groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssociationsGroups(options) {
            return exports.AssociationsApiFp(configuration).getAssociationsGroups(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AssociationsApi - object-oriented interface
 * @export
 * @class AssociationsApi
 * @extends {BaseAPI}
 */
class AssociationsApi extends base_1.BaseAPI {
    /**
     * Returns a paginated response of association groups available in the system
     * @summary Paginated array of association groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssociationsApi
     */
    getAssociationsGroups(options) {
        return exports.AssociationsApiFp(this.configuration).getAssociationsGroups(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AssociationsApi = AssociationsApi;
/**
 * AttributesApi - axios parameter creator
 * @export
 */
exports.AttributesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes an attribute group
         * @summary Delete an attribute group
         * @param {string} attributeGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributeGroupsAttributeGroupId: (attributeGroupId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'attributeGroupId' is not null or undefined
            if (attributeGroupId === null || attributeGroupId === undefined) {
                throw new base_1.RequiredError('attributeGroupId', 'Required parameter attributeGroupId was null or undefined when calling deleteAttributeGroupsAttributeGroupId.');
            }
            const localVarPath = `/attribute-groups/{attributeGroupId}`
                .replace(`{${"attributeGroupId"}}`, encodeURIComponent(String(attributeGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete an attribute.
         * @summary Delete an attribute
         * @param {string} attributeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributesAttributeId: (attributeId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'attributeId' is not null or undefined
            if (attributeId === null || attributeId === undefined) {
                throw new base_1.RequiredError('attributeId', 'Required parameter attributeId was null or undefined when calling deleteAttributesAttributeId.');
            }
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a paginated list of available attribute groups
         * @summary Paginated list of Attribute Groups
         * @param {boolean} [allRecords] Will skip pagination and return all records
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroups: (allRecords, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/attribute-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (allRecords !== undefined) {
                localVarQueryParameter['all_records'] = allRecords;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a single attribute group
         * @summary Get a single attribute group
         * @param {string} attributeGroupId
         * @param {number} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroupsAttributeGroupId: (attributeGroupId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'attributeGroupId' is not null or undefined
            if (attributeGroupId === null || attributeGroupId === undefined) {
                throw new base_1.RequiredError('attributeGroupId', 'Required parameter attributeGroupId was null or undefined when calling getAttributeGroupsAttributeGroupId.');
            }
            const localVarPath = `/attribute-groups/{attributeGroupId}`
                .replace(`{${"attributeGroupId"}}`, encodeURIComponent(String(attributeGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Return a paged array of attributes
         * @summary Get Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/attributes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an attribute from a given ID.
         * @summary Get an attribute
         * @param {string} attributeId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesAttributeId: (attributeId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'attributeId' is not null or undefined
            if (attributeId === null || attributeId === undefined) {
                throw new base_1.RequiredError('attributeId', 'Required parameter attributeId was null or undefined when calling getAttributesAttributeId.');
            }
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create an Attribute Group
         * @param {CreateAttributeGroupBodyName} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributeGroups: (name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/attribute-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new attribute
         * @summary Create Attribute
         * @param {InlineObject} [inlineObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributes: (inlineObject, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/attributes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject !== undefined ? inlineObject : {}) : (inlineObject || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an attribute group.
         * @summary Update an attribute group
         * @param {string} attributeGroupId
         * @param {AttributeGroup} [attributeGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsAttributeGroupId: (attributeGroupId, attributeGroup, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'attributeGroupId' is not null or undefined
            if (attributeGroupId === null || attributeGroupId === undefined) {
                throw new base_1.RequiredError('attributeGroupId', 'Required parameter attributeGroupId was null or undefined when calling putAttributeGroupsAttributeGroupId.');
            }
            const localVarPath = `/attribute-groups/{attributeGroupId}`
                .replace(`{${"attributeGroupId"}}`, encodeURIComponent(String(attributeGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof attributeGroup !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(attributeGroup !== undefined ? attributeGroup : {}) : (attributeGroup || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends a request to reorder the attribute groups in the system
         * @summary Reorder attribute groups
         * @param {AttributeGroupReorderBody} [attributeGroupReorderBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsReorder: (attributeGroupReorderBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/attribute-groups/reorder`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof attributeGroupReorderBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(attributeGroupReorderBody !== undefined ? attributeGroupReorderBody : {}) : (attributeGroupReorderBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an attribute from a given ID.
         * @summary Update an attribute
         * @param {string} attributeId
         * @param {UpdateAttributesBody} [updateAttributesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesAttributeId: (attributeId, updateAttributesBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'attributeId' is not null or undefined
            if (attributeId === null || attributeId === undefined) {
                throw new base_1.RequiredError('attributeId', 'Required parameter attributeId was null or undefined when calling putAttributesAttributeId.');
            }
            const localVarPath = `/attributes/{attributeId}`
                .replace(`{${"attributeId"}}`, encodeURIComponent(String(attributeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof updateAttributesBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateAttributesBody !== undefined ? updateAttributesBody : {}) : (updateAttributesBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows you to reorder a target category in relation to another.
         * @summary Update request to reorder attributes
         * @param {AttributesReorderBody} [attributesReorderBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesOrder: (attributesReorderBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/attributes/order`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof attributesReorderBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(attributesReorderBody !== undefined ? attributesReorderBody : {}) : (attributesReorderBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * AttributesApi - functional programming interface
 * @export
 */
exports.AttributesApiFp = function (configuration) {
    return {
        /**
         * Deletes an attribute group
         * @summary Delete an attribute group
         * @param {string} attributeGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributeGroupsAttributeGroupId(attributeGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).deleteAttributeGroupsAttributeGroupId(attributeGroupId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Delete an attribute.
         * @summary Delete an attribute
         * @param {string} attributeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributesAttributeId(attributeId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).deleteAttributesAttributeId(attributeId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a paginated list of available attribute groups
         * @summary Paginated list of Attribute Groups
         * @param {boolean} [allRecords] Will skip pagination and return all records
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroups(allRecords, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).getAttributeGroups(allRecords, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Gets a single attribute group
         * @summary Get a single attribute group
         * @param {string} attributeGroupId
         * @param {number} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroupsAttributeGroupId(attributeGroupId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).getAttributeGroupsAttributeGroupId(attributeGroupId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Return a paged array of attributes
         * @summary Get Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).getAttributes(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns an attribute from a given ID.
         * @summary Get an attribute
         * @param {string} attributeId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesAttributeId(attributeId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).getAttributesAttributeId(attributeId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Create an Attribute Group
         * @param {CreateAttributeGroupBodyName} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributeGroups(name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).postAttributeGroups(name, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new attribute
         * @summary Create Attribute
         * @param {InlineObject} [inlineObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributes(inlineObject, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).postAttributes(inlineObject, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates an attribute group.
         * @summary Update an attribute group
         * @param {string} attributeGroupId
         * @param {AttributeGroup} [attributeGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsAttributeGroupId(attributeGroupId, attributeGroup, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).putAttributeGroupsAttributeGroupId(attributeGroupId, attributeGroup, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sends a request to reorder the attribute groups in the system
         * @summary Reorder attribute groups
         * @param {AttributeGroupReorderBody} [attributeGroupReorderBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsReorder(attributeGroupReorderBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).putAttributeGroupsReorder(attributeGroupReorderBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates an attribute from a given ID.
         * @summary Update an attribute
         * @param {string} attributeId
         * @param {UpdateAttributesBody} [updateAttributesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesAttributeId(attributeId, updateAttributesBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).putAttributesAttributeId(attributeId, updateAttributesBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Allows you to reorder a target category in relation to another.
         * @summary Update request to reorder attributes
         * @param {AttributesReorderBody} [attributesReorderBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesOrder(attributesReorderBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.AttributesApiAxiosParamCreator(configuration).putAttributesOrder(attributesReorderBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * AttributesApi - factory interface
 * @export
 */
exports.AttributesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Deletes an attribute group
         * @summary Delete an attribute group
         * @param {string} attributeGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributeGroupsAttributeGroupId(attributeGroupId, options) {
            return exports.AttributesApiFp(configuration).deleteAttributeGroupsAttributeGroupId(attributeGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an attribute.
         * @summary Delete an attribute
         * @param {string} attributeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttributesAttributeId(attributeId, options) {
            return exports.AttributesApiFp(configuration).deleteAttributesAttributeId(attributeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of available attribute groups
         * @summary Paginated list of Attribute Groups
         * @param {boolean} [allRecords] Will skip pagination and return all records
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroups(allRecords, include, options) {
            return exports.AttributesApiFp(configuration).getAttributeGroups(allRecords, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a single attribute group
         * @summary Get a single attribute group
         * @param {string} attributeGroupId
         * @param {number} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributeGroupsAttributeGroupId(attributeGroupId, include, options) {
            return exports.AttributesApiFp(configuration).getAttributeGroupsAttributeGroupId(attributeGroupId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a paged array of attributes
         * @summary Get Attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributes(options) {
            return exports.AttributesApiFp(configuration).getAttributes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an attribute from a given ID.
         * @summary Get an attribute
         * @param {string} attributeId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttributesAttributeId(attributeId, include, options) {
            return exports.AttributesApiFp(configuration).getAttributesAttributeId(attributeId, include, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create an Attribute Group
         * @param {CreateAttributeGroupBodyName} [name]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributeGroups(name, options) {
            return exports.AttributesApiFp(configuration).postAttributeGroups(name, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new attribute
         * @summary Create Attribute
         * @param {InlineObject} [inlineObject]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAttributes(inlineObject, options) {
            return exports.AttributesApiFp(configuration).postAttributes(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an attribute group.
         * @summary Update an attribute group
         * @param {string} attributeGroupId
         * @param {AttributeGroup} [attributeGroup]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsAttributeGroupId(attributeGroupId, attributeGroup, options) {
            return exports.AttributesApiFp(configuration).putAttributeGroupsAttributeGroupId(attributeGroupId, attributeGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a request to reorder the attribute groups in the system
         * @summary Reorder attribute groups
         * @param {AttributeGroupReorderBody} [attributeGroupReorderBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributeGroupsReorder(attributeGroupReorderBody, options) {
            return exports.AttributesApiFp(configuration).putAttributeGroupsReorder(attributeGroupReorderBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an attribute from a given ID.
         * @summary Update an attribute
         * @param {string} attributeId
         * @param {UpdateAttributesBody} [updateAttributesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesAttributeId(attributeId, updateAttributesBody, options) {
            return exports.AttributesApiFp(configuration).putAttributesAttributeId(attributeId, updateAttributesBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to reorder a target category in relation to another.
         * @summary Update request to reorder attributes
         * @param {AttributesReorderBody} [attributesReorderBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAttributesOrder(attributesReorderBody, options) {
            return exports.AttributesApiFp(configuration).putAttributesOrder(attributesReorderBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AttributesApi - object-oriented interface
 * @export
 * @class AttributesApi
 * @extends {BaseAPI}
 */
class AttributesApi extends base_1.BaseAPI {
    /**
     * Deletes an attribute group
     * @summary Delete an attribute group
     * @param {string} attributeGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    deleteAttributeGroupsAttributeGroupId(attributeGroupId, options) {
        return exports.AttributesApiFp(this.configuration).deleteAttributeGroupsAttributeGroupId(attributeGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete an attribute.
     * @summary Delete an attribute
     * @param {string} attributeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    deleteAttributesAttributeId(attributeId, options) {
        return exports.AttributesApiFp(this.configuration).deleteAttributesAttributeId(attributeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a paginated list of available attribute groups
     * @summary Paginated list of Attribute Groups
     * @param {boolean} [allRecords] Will skip pagination and return all records
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    getAttributeGroups(allRecords, include, options) {
        return exports.AttributesApiFp(this.configuration).getAttributeGroups(allRecords, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a single attribute group
     * @summary Get a single attribute group
     * @param {string} attributeGroupId
     * @param {number} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    getAttributeGroupsAttributeGroupId(attributeGroupId, include, options) {
        return exports.AttributesApiFp(this.configuration).getAttributeGroupsAttributeGroupId(attributeGroupId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Return a paged array of attributes
     * @summary Get Attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    getAttributes(options) {
        return exports.AttributesApiFp(this.configuration).getAttributes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an attribute from a given ID.
     * @summary Get an attribute
     * @param {string} attributeId
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    getAttributesAttributeId(attributeId, include, options) {
        return exports.AttributesApiFp(this.configuration).getAttributesAttributeId(attributeId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create an Attribute Group
     * @param {CreateAttributeGroupBodyName} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    postAttributeGroups(name, options) {
        return exports.AttributesApiFp(this.configuration).postAttributeGroups(name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new attribute
     * @summary Create Attribute
     * @param {InlineObject} [inlineObject]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    postAttributes(inlineObject, options) {
        return exports.AttributesApiFp(this.configuration).postAttributes(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an attribute group.
     * @summary Update an attribute group
     * @param {string} attributeGroupId
     * @param {AttributeGroup} [attributeGroup]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    putAttributeGroupsAttributeGroupId(attributeGroupId, attributeGroup, options) {
        return exports.AttributesApiFp(this.configuration).putAttributeGroupsAttributeGroupId(attributeGroupId, attributeGroup, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends a request to reorder the attribute groups in the system
     * @summary Reorder attribute groups
     * @param {AttributeGroupReorderBody} [attributeGroupReorderBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    putAttributeGroupsReorder(attributeGroupReorderBody, options) {
        return exports.AttributesApiFp(this.configuration).putAttributeGroupsReorder(attributeGroupReorderBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an attribute from a given ID.
     * @summary Update an attribute
     * @param {string} attributeId
     * @param {UpdateAttributesBody} [updateAttributesBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    putAttributesAttributeId(attributeId, updateAttributesBody, options) {
        return exports.AttributesApiFp(this.configuration).putAttributesAttributeId(attributeId, updateAttributesBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to reorder a target category in relation to another.
     * @summary Update request to reorder attributes
     * @param {AttributesReorderBody} [attributesReorderBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttributesApi
     */
    putAttributesOrder(attributesReorderBody, options) {
        return exports.AttributesApiFp(this.configuration).putAttributesOrder(attributesReorderBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AttributesApi = AttributesApi;
/**
 * BasketsApi - axios parameter creator
 * @export
 */
exports.BasketsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Removes basket lines from a basket
         * @summary Delete basket lines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketLines: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/basket-lines`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a basket
         * @summary Delete a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketId: (basketId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling deleteBasketsBasketId.');
            }
            const localVarPath = `/baskets/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one.
         * @summary Remove discount
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketIdDiscounts: (basketId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling deleteBasketsBasketIdDiscounts.');
            }
            const localVarPath = `/baskets/{basketId}/discounts`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a paginated list of baskets
         * @summary Get baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaskets: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/baskets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a basket by it\'s ID
         * @summary Get basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsBasketId: (basketId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling getBasketsBasketId.');
            }
            const localVarPath = `/baskets/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This request will get the current active basket for a user
         * @summary Get the current basket for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsCurrent: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/baskets/current`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an authenticatd users saved baskets.
         * @summary Get a users saved baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsSaved: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/baskets/saved`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add lines to a basket
         * @summary Create basket lines
         * @param {CreateBasketLinesBody} [createBasketLinesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketLines: (createBasketLinesBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/basket-lines`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof createBasketLinesBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createBasketLinesBody !== undefined ? createBasketLinesBody : {}) : (createBasketLinesBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create Basket
         * @param {CreateBasketBody} [createBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBaskets: (createBasketBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/baskets`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof createBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createBasketBody !== undefined ? createBasketBody : {}) : (createBasketBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * A user is able to \"claim\" a guest basket.
         * @summary Allow a user to claim a basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdClaim: (basketId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling postBasketsBasketIdClaim.');
            }
            const localVarPath = `/baskets/{basketId}/claim`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows you to add custom meta information to a basket.
         * @summary Add meta information
         * @param {string} basketId
         * @param {AddBasketMetaBody} [addBasketMetaBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdMeta: (basketId, addBasketMetaBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling postBasketsBasketIdMeta.');
            }
            const localVarPath = `/baskets/{basketId}/meta`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof addBasketMetaBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(addBasketMetaBody !== undefined ? addBasketMetaBody : {}) : (addBasketMetaBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Saves a basket to a users account.
         * @summary Save a basket for a user
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdSave: (basketId, saveBasketBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling postBasketsBasketIdSave.');
            }
            const localVarPath = `/baskets/{basketId}/save`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof saveBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(saveBasketBody !== undefined ? saveBasketBody : {}) : (saveBasketBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
         * @summary Resolve a basket
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsResolve: (saveBasketBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/baskets/resolve`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof saveBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(saveBasketBody !== undefined ? saveBasketBody : {}) : (saveBasketBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a basket line based on it\'s ID.
         * @summary Update basket line
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineId: (basketLineId, basketLineUpdateBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketLineId' is not null or undefined
            if (basketLineId === null || basketLineId === undefined) {
                throw new base_1.RequiredError('basketLineId', 'Required parameter basketLineId was null or undefined when calling putBasketLinesBasketLineId.');
            }
            const localVarPath = `/basket-lines/{basketLineId}`
                .replace(`{${"basketLineId"}}`, encodeURIComponent(String(basketLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof basketLineUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(basketLineUpdateBody !== undefined ? basketLineUpdateBody : {}) : (basketLineUpdateBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update basket line quantity
         * @summary Update basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdAdd: (basketLineId, basketLineUpdateBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketLineId' is not null or undefined
            if (basketLineId === null || basketLineId === undefined) {
                throw new base_1.RequiredError('basketLineId', 'Required parameter basketLineId was null or undefined when calling putBasketLinesBasketLineIdAdd.');
            }
            const localVarPath = `/basket-lines/{basketLineId}/add`
                .replace(`{${"basketLineId"}}`, encodeURIComponent(String(basketLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof basketLineUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(basketLineUpdateBody !== undefined ? basketLineUpdateBody : {}) : (basketLineUpdateBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes quantity from a basket line
         * @summary Remove basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdRemove: (basketLineId, basketLineUpdateBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketLineId' is not null or undefined
            if (basketLineId === null || basketLineId === undefined) {
                throw new base_1.RequiredError('basketLineId', 'Required parameter basketLineId was null or undefined when calling putBasketLinesBasketLineIdRemove.');
            }
            const localVarPath = `/basket-lines/{basketLineId}/remove`
                .replace(`{${"basketLineId"}}`, encodeURIComponent(String(basketLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof basketLineUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(basketLineUpdateBody !== undefined ? basketLineUpdateBody : {}) : (basketLineUpdateBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates a basket
         * @summary Update a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsBasketId: (basketId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling putBasketsBasketId.');
            }
            const localVarPath = `/baskets/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates a saved basket on the API
         * @summary Update a saved basket
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsSavedBasketId: (basketId, saveBasketBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling putBasketsSavedBasketId.');
            }
            const localVarPath = `/baskets/saved/{basketId}`
                .replace(`{${"basketId"}}`, encodeURIComponent(String(basketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof saveBasketBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(saveBasketBody !== undefined ? saveBasketBody : {}) : (saveBasketBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BasketsApi - functional programming interface
 * @export
 */
exports.BasketsApiFp = function (configuration) {
    return {
        /**
         * Removes basket lines from a basket
         * @summary Delete basket lines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketLines(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).deleteBasketLines(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Deletes a basket
         * @summary Delete a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketId(basketId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).deleteBasketsBasketId(basketId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one.
         * @summary Remove discount
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketIdDiscounts(basketId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).deleteBasketsBasketIdDiscounts(basketId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a paginated list of baskets
         * @summary Get baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaskets(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).getBaskets(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a basket by it\'s ID
         * @summary Get basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsBasketId(basketId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).getBasketsBasketId(basketId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This request will get the current active basket for a user
         * @summary Get the current basket for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsCurrent(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).getBasketsCurrent(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns an authenticatd users saved baskets.
         * @summary Get a users saved baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsSaved(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).getBasketsSaved(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Add lines to a basket
         * @summary Create basket lines
         * @param {CreateBasketLinesBody} [createBasketLinesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketLines(createBasketLinesBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).postBasketLines(createBasketLinesBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Create Basket
         * @param {CreateBasketBody} [createBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBaskets(createBasketBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).postBaskets(createBasketBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * A user is able to \"claim\" a guest basket.
         * @summary Allow a user to claim a basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdClaim(basketId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).postBasketsBasketIdClaim(basketId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Allows you to add custom meta information to a basket.
         * @summary Add meta information
         * @param {string} basketId
         * @param {AddBasketMetaBody} [addBasketMetaBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdMeta(basketId, addBasketMetaBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).postBasketsBasketIdMeta(basketId, addBasketMetaBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Saves a basket to a users account.
         * @summary Save a basket for a user
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdSave(basketId, saveBasketBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).postBasketsBasketIdSave(basketId, saveBasketBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
         * @summary Resolve a basket
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsResolve(saveBasketBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).postBasketsResolve(saveBasketBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a basket line based on it\'s ID.
         * @summary Update basket line
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update basket line quantity
         * @summary Update basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Removes quantity from a basket line
         * @summary Remove basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates a basket
         * @summary Update a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsBasketId(basketId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).putBasketsBasketId(basketId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates a saved basket on the API
         * @summary Update a saved basket
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsSavedBasketId(basketId, saveBasketBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.BasketsApiAxiosParamCreator(configuration).putBasketsSavedBasketId(basketId, saveBasketBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * BasketsApi - factory interface
 * @export
 */
exports.BasketsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Removes basket lines from a basket
         * @summary Delete basket lines
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketLines(options) {
            return exports.BasketsApiFp(configuration).deleteBasketLines(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a basket
         * @summary Delete a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketId(basketId, options) {
            return exports.BasketsApiFp(configuration).deleteBasketsBasketId(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one.
         * @summary Remove discount
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBasketsBasketIdDiscounts(basketId, options) {
            return exports.BasketsApiFp(configuration).deleteBasketsBasketIdDiscounts(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of baskets
         * @summary Get baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaskets(options) {
            return exports.BasketsApiFp(configuration).getBaskets(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a basket by it\'s ID
         * @summary Get basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsBasketId(basketId, options) {
            return exports.BasketsApiFp(configuration).getBasketsBasketId(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will get the current active basket for a user
         * @summary Get the current basket for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsCurrent(options) {
            return exports.BasketsApiFp(configuration).getBasketsCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an authenticatd users saved baskets.
         * @summary Get a users saved baskets
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketsSaved(options) {
            return exports.BasketsApiFp(configuration).getBasketsSaved(options).then((request) => request(axios, basePath));
        },
        /**
         * Add lines to a basket
         * @summary Create basket lines
         * @param {CreateBasketLinesBody} [createBasketLinesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketLines(createBasketLinesBody, options) {
            return exports.BasketsApiFp(configuration).postBasketLines(createBasketLinesBody, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Basket
         * @param {CreateBasketBody} [createBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBaskets(createBasketBody, options) {
            return exports.BasketsApiFp(configuration).postBaskets(createBasketBody, options).then((request) => request(axios, basePath));
        },
        /**
         * A user is able to \"claim\" a guest basket.
         * @summary Allow a user to claim a basket
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdClaim(basketId, options) {
            return exports.BasketsApiFp(configuration).postBasketsBasketIdClaim(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to add custom meta information to a basket.
         * @summary Add meta information
         * @param {string} basketId
         * @param {AddBasketMetaBody} [addBasketMetaBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdMeta(basketId, addBasketMetaBody, options) {
            return exports.BasketsApiFp(configuration).postBasketsBasketIdMeta(basketId, addBasketMetaBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves a basket to a users account.
         * @summary Save a basket for a user
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsBasketIdSave(basketId, saveBasketBody, options) {
            return exports.BasketsApiFp(configuration).postBasketsBasketIdSave(basketId, saveBasketBody, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
         * @summary Resolve a basket
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postBasketsResolve(saveBasketBody, options) {
            return exports.BasketsApiFp(configuration).postBasketsResolve(saveBasketBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a basket line based on it\'s ID.
         * @summary Update basket line
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options) {
            return exports.BasketsApiFp(configuration).putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update basket line quantity
         * @summary Update basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options) {
            return exports.BasketsApiFp(configuration).putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes quantity from a basket line
         * @summary Remove basket line quantity
         * @param {string} basketLineId
         * @param {BasketLineUpdateBody} [basketLineUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options) {
            return exports.BasketsApiFp(configuration).putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a basket
         * @summary Update a basket by ID
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsBasketId(basketId, options) {
            return exports.BasketsApiFp(configuration).putBasketsBasketId(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a saved basket on the API
         * @summary Update a saved basket
         * @param {string} basketId
         * @param {SaveBasketBody} [saveBasketBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putBasketsSavedBasketId(basketId, saveBasketBody, options) {
            return exports.BasketsApiFp(configuration).putBasketsSavedBasketId(basketId, saveBasketBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BasketsApi - object-oriented interface
 * @export
 * @class BasketsApi
 * @extends {BaseAPI}
 */
class BasketsApi extends base_1.BaseAPI {
    /**
     * Removes basket lines from a basket
     * @summary Delete basket lines
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    deleteBasketLines(options) {
        return exports.BasketsApiFp(this.configuration).deleteBasketLines(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a basket
     * @summary Delete a basket by ID
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    deleteBasketsBasketId(basketId, options) {
        return exports.BasketsApiFp(this.configuration).deleteBasketsBasketId(basketId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows a user/guest to remove a basket from their basket. Useful if you can only have one discount at a time and they wish to use a different one.
     * @summary Remove discount
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    deleteBasketsBasketIdDiscounts(basketId, options) {
        return exports.BasketsApiFp(this.configuration).deleteBasketsBasketIdDiscounts(basketId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a paginated list of baskets
     * @summary Get baskets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    getBaskets(options) {
        return exports.BasketsApiFp(this.configuration).getBaskets(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a basket by it\'s ID
     * @summary Get basket
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    getBasketsBasketId(basketId, options) {
        return exports.BasketsApiFp(this.configuration).getBasketsBasketId(basketId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This request will get the current active basket for a user
     * @summary Get the current basket for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    getBasketsCurrent(options) {
        return exports.BasketsApiFp(this.configuration).getBasketsCurrent(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an authenticatd users saved baskets.
     * @summary Get a users saved baskets
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    getBasketsSaved(options) {
        return exports.BasketsApiFp(this.configuration).getBasketsSaved(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add lines to a basket
     * @summary Create basket lines
     * @param {CreateBasketLinesBody} [createBasketLinesBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    postBasketLines(createBasketLinesBody, options) {
        return exports.BasketsApiFp(this.configuration).postBasketLines(createBasketLinesBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create Basket
     * @param {CreateBasketBody} [createBasketBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    postBaskets(createBasketBody, options) {
        return exports.BasketsApiFp(this.configuration).postBaskets(createBasketBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * A user is able to \"claim\" a guest basket.
     * @summary Allow a user to claim a basket
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    postBasketsBasketIdClaim(basketId, options) {
        return exports.BasketsApiFp(this.configuration).postBasketsBasketIdClaim(basketId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to add custom meta information to a basket.
     * @summary Add meta information
     * @param {string} basketId
     * @param {AddBasketMetaBody} [addBasketMetaBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    postBasketsBasketIdMeta(basketId, addBasketMetaBody, options) {
        return exports.BasketsApiFp(this.configuration).postBasketsBasketIdMeta(basketId, addBasketMetaBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Saves a basket to a users account.
     * @summary Save a basket for a user
     * @param {string} basketId
     * @param {SaveBasketBody} [saveBasketBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    postBasketsBasketIdSave(basketId, saveBasketBody, options) {
        return exports.BasketsApiFp(this.configuration).postBasketsBasketIdSave(basketId, saveBasketBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is for when you want to either merge a users basket with a guest basket and then assign that new basket or associate a user to a guest basket.  If you choose not to merge a basket, their current one will be overwritten with the guest basket.
     * @summary Resolve a basket
     * @param {SaveBasketBody} [saveBasketBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    postBasketsResolve(saveBasketBody, options) {
        return exports.BasketsApiFp(this.configuration).postBasketsResolve(saveBasketBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a basket line based on it\'s ID.
     * @summary Update basket line
     * @param {string} basketLineId
     * @param {BasketLineUpdateBody} [basketLineUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options) {
        return exports.BasketsApiFp(this.configuration).putBasketLinesBasketLineId(basketLineId, basketLineUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update basket line quantity
     * @summary Update basket line quantity
     * @param {string} basketLineId
     * @param {BasketLineUpdateBody} [basketLineUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options) {
        return exports.BasketsApiFp(this.configuration).putBasketLinesBasketLineIdAdd(basketLineId, basketLineUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes quantity from a basket line
     * @summary Remove basket line quantity
     * @param {string} basketLineId
     * @param {BasketLineUpdateBody} [basketLineUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options) {
        return exports.BasketsApiFp(this.configuration).putBasketLinesBasketLineIdRemove(basketLineId, basketLineUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a basket
     * @summary Update a basket by ID
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    putBasketsBasketId(basketId, options) {
        return exports.BasketsApiFp(this.configuration).putBasketsBasketId(basketId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a saved basket on the API
     * @summary Update a saved basket
     * @param {string} basketId
     * @param {SaveBasketBody} [saveBasketBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    putBasketsSavedBasketId(basketId, saveBasketBody, options) {
        return exports.BasketsApiFp(this.configuration).putBasketsSavedBasketId(basketId, saveBasketBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BasketsApi = BasketsApi;
/**
 * CategoriesApi - axios parameter creator
 * @export
 */
exports.CategoriesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a paginated resource of categories
         * @summary Get Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/categories`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a single category from a given ID
         * @summary Return a single category
         * @param {string} categoryId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesCategoryId: (categoryId, includes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling getCategoriesCategoryId.');
            }
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns categories by a given parent ID.
         * @summary Get categories by parent id
         * @param {string} parentId If omitted will return top level catgories
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesParentParentId: (parentId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'parentId' is not null or undefined
            if (parentId === null || parentId === undefined) {
                throw new base_1.RequiredError('parentId', 'Required parameter parentId was null or undefined when calling getCategoriesParentParentId.');
            }
            const localVarPath = `/categories/parent/{parentId}`
                .replace(`{${"parentId"}}`, encodeURIComponent(String(parentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Attaches channels to a catagory
         * @summary Attach channels to a category
         * @param {string} categoryId
         * @param {AttachCategoryChannelsBody} [attachCategoryChannelsBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdChannels: (categoryId, attachCategoryChannelsBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling postCategoriesCategoryIdChannels.');
            }
            const localVarPath = `/categories/{categoryId}/channels`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof attachCategoryChannelsBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(attachCategoryChannelsBody !== undefined ? attachCategoryChannelsBody : {}) : (attachCategoryChannelsBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Attaches customer groups to a category resource.
         * @summary Attach customer groups to a category
         * @param {string} categoryId
         * @param {AttachCategoryCustomerGroupsBody} [attachCategoryCustomerGroupsBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdCustomerGroups: (categoryId, attachCategoryCustomerGroupsBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling postCategoriesCategoryIdCustomerGroups.');
            }
            const localVarPath = `/categories/{categoryId}/customer-groups`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof attachCategoryCustomerGroupsBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(attachCategoryCustomerGroupsBody !== undefined ? attachCategoryCustomerGroupsBody : {}) : (attachCategoryCustomerGroupsBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create or return the current category draft resource.
         * @summary Create or retrieve the current category draft
         * @param {string} categoryId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdDrafts: (categoryId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling postCategoriesCategoryIdDrafts.');
            }
            const localVarPath = `/categories/{categoryId}/drafts`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Attaches layouts to a category resource
         * @summary Update a category layout
         * @param {string} categoryId
         * @param {CategoryAttachLayoutBody} [categoryAttachLayoutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryLayouts: (categoryId, categoryAttachLayoutBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling postCategoriesCategoryLayouts.');
            }
            const localVarPath = `/categories/{categoryId}/layouts`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof categoryAttachLayoutBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(categoryAttachLayoutBody !== undefined ? categoryAttachLayoutBody : {}) : (categoryAttachLayoutBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Attaches routes to a category resource.
         * @summary Update a category\'s routes
         * @param {string} categoryId
         * @param {AttachCategoryRoutesBody} [attachCategoryRoutesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryRoutes: (categoryId, attachCategoryRoutesBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling postCategoriesCategoryRoutes.');
            }
            const localVarPath = `/categories/{categoryId}/routes`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof attachCategoryRoutesBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(attachCategoryRoutesBody !== undefined ? attachCategoryRoutesBody : {}) : (attachCategoryRoutesBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Reorder a category
         * @param {ReorderCategoryBody} [reorderCategoryBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesReorder: (reorderCategoryBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/categories/reorder`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof reorderCategoryBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(reorderCategoryBody !== undefined ? reorderCategoryBody : {}) : (reorderCategoryBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a category using a given ID.
         * @summary Update a category
         * @param {string} categoryId
         * @param {CreateCategoryBody} [createCategoryBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryId: (categoryId, createCategoryBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling putCategoriesCategoryId.');
            }
            const localVarPath = `/categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof createCategoryBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createCategoryBody !== undefined ? createCategoryBody : {}) : (createCategoryBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Attaches products to a category resource.
         * @summary Attach products
         * @param {string} categoryId
         * @param {AttachCategoryProductsBody} [attachCategoryProductsBody] When using \&quot;custom\&quot; sort type, sorting will be based on the position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryIdProducts: (categoryId, attachCategoryProductsBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling putCategoriesCategoryIdProducts.');
            }
            const localVarPath = `/categories/{categoryId}/products`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof attachCategoryProductsBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(attachCategoryProductsBody !== undefined ? attachCategoryProductsBody : {}) : (attachCategoryProductsBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CategoriesApi - functional programming interface
 * @export
 */
exports.CategoriesApiFp = function (configuration) {
    return {
        /**
         * Returns a paginated resource of categories
         * @summary Get Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).getCategories(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a single category from a given ID
         * @summary Return a single category
         * @param {string} categoryId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesCategoryId(categoryId, includes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).getCategoriesCategoryId(categoryId, includes, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns categories by a given parent ID.
         * @summary Get categories by parent id
         * @param {string} parentId If omitted will return top level catgories
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesParentParentId(parentId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).getCategoriesParentParentId(parentId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Attaches channels to a catagory
         * @summary Attach channels to a category
         * @param {string} categoryId
         * @param {AttachCategoryChannelsBody} [attachCategoryChannelsBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdChannels(categoryId, attachCategoryChannelsBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryIdChannels(categoryId, attachCategoryChannelsBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Attaches customer groups to a category resource.
         * @summary Attach customer groups to a category
         * @param {string} categoryId
         * @param {AttachCategoryCustomerGroupsBody} [attachCategoryCustomerGroupsBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdCustomerGroups(categoryId, attachCategoryCustomerGroupsBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryIdCustomerGroups(categoryId, attachCategoryCustomerGroupsBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create or return the current category draft resource.
         * @summary Create or retrieve the current category draft
         * @param {string} categoryId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdDrafts(categoryId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryIdDrafts(categoryId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Attaches layouts to a category resource
         * @summary Update a category layout
         * @param {string} categoryId
         * @param {CategoryAttachLayoutBody} [categoryAttachLayoutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryLayouts(categoryId, categoryAttachLayoutBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryLayouts(categoryId, categoryAttachLayoutBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Attaches routes to a category resource.
         * @summary Update a category\'s routes
         * @param {string} categoryId
         * @param {AttachCategoryRoutesBody} [attachCategoryRoutesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryRoutes(categoryId, attachCategoryRoutesBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).postCategoriesCategoryRoutes(categoryId, attachCategoryRoutesBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Reorder a category
         * @param {ReorderCategoryBody} [reorderCategoryBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesReorder(reorderCategoryBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).postCategoriesReorder(reorderCategoryBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a category using a given ID.
         * @summary Update a category
         * @param {string} categoryId
         * @param {CreateCategoryBody} [createCategoryBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryId(categoryId, createCategoryBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).putCategoriesCategoryId(categoryId, createCategoryBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Attaches products to a category resource.
         * @summary Attach products
         * @param {string} categoryId
         * @param {AttachCategoryProductsBody} [attachCategoryProductsBody] When using \&quot;custom\&quot; sort type, sorting will be based on the position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryIdProducts(categoryId, attachCategoryProductsBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CategoriesApiAxiosParamCreator(configuration).putCategoriesCategoryIdProducts(categoryId, attachCategoryProductsBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * CategoriesApi - factory interface
 * @export
 */
exports.CategoriesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns a paginated resource of categories
         * @summary Get Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(options) {
            return exports.CategoriesApiFp(configuration).getCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single category from a given ID
         * @summary Return a single category
         * @param {string} categoryId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesCategoryId(categoryId, includes, options) {
            return exports.CategoriesApiFp(configuration).getCategoriesCategoryId(categoryId, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns categories by a given parent ID.
         * @summary Get categories by parent id
         * @param {string} parentId If omitted will return top level catgories
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoriesParentParentId(parentId, include, options) {
            return exports.CategoriesApiFp(configuration).getCategoriesParentParentId(parentId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches channels to a catagory
         * @summary Attach channels to a category
         * @param {string} categoryId
         * @param {AttachCategoryChannelsBody} [attachCategoryChannelsBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdChannels(categoryId, attachCategoryChannelsBody, options) {
            return exports.CategoriesApiFp(configuration).postCategoriesCategoryIdChannels(categoryId, attachCategoryChannelsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches customer groups to a category resource.
         * @summary Attach customer groups to a category
         * @param {string} categoryId
         * @param {AttachCategoryCustomerGroupsBody} [attachCategoryCustomerGroupsBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdCustomerGroups(categoryId, attachCategoryCustomerGroupsBody, options) {
            return exports.CategoriesApiFp(configuration).postCategoriesCategoryIdCustomerGroups(categoryId, attachCategoryCustomerGroupsBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or return the current category draft resource.
         * @summary Create or retrieve the current category draft
         * @param {string} categoryId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryIdDrafts(categoryId, include, options) {
            return exports.CategoriesApiFp(configuration).postCategoriesCategoryIdDrafts(categoryId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches layouts to a category resource
         * @summary Update a category layout
         * @param {string} categoryId
         * @param {CategoryAttachLayoutBody} [categoryAttachLayoutBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryLayouts(categoryId, categoryAttachLayoutBody, options) {
            return exports.CategoriesApiFp(configuration).postCategoriesCategoryLayouts(categoryId, categoryAttachLayoutBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches routes to a category resource.
         * @summary Update a category\'s routes
         * @param {string} categoryId
         * @param {AttachCategoryRoutesBody} [attachCategoryRoutesBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesCategoryRoutes(categoryId, attachCategoryRoutesBody, options) {
            return exports.CategoriesApiFp(configuration).postCategoriesCategoryRoutes(categoryId, attachCategoryRoutesBody, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Reorder a category
         * @param {ReorderCategoryBody} [reorderCategoryBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategoriesReorder(reorderCategoryBody, options) {
            return exports.CategoriesApiFp(configuration).postCategoriesReorder(reorderCategoryBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a category using a given ID.
         * @summary Update a category
         * @param {string} categoryId
         * @param {CreateCategoryBody} [createCategoryBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryId(categoryId, createCategoryBody, options) {
            return exports.CategoriesApiFp(configuration).putCategoriesCategoryId(categoryId, createCategoryBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Attaches products to a category resource.
         * @summary Attach products
         * @param {string} categoryId
         * @param {AttachCategoryProductsBody} [attachCategoryProductsBody] When using \&quot;custom\&quot; sort type, sorting will be based on the position.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCategoriesCategoryIdProducts(categoryId, attachCategoryProductsBody, options) {
            return exports.CategoriesApiFp(configuration).putCategoriesCategoryIdProducts(categoryId, attachCategoryProductsBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
class CategoriesApi extends base_1.BaseAPI {
    /**
     * Returns a paginated resource of categories
     * @summary Get Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategories(options) {
        return exports.CategoriesApiFp(this.configuration).getCategories(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a single category from a given ID
     * @summary Return a single category
     * @param {string} categoryId
     * @param {string} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategoriesCategoryId(categoryId, includes, options) {
        return exports.CategoriesApiFp(this.configuration).getCategoriesCategoryId(categoryId, includes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns categories by a given parent ID.
     * @summary Get categories by parent id
     * @param {string} parentId If omitted will return top level catgories
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategoriesParentParentId(parentId, include, options) {
        return exports.CategoriesApiFp(this.configuration).getCategoriesParentParentId(parentId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attaches channels to a catagory
     * @summary Attach channels to a category
     * @param {string} categoryId
     * @param {AttachCategoryChannelsBody} [attachCategoryChannelsBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    postCategoriesCategoryIdChannels(categoryId, attachCategoryChannelsBody, options) {
        return exports.CategoriesApiFp(this.configuration).postCategoriesCategoryIdChannels(categoryId, attachCategoryChannelsBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attaches customer groups to a category resource.
     * @summary Attach customer groups to a category
     * @param {string} categoryId
     * @param {AttachCategoryCustomerGroupsBody} [attachCategoryCustomerGroupsBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    postCategoriesCategoryIdCustomerGroups(categoryId, attachCategoryCustomerGroupsBody, options) {
        return exports.CategoriesApiFp(this.configuration).postCategoriesCategoryIdCustomerGroups(categoryId, attachCategoryCustomerGroupsBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create or return the current category draft resource.
     * @summary Create or retrieve the current category draft
     * @param {string} categoryId
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    postCategoriesCategoryIdDrafts(categoryId, include, options) {
        return exports.CategoriesApiFp(this.configuration).postCategoriesCategoryIdDrafts(categoryId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attaches layouts to a category resource
     * @summary Update a category layout
     * @param {string} categoryId
     * @param {CategoryAttachLayoutBody} [categoryAttachLayoutBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    postCategoriesCategoryLayouts(categoryId, categoryAttachLayoutBody, options) {
        return exports.CategoriesApiFp(this.configuration).postCategoriesCategoryLayouts(categoryId, categoryAttachLayoutBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attaches routes to a category resource.
     * @summary Update a category\'s routes
     * @param {string} categoryId
     * @param {AttachCategoryRoutesBody} [attachCategoryRoutesBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    postCategoriesCategoryRoutes(categoryId, attachCategoryRoutesBody, options) {
        return exports.CategoriesApiFp(this.configuration).postCategoriesCategoryRoutes(categoryId, attachCategoryRoutesBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Reorder a category
     * @param {ReorderCategoryBody} [reorderCategoryBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    postCategoriesReorder(reorderCategoryBody, options) {
        return exports.CategoriesApiFp(this.configuration).postCategoriesReorder(reorderCategoryBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a category using a given ID.
     * @summary Update a category
     * @param {string} categoryId
     * @param {CreateCategoryBody} [createCategoryBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    putCategoriesCategoryId(categoryId, createCategoryBody, options) {
        return exports.CategoriesApiFp(this.configuration).putCategoriesCategoryId(categoryId, createCategoryBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attaches products to a category resource.
     * @summary Attach products
     * @param {string} categoryId
     * @param {AttachCategoryProductsBody} [attachCategoryProductsBody] When using \&quot;custom\&quot; sort type, sorting will be based on the position.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    putCategoriesCategoryIdProducts(categoryId, attachCategoryProductsBody, options) {
        return exports.CategoriesApiFp(this.configuration).putCategoriesCategoryIdProducts(categoryId, attachCategoryProductsBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CategoriesApi = CategoriesApi;
/**
 * ChannelsApi - axios parameter creator
 * @export
 */
exports.ChannelsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Delete the channel resource
         * @param {string} channelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelsChannelId: (channelId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling deleteChannelsChannelId.');
            }
            const localVarPath = `/channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a paginated list of all channel
         * @summary Get all channels
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels: (includes, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the channel resource
         * @param {string} channelId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsChannelId: (channelId, includes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling getChannelsChannelId.');
            }
            const localVarPath = `/channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new channel resource
         * @summary Create a new channel
         * @param {string} [handle]
         * @param {string} [name]
         * @param {string} [url]
         * @param {boolean} [_default]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannels: (handle, name, url, _default, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/channels`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (handle !== undefined) {
                localVarFormParams.append('handle', handle);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (url !== undefined) {
                localVarFormParams.append('url', url);
            }
            if (_default !== undefined) {
                localVarFormParams.append('default', _default);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update the channel resource
         * @param {string} channelId
         * @param {string} [handle]
         * @param {string} [name]
         * @param {string} [url]
         * @param {boolean} [_default]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelsChannelId: (channelId, handle, name, url, _default, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new base_1.RequiredError('channelId', 'Required parameter channelId was null or undefined when calling putChannelsChannelId.');
            }
            const localVarPath = `/channels/{channelId}`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (handle !== undefined) {
                localVarFormParams.append('handle', handle);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (url !== undefined) {
                localVarFormParams.append('url', url);
            }
            if (_default !== undefined) {
                localVarFormParams.append('default', _default);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ChannelsApi - functional programming interface
 * @export
 */
exports.ChannelsApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Delete the channel resource
         * @param {string} channelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelsChannelId(channelId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).deleteChannelsChannelId(channelId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Gets a paginated list of all channel
         * @summary Get all channels
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(includes, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).getChannels(includes, perPage, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get the channel resource
         * @param {string} channelId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsChannelId(channelId, includes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).getChannelsChannelId(channelId, includes, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new channel resource
         * @summary Create a new channel
         * @param {string} [handle]
         * @param {string} [name]
         * @param {string} [url]
         * @param {boolean} [_default]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannels(handle, name, url, _default, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).postChannels(handle, name, url, _default, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Update the channel resource
         * @param {string} channelId
         * @param {string} [handle]
         * @param {string} [name]
         * @param {string} [url]
         * @param {boolean} [_default]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelsChannelId(channelId, handle, name, url, _default, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ChannelsApiAxiosParamCreator(configuration).putChannelsChannelId(channelId, handle, name, url, _default, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ChannelsApi - factory interface
 * @export
 */
exports.ChannelsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Delete the channel resource
         * @param {string} channelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChannelsChannelId(channelId, options) {
            return exports.ChannelsApiFp(configuration).deleteChannelsChannelId(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of all channel
         * @summary Get all channels
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(includes, perPage, options) {
            return exports.ChannelsApiFp(configuration).getChannels(includes, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the channel resource
         * @param {string} channelId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsChannelId(channelId, includes, options) {
            return exports.ChannelsApiFp(configuration).getChannelsChannelId(channelId, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new channel resource
         * @summary Create a new channel
         * @param {string} [handle]
         * @param {string} [name]
         * @param {string} [url]
         * @param {boolean} [_default]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannels(handle, name, url, _default, options) {
            return exports.ChannelsApiFp(configuration).postChannels(handle, name, url, _default, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the channel resource
         * @param {string} channelId
         * @param {string} [handle]
         * @param {string} [name]
         * @param {string} [url]
         * @param {boolean} [_default]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelsChannelId(channelId, handle, name, url, _default, options) {
            return exports.ChannelsApiFp(configuration).putChannelsChannelId(channelId, handle, name, url, _default, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChannelsApi - object-oriented interface
 * @export
 * @class ChannelsApi
 * @extends {BaseAPI}
 */
class ChannelsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Delete the channel resource
     * @param {string} channelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    deleteChannelsChannelId(channelId, options) {
        return exports.ChannelsApiFp(this.configuration).deleteChannelsChannelId(channelId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a paginated list of all channel
     * @summary Get all channels
     * @param {string} [includes] Comma separated includes for the resource
     * @param {number} [perPage] How many results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    getChannels(includes, perPage, options) {
        return exports.ChannelsApiFp(this.configuration).getChannels(includes, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the channel resource
     * @param {string} channelId
     * @param {string} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    getChannelsChannelId(channelId, includes, options) {
        return exports.ChannelsApiFp(this.configuration).getChannelsChannelId(channelId, includes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new channel resource
     * @summary Create a new channel
     * @param {string} [handle]
     * @param {string} [name]
     * @param {string} [url]
     * @param {boolean} [_default]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    postChannels(handle, name, url, _default, options) {
        return exports.ChannelsApiFp(this.configuration).postChannels(handle, name, url, _default, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update the channel resource
     * @param {string} channelId
     * @param {string} [handle]
     * @param {string} [name]
     * @param {string} [url]
     * @param {boolean} [_default]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelsApi
     */
    putChannelsChannelId(channelId, handle, name, url, _default, options) {
        return exports.ChannelsApiFp(this.configuration).putChannelsChannelId(channelId, handle, name, url, _default, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ChannelsApi = ChannelsApi;
/**
 * CollectionsApi - axios parameter creator
 * @export
 */
exports.CollectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a Collection by its ID
         * @summary Delete Collection
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionsCollectionId: (collectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new base_1.RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling deleteCollectionsCollectionId.');
            }
            const localVarPath = `/collections/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a paginated response of collections.
         * @summary Get Collections
         * @param {'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups'} [include]
         * @param {string} [perPage]
         * @param {string} [fullResponse]
         * @param {string} [sort]
         * @param {string} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections: (include, perPage, fullResponse, sort, page, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/collections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a single Collection by its ID
         * @summary Single Collection
         * @param {string} collectionId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollectionId: (collectionId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new base_1.RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling getCollectionsCollectionId.');
            }
            const localVarPath = `/collections/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new collection.
         * @summary Create Collection
         * @param {InlineObject3} [inlineObject3]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollections: (inlineObject3, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/collections`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject3 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject3 !== undefined ? inlineObject3 : {}) : (inlineObject3 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Syncs products with a collection.
         * @summary Update a collection\'s products
         * @param {string} collectionId
         * @param {InlineObject2} [inlineObject2]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionIdProducts: (collectionId, inlineObject2, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new base_1.RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling postCollectionsCollectionIdProducts.');
            }
            const localVarPath = `/collections/{collectionId}/products`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject2 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject2 !== undefined ? inlineObject2 : {}) : (inlineObject2 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This request will allow you to attach routes to a collection
         * @summary Update a collection\'s routes
         * @param {string} collectionId
         * @param {InlineObject1} [inlineObject1]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionRoutes: (collectionId, inlineObject1, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new base_1.RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling postCollectionsCollectionRoutes.');
            }
            const localVarPath = `/collections/{collectionId}/routes`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject1 !== undefined ? inlineObject1 : {}) : (inlineObject1 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Collection by its ID.
         * @summary Update Collection
         * @param {string} collectionId
         * @param {InlineObject4} [inlineObject4]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionsCollectionId: (collectionId, inlineObject4, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new base_1.RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling putCollectionsCollectionId.');
            }
            const localVarPath = `/collections/{collectionId}`
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject4 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject4 !== undefined ? inlineObject4 : {}) : (inlineObject4 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CollectionsApi - functional programming interface
 * @export
 */
exports.CollectionsApiFp = function (configuration) {
    return {
        /**
         * Delete a Collection by its ID
         * @summary Delete Collection
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionsCollectionId(collectionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).deleteCollectionsCollectionId(collectionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a paginated response of collections.
         * @summary Get Collections
         * @param {'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups'} [include]
         * @param {string} [perPage]
         * @param {string} [fullResponse]
         * @param {string} [sort]
         * @param {string} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections(include, perPage, fullResponse, sort, page, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).getCollections(include, perPage, fullResponse, sort, page, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a single Collection by its ID
         * @summary Single Collection
         * @param {string} collectionId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollectionId(collectionId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).getCollectionsCollectionId(collectionId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new collection.
         * @summary Create Collection
         * @param {InlineObject3} [inlineObject3]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollections(inlineObject3, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).postCollections(inlineObject3, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Syncs products with a collection.
         * @summary Update a collection\'s products
         * @param {string} collectionId
         * @param {InlineObject2} [inlineObject2]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionIdProducts(collectionId, inlineObject2, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).postCollectionsCollectionIdProducts(collectionId, inlineObject2, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This request will allow you to attach routes to a collection
         * @summary Update a collection\'s routes
         * @param {string} collectionId
         * @param {InlineObject1} [inlineObject1]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionRoutes(collectionId, inlineObject1, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).postCollectionsCollectionRoutes(collectionId, inlineObject1, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Collection by its ID.
         * @summary Update Collection
         * @param {string} collectionId
         * @param {InlineObject4} [inlineObject4]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionsCollectionId(collectionId, inlineObject4, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CollectionsApiAxiosParamCreator(configuration).putCollectionsCollectionId(collectionId, inlineObject4, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * CollectionsApi - factory interface
 * @export
 */
exports.CollectionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete a Collection by its ID
         * @summary Delete Collection
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCollectionsCollectionId(collectionId, options) {
            return exports.CollectionsApiFp(configuration).deleteCollectionsCollectionId(collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated response of collections.
         * @summary Get Collections
         * @param {'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups'} [include]
         * @param {string} [perPage]
         * @param {string} [fullResponse]
         * @param {string} [sort]
         * @param {string} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollections(include, perPage, fullResponse, sort, page, options) {
            return exports.CollectionsApiFp(configuration).getCollections(include, perPage, fullResponse, sort, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single Collection by its ID
         * @summary Single Collection
         * @param {string} collectionId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCollectionsCollectionId(collectionId, include, options) {
            return exports.CollectionsApiFp(configuration).getCollectionsCollectionId(collectionId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new collection.
         * @summary Create Collection
         * @param {InlineObject3} [inlineObject3]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollections(inlineObject3, options) {
            return exports.CollectionsApiFp(configuration).postCollections(inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * Syncs products with a collection.
         * @summary Update a collection\'s products
         * @param {string} collectionId
         * @param {InlineObject2} [inlineObject2]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionIdProducts(collectionId, inlineObject2, options) {
            return exports.CollectionsApiFp(configuration).postCollectionsCollectionIdProducts(collectionId, inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * This request will allow you to attach routes to a collection
         * @summary Update a collection\'s routes
         * @param {string} collectionId
         * @param {InlineObject1} [inlineObject1]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCollectionsCollectionRoutes(collectionId, inlineObject1, options) {
            return exports.CollectionsApiFp(configuration).postCollectionsCollectionRoutes(collectionId, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Collection by its ID.
         * @summary Update Collection
         * @param {string} collectionId
         * @param {InlineObject4} [inlineObject4]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCollectionsCollectionId(collectionId, inlineObject4, options) {
            return exports.CollectionsApiFp(configuration).putCollectionsCollectionId(collectionId, inlineObject4, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CollectionsApi - object-oriented interface
 * @export
 * @class CollectionsApi
 * @extends {BaseAPI}
 */
class CollectionsApi extends base_1.BaseAPI {
    /**
     * Delete a Collection by its ID
     * @summary Delete Collection
     * @param {string} collectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    deleteCollectionsCollectionId(collectionId, options) {
        return exports.CollectionsApiFp(this.configuration).deleteCollectionsCollectionId(collectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a paginated response of collections.
     * @summary Get Collections
     * @param {'routes' | 'layout' | 'channels' | 'assets' | 'attributes' | 'routes' | 'products' | 'customer_groups'} [include]
     * @param {string} [perPage]
     * @param {string} [fullResponse]
     * @param {string} [sort]
     * @param {string} [page]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollections(include, perPage, fullResponse, sort, page, options) {
        return exports.CollectionsApiFp(this.configuration).getCollections(include, perPage, fullResponse, sort, page, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a single Collection by its ID
     * @summary Single Collection
     * @param {string} collectionId
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    getCollectionsCollectionId(collectionId, include, options) {
        return exports.CollectionsApiFp(this.configuration).getCollectionsCollectionId(collectionId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new collection.
     * @summary Create Collection
     * @param {InlineObject3} [inlineObject3]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    postCollections(inlineObject3, options) {
        return exports.CollectionsApiFp(this.configuration).postCollections(inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Syncs products with a collection.
     * @summary Update a collection\'s products
     * @param {string} collectionId
     * @param {InlineObject2} [inlineObject2]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    postCollectionsCollectionIdProducts(collectionId, inlineObject2, options) {
        return exports.CollectionsApiFp(this.configuration).postCollectionsCollectionIdProducts(collectionId, inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This request will allow you to attach routes to a collection
     * @summary Update a collection\'s routes
     * @param {string} collectionId
     * @param {InlineObject1} [inlineObject1]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    postCollectionsCollectionRoutes(collectionId, inlineObject1, options) {
        return exports.CollectionsApiFp(this.configuration).postCollectionsCollectionRoutes(collectionId, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Collection by its ID.
     * @summary Update Collection
     * @param {string} collectionId
     * @param {InlineObject4} [inlineObject4]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CollectionsApi
     */
    putCollectionsCollectionId(collectionId, inlineObject4, options) {
        return exports.CollectionsApiFp(this.configuration).putCollectionsCollectionId(collectionId, inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CollectionsApi = CollectionsApi;
/**
 * CountriesApi - axios parameter creator
 * @export
 */
exports.CountriesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets a paginated list of all channel
         * @summary Get all countries
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries: (include, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/countries`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the country resource
         * @param {string} countryId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountriesCountryId: (countryId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'countryId' is not null or undefined
            if (countryId === null || countryId === undefined) {
                throw new base_1.RequiredError('countryId', 'Required parameter countryId was null or undefined when calling getCountriesCountryId.');
            }
            const localVarPath = `/countries/{countryId}`
                .replace(`{${"countryId"}}`, encodeURIComponent(String(countryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update the country resource
         * @param {string} countryId
         * @param {boolean} [preferred]
         * @param {boolean} [enabled]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCountriesCountryId: (countryId, preferred, enabled, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'countryId' is not null or undefined
            if (countryId === null || countryId === undefined) {
                throw new base_1.RequiredError('countryId', 'Required parameter countryId was null or undefined when calling putCountriesCountryId.');
            }
            const localVarPath = `/countries/{countryId}`
                .replace(`{${"countryId"}}`, encodeURIComponent(String(countryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (preferred !== undefined) {
                localVarFormParams.append('preferred', preferred);
            }
            if (enabled !== undefined) {
                localVarFormParams.append('enabled', enabled);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CountriesApi - functional programming interface
 * @export
 */
exports.CountriesApiFp = function (configuration) {
    return {
        /**
         * Gets a paginated list of all channel
         * @summary Get all countries
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(include, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CountriesApiAxiosParamCreator(configuration).getCountries(include, perPage, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get the country resource
         * @param {string} countryId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountriesCountryId(countryId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CountriesApiAxiosParamCreator(configuration).getCountriesCountryId(countryId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Update the country resource
         * @param {string} countryId
         * @param {boolean} [preferred]
         * @param {boolean} [enabled]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCountriesCountryId(countryId, preferred, enabled, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CountriesApiAxiosParamCreator(configuration).putCountriesCountryId(countryId, preferred, enabled, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * CountriesApi - factory interface
 * @export
 */
exports.CountriesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Gets a paginated list of all channel
         * @summary Get all countries
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountries(include, perPage, options) {
            return exports.CountriesApiFp(configuration).getCountries(include, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the country resource
         * @param {string} countryId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountriesCountryId(countryId, include, options) {
            return exports.CountriesApiFp(configuration).getCountriesCountryId(countryId, include, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the country resource
         * @param {string} countryId
         * @param {boolean} [preferred]
         * @param {boolean} [enabled]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCountriesCountryId(countryId, preferred, enabled, options) {
            return exports.CountriesApiFp(configuration).putCountriesCountryId(countryId, preferred, enabled, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
class CountriesApi extends base_1.BaseAPI {
    /**
     * Gets a paginated list of all channel
     * @summary Get all countries
     * @param {string} [include] Comma separated includes for the resource
     * @param {number} [perPage] How many results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    getCountries(include, perPage, options) {
        return exports.CountriesApiFp(this.configuration).getCountries(include, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the country resource
     * @param {string} countryId
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    getCountriesCountryId(countryId, include, options) {
        return exports.CountriesApiFp(this.configuration).getCountriesCountryId(countryId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update the country resource
     * @param {string} countryId
     * @param {boolean} [preferred]
     * @param {boolean} [enabled]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    putCountriesCountryId(countryId, preferred, enabled, options) {
        return exports.CountriesApiFp(this.configuration).putCountriesCountryId(countryId, preferred, enabled, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CountriesApi = CountriesApi;
/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
exports.CurrenciesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets a paginated list of all currencies
         * @summary Get all currencies
         * @param {string} [include] Comma separated includes for the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies: (include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/currencies`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CurrenciesApi - functional programming interface
 * @export
 */
exports.CurrenciesApiFp = function (configuration) {
    return {
        /**
         * Gets a paginated list of all currencies
         * @summary Get all currencies
         * @param {string} [include] Comma separated includes for the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CurrenciesApiAxiosParamCreator(configuration).getCurrencies(include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * CurrenciesApi - factory interface
 * @export
 */
exports.CurrenciesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Gets a paginated list of all currencies
         * @summary Get all currencies
         * @param {string} [include] Comma separated includes for the resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(include, options) {
            return exports.CurrenciesApiFp(configuration).getCurrencies(include, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
class CurrenciesApi extends base_1.BaseAPI {
    /**
     * Gets a paginated list of all currencies
     * @summary Get all currencies
     * @param {string} [include] Comma separated includes for the resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrenciesApi
     */
    getCurrencies(include, options) {
        return exports.CurrenciesApiFp(this.configuration).getCurrencies(include, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CurrenciesApi = CurrenciesApi;
/**
 * CustomerGroupsApi - axios parameter creator
 * @export
 */
exports.CustomerGroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Delete the customer group resource
         * @param {string} customerGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerGroupsCustomerGroupId: (customerGroupId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerGroupId' is not null or undefined
            if (customerGroupId === null || customerGroupId === undefined) {
                throw new base_1.RequiredError('customerGroupId', 'Required parameter customerGroupId was null or undefined when calling deleteCustomerGroupsCustomerGroupId.');
            }
            const localVarPath = `/customer-groups/{customerGroupId}`
                .replace(`{${"customerGroupId"}}`, encodeURIComponent(String(customerGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a single customer group
         * @param {string} customerGroupId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroupCustomerGroupId: (customerGroupId, includes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerGroupId' is not null or undefined
            if (customerGroupId === null || customerGroupId === undefined) {
                throw new base_1.RequiredError('customerGroupId', 'Required parameter customerGroupId was null or undefined when calling getCustomerGroupCustomerGroupId.');
            }
            const localVarPath = `/customer-groups/{customerGroupId}`
                .replace(`{${"customerGroupId"}}`, encodeURIComponent(String(customerGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a paginated list of all customer groups
         * @summary Get all customer groups
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroups: (includes, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/customer-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new customer group
         * @summary Create a new customer group
         * @param {string} [handle]
         * @param {string} [name]
         * @param {boolean} [_default]
         * @param {boolean} [system]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerGroups: (handle, name, _default, system, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/customer-groups`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (handle !== undefined) {
                localVarFormParams.append('handle', handle);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (_default !== undefined) {
                localVarFormParams.append('default', _default);
            }
            if (system !== undefined) {
                localVarFormParams.append('system', system);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update the customer group resource
         * @param {string} customerGroupId
         * @param {string} [handle]
         * @param {string} [name]
         * @param {boolean} [_default]
         * @param {boolean} [system]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomerGroupsCustomerGroupId: (customerGroupId, handle, name, _default, system, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerGroupId' is not null or undefined
            if (customerGroupId === null || customerGroupId === undefined) {
                throw new base_1.RequiredError('customerGroupId', 'Required parameter customerGroupId was null or undefined when calling putCustomerGroupsCustomerGroupId.');
            }
            const localVarPath = `/customer-groups/{customerGroupId}`
                .replace(`{${"customerGroupId"}}`, encodeURIComponent(String(customerGroupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (handle !== undefined) {
                localVarFormParams.append('handle', handle);
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (_default !== undefined) {
                localVarFormParams.append('default', _default);
            }
            if (system !== undefined) {
                localVarFormParams.append('system', system);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CustomerGroupsApi - functional programming interface
 * @export
 */
exports.CustomerGroupsApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Delete the customer group resource
         * @param {string} customerGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerGroupsCustomerGroupId(customerGroupId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomerGroupsApiAxiosParamCreator(configuration).deleteCustomerGroupsCustomerGroupId(customerGroupId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get a single customer group
         * @param {string} customerGroupId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroupCustomerGroupId(customerGroupId, includes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomerGroupsApiAxiosParamCreator(configuration).getCustomerGroupCustomerGroupId(customerGroupId, includes, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Gets a paginated list of all customer groups
         * @summary Get all customer groups
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroups(includes, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomerGroupsApiAxiosParamCreator(configuration).getCustomerGroups(includes, perPage, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new customer group
         * @summary Create a new customer group
         * @param {string} [handle]
         * @param {string} [name]
         * @param {boolean} [_default]
         * @param {boolean} [system]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerGroups(handle, name, _default, system, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomerGroupsApiAxiosParamCreator(configuration).postCustomerGroups(handle, name, _default, system, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Update the customer group resource
         * @param {string} customerGroupId
         * @param {string} [handle]
         * @param {string} [name]
         * @param {boolean} [_default]
         * @param {boolean} [system]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomerGroupsCustomerGroupId(customerGroupId, handle, name, _default, system, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomerGroupsApiAxiosParamCreator(configuration).putCustomerGroupsCustomerGroupId(customerGroupId, handle, name, _default, system, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * CustomerGroupsApi - factory interface
 * @export
 */
exports.CustomerGroupsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Delete the customer group resource
         * @param {string} customerGroupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerGroupsCustomerGroupId(customerGroupId, options) {
            return exports.CustomerGroupsApiFp(configuration).deleteCustomerGroupsCustomerGroupId(customerGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a single customer group
         * @param {string} customerGroupId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroupCustomerGroupId(customerGroupId, includes, options) {
            return exports.CustomerGroupsApiFp(configuration).getCustomerGroupCustomerGroupId(customerGroupId, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of all customer groups
         * @summary Get all customer groups
         * @param {string} [includes] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerGroups(includes, perPage, options) {
            return exports.CustomerGroupsApiFp(configuration).getCustomerGroups(includes, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new customer group
         * @summary Create a new customer group
         * @param {string} [handle]
         * @param {string} [name]
         * @param {boolean} [_default]
         * @param {boolean} [system]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomerGroups(handle, name, _default, system, options) {
            return exports.CustomerGroupsApiFp(configuration).postCustomerGroups(handle, name, _default, system, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the customer group resource
         * @param {string} customerGroupId
         * @param {string} [handle]
         * @param {string} [name]
         * @param {boolean} [_default]
         * @param {boolean} [system]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomerGroupsCustomerGroupId(customerGroupId, handle, name, _default, system, options) {
            return exports.CustomerGroupsApiFp(configuration).putCustomerGroupsCustomerGroupId(customerGroupId, handle, name, _default, system, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CustomerGroupsApi - object-oriented interface
 * @export
 * @class CustomerGroupsApi
 * @extends {BaseAPI}
 */
class CustomerGroupsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Delete the customer group resource
     * @param {string} customerGroupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    deleteCustomerGroupsCustomerGroupId(customerGroupId, options) {
        return exports.CustomerGroupsApiFp(this.configuration).deleteCustomerGroupsCustomerGroupId(customerGroupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a single customer group
     * @param {string} customerGroupId
     * @param {string} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    getCustomerGroupCustomerGroupId(customerGroupId, includes, options) {
        return exports.CustomerGroupsApiFp(this.configuration).getCustomerGroupCustomerGroupId(customerGroupId, includes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a paginated list of all customer groups
     * @summary Get all customer groups
     * @param {string} [includes] Comma separated includes for the resource
     * @param {number} [perPage] How many results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    getCustomerGroups(includes, perPage, options) {
        return exports.CustomerGroupsApiFp(this.configuration).getCustomerGroups(includes, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new customer group
     * @summary Create a new customer group
     * @param {string} [handle]
     * @param {string} [name]
     * @param {boolean} [_default]
     * @param {boolean} [system]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    postCustomerGroups(handle, name, _default, system, options) {
        return exports.CustomerGroupsApiFp(this.configuration).postCustomerGroups(handle, name, _default, system, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update the customer group resource
     * @param {string} customerGroupId
     * @param {string} [handle]
     * @param {string} [name]
     * @param {boolean} [_default]
     * @param {boolean} [system]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerGroupsApi
     */
    putCustomerGroupsCustomerGroupId(customerGroupId, handle, name, _default, system, options) {
        return exports.CustomerGroupsApiFp(this.configuration).putCustomerGroupsCustomerGroupId(customerGroupId, handle, name, _default, system, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CustomerGroupsApi = CustomerGroupsApi;
/**
 * CustomersApi - axios parameter creator
 * @export
 */
exports.CustomersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Delete the customer resource
         * @param {string} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomersCustomerId: (customerId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new base_1.RequiredError('customerId', 'Required parameter customerId was null or undefined when calling deleteCustomersCustomerId.');
            }
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint returns any available customer fields which have been defined in the getcandy config.
         * @summary Get custom customer fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerFields: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/customers/fields`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a paginated list of all customers
         * @summary Get all customers
         * @param {string} [include] Comma separated include for the resource
         * @param {number} [perPage] How many results per page
         * @param {number} [counts] Comma seperated count include to show relation counts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: (include, perPage, counts, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (counts !== undefined) {
                localVarQueryParameter['counts'] = counts;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get the customer resource
         * @param {string} customerId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerId: (customerId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new base_1.RequiredError('customerId', 'Required parameter customerId was null or undefined when calling getCustomersCustomerId.');
            }
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Attach a user to a customer record
         * @param {string} customerId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerIdUsers: (customerId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new base_1.RequiredError('customerId', 'Required parameter customerId was null or undefined when calling getCustomersCustomerIdUsers.');
            }
            const localVarPath = `/customers/{customerId}/users`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint returns any available user fields which have been defined in the getcandy config.
         * @summary Get custom user fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFields: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/users/fields`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new customer
         * @summary Create a new customer
         * @param {string} [firstname]
         * @param {string} [lastname]
         * @param {number} [contactNumber]
         * @param {number} [altContactNumber]
         * @param {string} [companyName]
         * @param {string} [vatNo]
         * @param {object} [fields]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers: (firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (firstname !== undefined) {
                localVarFormParams.append('firstname', firstname);
            }
            if (lastname !== undefined) {
                localVarFormParams.append('lastname', lastname);
            }
            if (contactNumber !== undefined) {
                localVarFormParams.append('contact_number', contactNumber);
            }
            if (altContactNumber !== undefined) {
                localVarFormParams.append('alt_contact_number', altContactNumber);
            }
            if (companyName !== undefined) {
                localVarFormParams.append('company_name', companyName);
            }
            if (vatNo !== undefined) {
                localVarFormParams.append('vat_no', vatNo);
            }
            if (fields !== undefined) {
                localVarFormParams.append('fields', fields);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Attach customer groups to a customer
         * @param {string} customerId
         * @param {AttachCustomerToGroupBody} [attachCustomerToGroupBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomersCustomerIdCustomerGroups: (customerId, attachCustomerToGroupBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new base_1.RequiredError('customerId', 'Required parameter customerId was null or undefined when calling postCustomersCustomerIdCustomerGroups.');
            }
            const localVarPath = `/customers/{customerId}/customer-groups`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof attachCustomerToGroupBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(attachCustomerToGroupBody !== undefined ? attachCustomerToGroupBody : {}) : (attachCustomerToGroupBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update the customer resource
         * @param {string} customerId
         * @param {UpdateCustomerBody} [updateCustomerBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomersCustomerId: (customerId, updateCustomerBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'customerId' is not null or undefined
            if (customerId === null || customerId === undefined) {
                throw new base_1.RequiredError('customerId', 'Required parameter customerId was null or undefined when calling putCustomersCustomerId.');
            }
            const localVarPath = `/customers/{customerId}`
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof updateCustomerBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateCustomerBody !== undefined ? updateCustomerBody : {}) : (updateCustomerBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CustomersApi - functional programming interface
 * @export
 */
exports.CustomersApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Delete the customer resource
         * @param {string} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomersCustomerId(customerId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomersApiAxiosParamCreator(configuration).deleteCustomersCustomerId(customerId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint returns any available customer fields which have been defined in the getcandy config.
         * @summary Get custom customer fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerFields(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomersApiAxiosParamCreator(configuration).getCustomerFields(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Gets a paginated list of all customers
         * @summary Get all customers
         * @param {string} [include] Comma separated include for the resource
         * @param {number} [perPage] How many results per page
         * @param {number} [counts] Comma seperated count include to show relation counts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(include, perPage, counts, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomersApiAxiosParamCreator(configuration).getCustomers(include, perPage, counts, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get the customer resource
         * @param {string} customerId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerId(customerId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomersApiAxiosParamCreator(configuration).getCustomersCustomerId(customerId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Attach a user to a customer record
         * @param {string} customerId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerIdUsers(customerId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomersApiAxiosParamCreator(configuration).getCustomersCustomerIdUsers(customerId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint returns any available user fields which have been defined in the getcandy config.
         * @summary Get custom user fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFields(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomersApiAxiosParamCreator(configuration).getUsersFields(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new customer
         * @summary Create a new customer
         * @param {string} [firstname]
         * @param {string} [lastname]
         * @param {number} [contactNumber]
         * @param {number} [altContactNumber]
         * @param {string} [companyName]
         * @param {string} [vatNo]
         * @param {object} [fields]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers(firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomersApiAxiosParamCreator(configuration).postCustomers(firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Attach customer groups to a customer
         * @param {string} customerId
         * @param {AttachCustomerToGroupBody} [attachCustomerToGroupBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomersCustomerIdCustomerGroups(customerId, attachCustomerToGroupBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomersApiAxiosParamCreator(configuration).postCustomersCustomerIdCustomerGroups(customerId, attachCustomerToGroupBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Update the customer resource
         * @param {string} customerId
         * @param {UpdateCustomerBody} [updateCustomerBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomersCustomerId(customerId, updateCustomerBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.CustomersApiAxiosParamCreator(configuration).putCustomersCustomerId(customerId, updateCustomerBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * CustomersApi - factory interface
 * @export
 */
exports.CustomersApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         *
         * @summary Delete the customer resource
         * @param {string} customerId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomersCustomerId(customerId, options) {
            return exports.CustomersApiFp(configuration).deleteCustomersCustomerId(customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns any available customer fields which have been defined in the getcandy config.
         * @summary Get custom customer fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerFields(options) {
            return exports.CustomersApiFp(configuration).getCustomerFields(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of all customers
         * @summary Get all customers
         * @param {string} [include] Comma separated include for the resource
         * @param {number} [perPage] How many results per page
         * @param {number} [counts] Comma seperated count include to show relation counts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(include, perPage, counts, options) {
            return exports.CustomersApiFp(configuration).getCustomers(include, perPage, counts, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the customer resource
         * @param {string} customerId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerId(customerId, include, options) {
            return exports.CustomersApiFp(configuration).getCustomersCustomerId(customerId, include, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Attach a user to a customer record
         * @param {string} customerId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomersCustomerIdUsers(customerId, include, options) {
            return exports.CustomersApiFp(configuration).getCustomersCustomerIdUsers(customerId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns any available user fields which have been defined in the getcandy config.
         * @summary Get custom user fields
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersFields(options) {
            return exports.CustomersApiFp(configuration).getUsersFields(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new customer
         * @summary Create a new customer
         * @param {string} [firstname]
         * @param {string} [lastname]
         * @param {number} [contactNumber]
         * @param {number} [altContactNumber]
         * @param {string} [companyName]
         * @param {string} [vatNo]
         * @param {object} [fields]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomers(firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options) {
            return exports.CustomersApiFp(configuration).postCustomers(firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Attach customer groups to a customer
         * @param {string} customerId
         * @param {AttachCustomerToGroupBody} [attachCustomerToGroupBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCustomersCustomerIdCustomerGroups(customerId, attachCustomerToGroupBody, options) {
            return exports.CustomersApiFp(configuration).postCustomersCustomerIdCustomerGroups(customerId, attachCustomerToGroupBody, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the customer resource
         * @param {string} customerId
         * @param {UpdateCustomerBody} [updateCustomerBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putCustomersCustomerId(customerId, updateCustomerBody, options) {
            return exports.CustomersApiFp(configuration).putCustomersCustomerId(customerId, updateCustomerBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
class CustomersApi extends base_1.BaseAPI {
    /**
     *
     * @summary Delete the customer resource
     * @param {string} customerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    deleteCustomersCustomerId(customerId, options) {
        return exports.CustomersApiFp(this.configuration).deleteCustomersCustomerId(customerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint returns any available customer fields which have been defined in the getcandy config.
     * @summary Get custom customer fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    getCustomerFields(options) {
        return exports.CustomersApiFp(this.configuration).getCustomerFields(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a paginated list of all customers
     * @summary Get all customers
     * @param {string} [include] Comma separated include for the resource
     * @param {number} [perPage] How many results per page
     * @param {number} [counts] Comma seperated count include to show relation counts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    getCustomers(include, perPage, counts, options) {
        return exports.CustomersApiFp(this.configuration).getCustomers(include, perPage, counts, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the customer resource
     * @param {string} customerId
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    getCustomersCustomerId(customerId, include, options) {
        return exports.CustomersApiFp(this.configuration).getCustomersCustomerId(customerId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Attach a user to a customer record
     * @param {string} customerId
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    getCustomersCustomerIdUsers(customerId, include, options) {
        return exports.CustomersApiFp(this.configuration).getCustomersCustomerIdUsers(customerId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint returns any available user fields which have been defined in the getcandy config.
     * @summary Get custom user fields
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    getUsersFields(options) {
        return exports.CustomersApiFp(this.configuration).getUsersFields(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new customer
     * @summary Create a new customer
     * @param {string} [firstname]
     * @param {string} [lastname]
     * @param {number} [contactNumber]
     * @param {number} [altContactNumber]
     * @param {string} [companyName]
     * @param {string} [vatNo]
     * @param {object} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    postCustomers(firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options) {
        return exports.CustomersApiFp(this.configuration).postCustomers(firstname, lastname, contactNumber, altContactNumber, companyName, vatNo, fields, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Attach customer groups to a customer
     * @param {string} customerId
     * @param {AttachCustomerToGroupBody} [attachCustomerToGroupBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    postCustomersCustomerIdCustomerGroups(customerId, attachCustomerToGroupBody, options) {
        return exports.CustomersApiFp(this.configuration).postCustomersCustomerIdCustomerGroups(customerId, attachCustomerToGroupBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update the customer resource
     * @param {string} customerId
     * @param {UpdateCustomerBody} [updateCustomerBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    putCustomersCustomerId(customerId, updateCustomerBody, options) {
        return exports.CustomersApiFp(this.configuration).putCustomersCustomerId(customerId, updateCustomerBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CustomersApi = CustomersApi;
/**
 * DiscountsApi - axios parameter creator
 * @export
 */
exports.DiscountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes a Discount
         * @summary Delete Discount
         * @param {string} discountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountId: (discountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'discountId' is not null or undefined
            if (discountId === null || discountId === undefined) {
                throw new base_1.RequiredError('discountId', 'Required parameter discountId was null or undefined when calling deleteDiscountsDiscountId.');
            }
            const localVarPath = `/discounts/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a paginated list of Discounts
         * @summary Get Discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/discounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a Discount by it\'s ID.
         * @summary Get a Discount
         * @param {string} discountId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscountsDiscountId: (discountId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'discountId' is not null or undefined
            if (discountId === null || discountId === undefined) {
                throw new base_1.RequiredError('discountId', 'Required parameter discountId was null or undefined when calling getDiscountsDiscountId.');
            }
            const localVarPath = `/discounts/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new Discount.
         * @summary Create Discount
         * @param {InlineObject5} [inlineObject5]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscounts: (inlineObject5, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/discounts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject5 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject5 !== undefined ? inlineObject5 : {}) : (inlineObject5 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates a Discount
         * @summary Update Discount
         * @param {string} discountId
         * @param {InlineObject6} [inlineObject6]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDiscountsDiscountId: (discountId, inlineObject6, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'discountId' is not null or undefined
            if (discountId === null || discountId === undefined) {
                throw new base_1.RequiredError('discountId', 'Required parameter discountId was null or undefined when calling putDiscountsDiscountId.');
            }
            const localVarPath = `/discounts/{discountId}`
                .replace(`{${"discountId"}}`, encodeURIComponent(String(discountId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject6 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject6 !== undefined ? inlineObject6 : {}) : (inlineObject6 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DiscountsApi - functional programming interface
 * @export
 */
exports.DiscountsApiFp = function (configuration) {
    return {
        /**
         * Deletes a Discount
         * @summary Delete Discount
         * @param {string} discountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountId(discountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DiscountsApiAxiosParamCreator(configuration).deleteDiscountsDiscountId(discountId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a paginated list of Discounts
         * @summary Get Discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DiscountsApiAxiosParamCreator(configuration).getDiscounts(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a Discount by it\'s ID.
         * @summary Get a Discount
         * @param {string} discountId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscountsDiscountId(discountId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DiscountsApiAxiosParamCreator(configuration).getDiscountsDiscountId(discountId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new Discount.
         * @summary Create Discount
         * @param {InlineObject5} [inlineObject5]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscounts(inlineObject5, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DiscountsApiAxiosParamCreator(configuration).postDiscounts(inlineObject5, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates a Discount
         * @summary Update Discount
         * @param {string} discountId
         * @param {InlineObject6} [inlineObject6]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDiscountsDiscountId(discountId, inlineObject6, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.DiscountsApiAxiosParamCreator(configuration).putDiscountsDiscountId(discountId, inlineObject6, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * DiscountsApi - factory interface
 * @export
 */
exports.DiscountsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Deletes a Discount
         * @summary Delete Discount
         * @param {string} discountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscountsDiscountId(discountId, options) {
            return exports.DiscountsApiFp(configuration).deleteDiscountsDiscountId(discountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Discounts
         * @summary Get Discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts(options) {
            return exports.DiscountsApiFp(configuration).getDiscounts(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Discount by it\'s ID.
         * @summary Get a Discount
         * @param {string} discountId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscountsDiscountId(discountId, include, options) {
            return exports.DiscountsApiFp(configuration).getDiscountsDiscountId(discountId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new Discount.
         * @summary Create Discount
         * @param {InlineObject5} [inlineObject5]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDiscounts(inlineObject5, options) {
            return exports.DiscountsApiFp(configuration).postDiscounts(inlineObject5, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Discount
         * @summary Update Discount
         * @param {string} discountId
         * @param {InlineObject6} [inlineObject6]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDiscountsDiscountId(discountId, inlineObject6, options) {
            return exports.DiscountsApiFp(configuration).putDiscountsDiscountId(discountId, inlineObject6, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DiscountsApi - object-oriented interface
 * @export
 * @class DiscountsApi
 * @extends {BaseAPI}
 */
class DiscountsApi extends base_1.BaseAPI {
    /**
     * Deletes a Discount
     * @summary Delete Discount
     * @param {string} discountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    deleteDiscountsDiscountId(discountId, options) {
        return exports.DiscountsApiFp(this.configuration).deleteDiscountsDiscountId(discountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a paginated list of Discounts
     * @summary Get Discounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    getDiscounts(options) {
        return exports.DiscountsApiFp(this.configuration).getDiscounts(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a Discount by it\'s ID.
     * @summary Get a Discount
     * @param {string} discountId
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    getDiscountsDiscountId(discountId, include, options) {
        return exports.DiscountsApiFp(this.configuration).getDiscountsDiscountId(discountId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new Discount.
     * @summary Create Discount
     * @param {InlineObject5} [inlineObject5]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    postDiscounts(inlineObject5, options) {
        return exports.DiscountsApiFp(this.configuration).postDiscounts(inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a Discount
     * @summary Update Discount
     * @param {string} discountId
     * @param {InlineObject6} [inlineObject6]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    putDiscountsDiscountId(discountId, inlineObject6, options) {
        return exports.DiscountsApiFp(this.configuration).putDiscountsDiscountId(discountId, inlineObject6, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.DiscountsApi = DiscountsApi;
/**
 * LanguagesApi - axios parameter creator
 * @export
 */
exports.LanguagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a Language by its ID
         * @summary Delete Language
         * @param {string} languageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanguagesLanguageId: (languageId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new base_1.RequiredError('languageId', 'Required parameter languageId was null or undefined when calling deleteLanguagesLanguageId.');
            }
            const localVarPath = `/languages/{languageId}`
                .replace(`{${"languageId"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a paginated list of Languages
         * @summary Get Languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/languages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Language by ID
         * @summary Get Language
         * @param {string} languageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguagesLanguageId: (languageId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new base_1.RequiredError('languageId', 'Required parameter languageId was null or undefined when calling getLanguagesLanguageId.');
            }
            const localVarPath = `/languages/{languageId}`
                .replace(`{${"languageId"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new language
         * @summary Create Language
         * @param {string} name
         * @param {string} lang
         * @param {string} iso Unique
         * @param {boolean} [enabled]
         * @param {boolean} [_default]
         * @param {boolean} [current]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLanguages: (name, lang, iso, enabled, _default, current, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling postLanguages.');
            }
            // verify required parameter 'lang' is not null or undefined
            if (lang === null || lang === undefined) {
                throw new base_1.RequiredError('lang', 'Required parameter lang was null or undefined when calling postLanguages.');
            }
            // verify required parameter 'iso' is not null or undefined
            if (iso === null || iso === undefined) {
                throw new base_1.RequiredError('iso', 'Required parameter iso was null or undefined when calling postLanguages.');
            }
            const localVarPath = `/languages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (lang !== undefined) {
                localVarFormParams.append('lang', lang);
            }
            if (iso !== undefined) {
                localVarFormParams.append('iso', iso);
            }
            if (enabled !== undefined) {
                localVarFormParams.append('enabled', enabled);
            }
            if (_default !== undefined) {
                localVarFormParams.append('default', _default);
            }
            if (current !== undefined) {
                localVarFormParams.append('current', current);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Language using it\'s ID
         * @summary Update Language
         * @param {string} languageId
         * @param {Language} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLanguagesLanguageId: (languageId, language, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new base_1.RequiredError('languageId', 'Required parameter languageId was null or undefined when calling putLanguagesLanguageId.');
            }
            const localVarPath = `/languages/{languageId}`
                .replace(`{${"languageId"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof language !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(language !== undefined ? language : {}) : (language || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * LanguagesApi - functional programming interface
 * @export
 */
exports.LanguagesApiFp = function (configuration) {
    return {
        /**
         * Delete a Language by its ID
         * @summary Delete Language
         * @param {string} languageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanguagesLanguageId(languageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LanguagesApiAxiosParamCreator(configuration).deleteLanguagesLanguageId(languageId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a paginated list of Languages
         * @summary Get Languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LanguagesApiAxiosParamCreator(configuration).getLanguages(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Language by ID
         * @summary Get Language
         * @param {string} languageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguagesLanguageId(languageId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LanguagesApiAxiosParamCreator(configuration).getLanguagesLanguageId(languageId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new language
         * @summary Create Language
         * @param {string} name
         * @param {string} lang
         * @param {string} iso Unique
         * @param {boolean} [enabled]
         * @param {boolean} [_default]
         * @param {boolean} [current]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLanguages(name, lang, iso, enabled, _default, current, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LanguagesApiAxiosParamCreator(configuration).postLanguages(name, lang, iso, enabled, _default, current, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Language using it\'s ID
         * @summary Update Language
         * @param {string} languageId
         * @param {Language} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLanguagesLanguageId(languageId, language, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LanguagesApiAxiosParamCreator(configuration).putLanguagesLanguageId(languageId, language, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * LanguagesApi - factory interface
 * @export
 */
exports.LanguagesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete a Language by its ID
         * @summary Delete Language
         * @param {string} languageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLanguagesLanguageId(languageId, options) {
            return exports.LanguagesApiFp(configuration).deleteLanguagesLanguageId(languageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Languages
         * @summary Get Languages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages(options) {
            return exports.LanguagesApiFp(configuration).getLanguages(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Language by ID
         * @summary Get Language
         * @param {string} languageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguagesLanguageId(languageId, options) {
            return exports.LanguagesApiFp(configuration).getLanguagesLanguageId(languageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new language
         * @summary Create Language
         * @param {string} name
         * @param {string} lang
         * @param {string} iso Unique
         * @param {boolean} [enabled]
         * @param {boolean} [_default]
         * @param {boolean} [current]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postLanguages(name, lang, iso, enabled, _default, current, options) {
            return exports.LanguagesApiFp(configuration).postLanguages(name, lang, iso, enabled, _default, current, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Language using it\'s ID
         * @summary Update Language
         * @param {string} languageId
         * @param {Language} [language]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLanguagesLanguageId(languageId, language, options) {
            return exports.LanguagesApiFp(configuration).putLanguagesLanguageId(languageId, language, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
class LanguagesApi extends base_1.BaseAPI {
    /**
     * Delete a Language by its ID
     * @summary Delete Language
     * @param {string} languageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    deleteLanguagesLanguageId(languageId, options) {
        return exports.LanguagesApiFp(this.configuration).deleteLanguagesLanguageId(languageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a paginated list of Languages
     * @summary Get Languages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    getLanguages(options) {
        return exports.LanguagesApiFp(this.configuration).getLanguages(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Language by ID
     * @summary Get Language
     * @param {string} languageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    getLanguagesLanguageId(languageId, options) {
        return exports.LanguagesApiFp(this.configuration).getLanguagesLanguageId(languageId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new language
     * @summary Create Language
     * @param {string} name
     * @param {string} lang
     * @param {string} iso Unique
     * @param {boolean} [enabled]
     * @param {boolean} [_default]
     * @param {boolean} [current]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    postLanguages(name, lang, iso, enabled, _default, current, options) {
        return exports.LanguagesApiFp(this.configuration).postLanguages(name, lang, iso, enabled, _default, current, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Language using it\'s ID
     * @summary Update Language
     * @param {string} languageId
     * @param {Language} [language]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    putLanguagesLanguageId(languageId, language, options) {
        return exports.LanguagesApiFp(this.configuration).putLanguagesLanguageId(languageId, language, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LanguagesApi = LanguagesApi;
/**
 * LayoutsApi - axios parameter creator
 * @export
 */
exports.LayoutsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a paginated list of Layouts
         * @summary Get Layouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLayouts: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/layouts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * LayoutsApi - functional programming interface
 * @export
 */
exports.LayoutsApiFp = function (configuration) {
    return {
        /**
         * Get a paginated list of Layouts
         * @summary Get Layouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLayouts(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.LayoutsApiAxiosParamCreator(configuration).getLayouts(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * LayoutsApi - factory interface
 * @export
 */
exports.LayoutsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Get a paginated list of Layouts
         * @summary Get Layouts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLayouts(options) {
            return exports.LayoutsApiFp(configuration).getLayouts(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * LayoutsApi - object-oriented interface
 * @export
 * @class LayoutsApi
 * @extends {BaseAPI}
 */
class LayoutsApi extends base_1.BaseAPI {
    /**
     * Get a paginated list of Layouts
     * @summary Get Layouts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayoutsApi
     */
    getLayouts(options) {
        return exports.LayoutsApiFp(this.configuration).getLayouts(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LayoutsApi = LayoutsApi;
/**
 * OrdersApi - axios parameter creator
 * @export
 */
exports.OrdersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes an order line from an order
         * @summary Delete an order line
         * @param {string} orderLineId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrdersLinesOrderId: (orderLineId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderLineId' is not null or undefined
            if (orderLineId === null || orderLineId === undefined) {
                throw new base_1.RequiredError('orderLineId', 'Required parameter orderLineId was null or undefined when calling deleteOrdersLinesOrderId.');
            }
            const localVarPath = `/orders/lines/{orderLineId}`
                .replace(`{${"orderLineId"}}`, encodeURIComponent(String(orderLineId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * If you\'re an admin user you will be able to see all orders, otherwise only the current users orders will be returned.
         * @summary Get orders
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: (include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Export orders into a base64 encoded string
         * @summary Get Order export
         * @param {'1sfe534r4ref:934redfk'} orders Colon seperated order IDs
         * @param {string} format The export format, must be present in config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBulk: (orders, format, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orders' is not null or undefined
            if (orders === null || orders === undefined) {
                throw new base_1.RequiredError('orders', 'Required parameter orders was null or undefined when calling getOrdersBulk.');
            }
            // verify required parameter 'format' is not null or undefined
            if (format === null || format === undefined) {
                throw new base_1.RequiredError('format', 'Required parameter format was null or undefined when calling getOrdersBulk.');
            }
            const localVarPath = `/orders/bulk`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (orders !== undefined) {
                localVarQueryParameter['orders'] = orders;
            }
            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will get a HTML email preview for an order status, this is useful if you want to be able to see what email will be sent out for the corresponding Order status.  Mailers for each order status should be stored in the getcandy config under `orders.mailers`
         * @summary Get order status preview email
         * @param {string} id An order id to use for the template
         * @param {string} status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersEmailPreviewStatus: (id, status, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling getOrdersEmailPreviewStatus.');
            }
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new base_1.RequiredError('status', 'Required parameter status was null or undefined when calling getOrdersEmailPreviewStatus.');
            }
            const localVarPath = `/orders/email-preview/{status}`
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get an orders invoice
         * @summary Get order invoice
         * @param {string} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdInvoice: (orderId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling getOrdersIdInvoice.');
            }
            const localVarPath = `/orders/{orderId}/invoice`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This will return a list of all ShippingMethod\'s that are available for this order.
         * @summary Get Order Shipping Methods
         * @param {string} orderId
         * @param {string} [include] The available resources to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdShippingMethods: (orderId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling getOrdersIdShippingMethods.');
            }
            const localVarPath = `/orders/{orderId}/shipping/methods`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get an Order by it\'s ID.  You must be an admin or owner to retrieve the order, otherwise you\'ll get a 404.
         * @summary Get Order
         * @param {string} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersOrderId: (orderId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling getOrdersOrderId.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns all order types currently in the system
         * @summary Get order types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersTypes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/orders/types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create an Order from a Basket instance
         * @summary Create Order
         * @param {CreateOrderBody} [createOrderBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders: (createOrderBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof createOrderBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createOrderBody !== undefined ? createOrderBody : {}) : (createOrderBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows you to bulk update a field across multiple Orders.  You must have the correct priviledges to perform this action.
         * @summary Bulk update orders
         * @param {InlineObject9} [inlineObject9]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersBulk: (inlineObject9, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/orders/bulk`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject9 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject9 !== undefined ? inlineObject9 : {}) : (inlineObject9 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sets an order to be expired. You must have the correct priviledges to perform this action. Once an order is expired, it will no longer appear in results unless performed by an admin or in the hub.
         * @summary Expire an Order
         * @param {string} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderIdExpire: (orderId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling postOrdersOrderIdExpire.');
            }
            const localVarPath = `/orders/{orderId}/expire`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Processes an order on the API
         * @param {InlineObject8} [inlineObject8]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersProcess: (inlineObject8, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/orders/process`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject8 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject8 !== undefined ? inlineObject8 : {}) : (inlineObject8 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add contact details to an order
         * @summary Add contact details
         * @param {string} orderId
         * @param {InlineObject11} [inlineObject11]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdContact: (orderId, inlineObject11, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling putOrdersIdContact.');
            }
            const localVarPath = `/orders/{orderId}/contact`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject11 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject11 !== undefined ? inlineObject11 : {}) : (inlineObject11 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Adds an order line to an order
         * @summary Add order line
         * @param {string} orderId
         * @param {InlineObject12} [inlineObject12]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdLines: (orderId, inlineObject12, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling putOrdersIdLines.');
            }
            const localVarPath = `/orders/{orderId}/lines`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject12 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject12 !== undefined ? inlineObject12 : {}) : (inlineObject12 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update an orders shipping address
         * @summary Update shipping address
         * @param {string} orderId
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingAddress: (orderId, address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling putOrdersIdShippingAddress.');
            }
            const localVarPath = `/orders/{orderId}/shipping/address`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof address !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(address !== undefined ? address : {}) : (address || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Adds a shipping cost to an Order
         * @summary Add shipping cost
         * @param {string} orderId
         * @param {string} [include] Related resources to include in response
         * @param {InlineObject10} [inlineObject10]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingCost: (orderId, include, inlineObject10, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling putOrdersIdShippingCost.');
            }
            const localVarPath = `/orders/{orderId}/shipping/cost`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject10 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject10 !== undefined ? inlineObject10 : {}) : (inlineObject10 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update an Order
         * @summary Update Order
         * @param {string} orderId
         * @param {string} [include]
         * @param {InlineObject7} [inlineObject7]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderId: (orderId, include, inlineObject7, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling putOrdersOrderId.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject7 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject7 !== undefined ? inlineObject7 : {}) : (inlineObject7 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update an orders billing address
         * @summary Update billing address
         * @param {string} orderId
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderIdBillingAddress: (orderId, address, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new base_1.RequiredError('orderId', 'Required parameter orderId was null or undefined when calling putOrdersOrderIdBillingAddress.');
            }
            const localVarPath = `/orders/{orderId}/billing/address`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof address !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(address !== undefined ? address : {}) : (address || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * OrdersApi - functional programming interface
 * @export
 */
exports.OrdersApiFp = function (configuration) {
    return {
        /**
         * Deletes an order line from an order
         * @summary Delete an order line
         * @param {string} orderLineId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrdersLinesOrderId(orderLineId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).deleteOrdersLinesOrderId(orderLineId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * If you\'re an admin user you will be able to see all orders, otherwise only the current users orders will be returned.
         * @summary Get orders
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).getOrders(include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Export orders into a base64 encoded string
         * @summary Get Order export
         * @param {'1sfe534r4ref:934redfk'} orders Colon seperated order IDs
         * @param {string} format The export format, must be present in config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBulk(orders, format, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).getOrdersBulk(orders, format, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint will get a HTML email preview for an order status, this is useful if you want to be able to see what email will be sent out for the corresponding Order status.  Mailers for each order status should be stored in the getcandy config under `orders.mailers`
         * @summary Get order status preview email
         * @param {string} id An order id to use for the template
         * @param {string} status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersEmailPreviewStatus(id, status, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).getOrdersEmailPreviewStatus(id, status, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get an orders invoice
         * @summary Get order invoice
         * @param {string} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdInvoice(orderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).getOrdersIdInvoice(orderId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This will return a list of all ShippingMethod\'s that are available for this order.
         * @summary Get Order Shipping Methods
         * @param {string} orderId
         * @param {string} [include] The available resources to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdShippingMethods(orderId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).getOrdersIdShippingMethods(orderId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get an Order by it\'s ID.  You must be an admin or owner to retrieve the order, otherwise you\'ll get a 404.
         * @summary Get Order
         * @param {string} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersOrderId(orderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).getOrdersOrderId(orderId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns all order types currently in the system
         * @summary Get order types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersTypes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).getOrdersTypes(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create an Order from a Basket instance
         * @summary Create Order
         * @param {CreateOrderBody} [createOrderBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders(createOrderBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).postOrders(createOrderBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Allows you to bulk update a field across multiple Orders.  You must have the correct priviledges to perform this action.
         * @summary Bulk update orders
         * @param {InlineObject9} [inlineObject9]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersBulk(inlineObject9, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).postOrdersBulk(inlineObject9, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sets an order to be expired. You must have the correct priviledges to perform this action. Once an order is expired, it will no longer appear in results unless performed by an admin or in the hub.
         * @summary Expire an Order
         * @param {string} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderIdExpire(orderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).postOrdersOrderIdExpire(orderId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Processes an order on the API
         * @param {InlineObject8} [inlineObject8]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersProcess(inlineObject8, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).postOrdersProcess(inlineObject8, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Add contact details to an order
         * @summary Add contact details
         * @param {string} orderId
         * @param {InlineObject11} [inlineObject11]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdContact(orderId, inlineObject11, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).putOrdersIdContact(orderId, inlineObject11, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Adds an order line to an order
         * @summary Add order line
         * @param {string} orderId
         * @param {InlineObject12} [inlineObject12]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdLines(orderId, inlineObject12, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).putOrdersIdLines(orderId, inlineObject12, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update an orders shipping address
         * @summary Update shipping address
         * @param {string} orderId
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingAddress(orderId, address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).putOrdersIdShippingAddress(orderId, address, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Adds a shipping cost to an Order
         * @summary Add shipping cost
         * @param {string} orderId
         * @param {string} [include] Related resources to include in response
         * @param {InlineObject10} [inlineObject10]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingCost(orderId, include, inlineObject10, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).putOrdersIdShippingCost(orderId, include, inlineObject10, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update an Order
         * @summary Update Order
         * @param {string} orderId
         * @param {string} [include]
         * @param {InlineObject7} [inlineObject7]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderId(orderId, include, inlineObject7, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).putOrdersOrderId(orderId, include, inlineObject7, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update an orders billing address
         * @summary Update billing address
         * @param {string} orderId
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderIdBillingAddress(orderId, address, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.OrdersApiAxiosParamCreator(configuration).putOrdersOrderIdBillingAddress(orderId, address, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * OrdersApi - factory interface
 * @export
 */
exports.OrdersApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Deletes an order line from an order
         * @summary Delete an order line
         * @param {string} orderLineId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrdersLinesOrderId(orderLineId, options) {
            return exports.OrdersApiFp(configuration).deleteOrdersLinesOrderId(orderLineId, options).then((request) => request(axios, basePath));
        },
        /**
         * If you\'re an admin user you will be able to see all orders, otherwise only the current users orders will be returned.
         * @summary Get orders
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(include, options) {
            return exports.OrdersApiFp(configuration).getOrders(include, options).then((request) => request(axios, basePath));
        },
        /**
         * Export orders into a base64 encoded string
         * @summary Get Order export
         * @param {'1sfe534r4ref:934redfk'} orders Colon seperated order IDs
         * @param {string} format The export format, must be present in config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersBulk(orders, format, options) {
            return exports.OrdersApiFp(configuration).getOrdersBulk(orders, format, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will get a HTML email preview for an order status, this is useful if you want to be able to see what email will be sent out for the corresponding Order status.  Mailers for each order status should be stored in the getcandy config under `orders.mailers`
         * @summary Get order status preview email
         * @param {string} id An order id to use for the template
         * @param {string} status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersEmailPreviewStatus(id, status, options) {
            return exports.OrdersApiFp(configuration).getOrdersEmailPreviewStatus(id, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an orders invoice
         * @summary Get order invoice
         * @param {string} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdInvoice(orderId, options) {
            return exports.OrdersApiFp(configuration).getOrdersIdInvoice(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return a list of all ShippingMethod\'s that are available for this order.
         * @summary Get Order Shipping Methods
         * @param {string} orderId
         * @param {string} [include] The available resources to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersIdShippingMethods(orderId, include, options) {
            return exports.OrdersApiFp(configuration).getOrdersIdShippingMethods(orderId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an Order by it\'s ID.  You must be an admin or owner to retrieve the order, otherwise you\'ll get a 404.
         * @summary Get Order
         * @param {string} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersOrderId(orderId, options) {
            return exports.OrdersApiFp(configuration).getOrdersOrderId(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all order types currently in the system
         * @summary Get order types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersTypes(options) {
            return exports.OrdersApiFp(configuration).getOrdersTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Create an Order from a Basket instance
         * @summary Create Order
         * @param {CreateOrderBody} [createOrderBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrders(createOrderBody, options) {
            return exports.OrdersApiFp(configuration).postOrders(createOrderBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to bulk update a field across multiple Orders.  You must have the correct priviledges to perform this action.
         * @summary Bulk update orders
         * @param {InlineObject9} [inlineObject9]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersBulk(inlineObject9, options) {
            return exports.OrdersApiFp(configuration).postOrdersBulk(inlineObject9, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets an order to be expired. You must have the correct priviledges to perform this action. Once an order is expired, it will no longer appear in results unless performed by an admin or in the hub.
         * @summary Expire an Order
         * @param {string} orderId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersOrderIdExpire(orderId, options) {
            return exports.OrdersApiFp(configuration).postOrdersOrderIdExpire(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Processes an order on the API
         * @param {InlineObject8} [inlineObject8]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postOrdersProcess(inlineObject8, options) {
            return exports.OrdersApiFp(configuration).postOrdersProcess(inlineObject8, options).then((request) => request(axios, basePath));
        },
        /**
         * Add contact details to an order
         * @summary Add contact details
         * @param {string} orderId
         * @param {InlineObject11} [inlineObject11]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdContact(orderId, inlineObject11, options) {
            return exports.OrdersApiFp(configuration).putOrdersIdContact(orderId, inlineObject11, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds an order line to an order
         * @summary Add order line
         * @param {string} orderId
         * @param {InlineObject12} [inlineObject12]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdLines(orderId, inlineObject12, options) {
            return exports.OrdersApiFp(configuration).putOrdersIdLines(orderId, inlineObject12, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an orders shipping address
         * @summary Update shipping address
         * @param {string} orderId
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingAddress(orderId, address, options) {
            return exports.OrdersApiFp(configuration).putOrdersIdShippingAddress(orderId, address, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a shipping cost to an Order
         * @summary Add shipping cost
         * @param {string} orderId
         * @param {string} [include] Related resources to include in response
         * @param {InlineObject10} [inlineObject10]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersIdShippingCost(orderId, include, inlineObject10, options) {
            return exports.OrdersApiFp(configuration).putOrdersIdShippingCost(orderId, include, inlineObject10, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an Order
         * @summary Update Order
         * @param {string} orderId
         * @param {string} [include]
         * @param {InlineObject7} [inlineObject7]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderId(orderId, include, inlineObject7, options) {
            return exports.OrdersApiFp(configuration).putOrdersOrderId(orderId, include, inlineObject7, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an orders billing address
         * @summary Update billing address
         * @param {string} orderId
         * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOrdersOrderIdBillingAddress(orderId, address, options) {
            return exports.OrdersApiFp(configuration).putOrdersOrderIdBillingAddress(orderId, address, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
class OrdersApi extends base_1.BaseAPI {
    /**
     * Deletes an order line from an order
     * @summary Delete an order line
     * @param {string} orderLineId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    deleteOrdersLinesOrderId(orderLineId, options) {
        return exports.OrdersApiFp(this.configuration).deleteOrdersLinesOrderId(orderLineId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * If you\'re an admin user you will be able to see all orders, otherwise only the current users orders will be returned.
     * @summary Get orders
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrders(include, options) {
        return exports.OrdersApiFp(this.configuration).getOrders(include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Export orders into a base64 encoded string
     * @summary Get Order export
     * @param {'1sfe534r4ref:934redfk'} orders Colon seperated order IDs
     * @param {string} format The export format, must be present in config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrdersBulk(orders, format, options) {
        return exports.OrdersApiFp(this.configuration).getOrdersBulk(orders, format, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will get a HTML email preview for an order status, this is useful if you want to be able to see what email will be sent out for the corresponding Order status.  Mailers for each order status should be stored in the getcandy config under `orders.mailers`
     * @summary Get order status preview email
     * @param {string} id An order id to use for the template
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrdersEmailPreviewStatus(id, status, options) {
        return exports.OrdersApiFp(this.configuration).getOrdersEmailPreviewStatus(id, status, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an orders invoice
     * @summary Get order invoice
     * @param {string} orderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrdersIdInvoice(orderId, options) {
        return exports.OrdersApiFp(this.configuration).getOrdersIdInvoice(orderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This will return a list of all ShippingMethod\'s that are available for this order.
     * @summary Get Order Shipping Methods
     * @param {string} orderId
     * @param {string} [include] The available resources to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrdersIdShippingMethods(orderId, include, options) {
        return exports.OrdersApiFp(this.configuration).getOrdersIdShippingMethods(orderId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get an Order by it\'s ID.  You must be an admin or owner to retrieve the order, otherwise you\'ll get a 404.
     * @summary Get Order
     * @param {string} orderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrdersOrderId(orderId, options) {
        return exports.OrdersApiFp(this.configuration).getOrdersOrderId(orderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all order types currently in the system
     * @summary Get order types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    getOrdersTypes(options) {
        return exports.OrdersApiFp(this.configuration).getOrdersTypes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create an Order from a Basket instance
     * @summary Create Order
     * @param {CreateOrderBody} [createOrderBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    postOrders(createOrderBody, options) {
        return exports.OrdersApiFp(this.configuration).postOrders(createOrderBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to bulk update a field across multiple Orders.  You must have the correct priviledges to perform this action.
     * @summary Bulk update orders
     * @param {InlineObject9} [inlineObject9]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    postOrdersBulk(inlineObject9, options) {
        return exports.OrdersApiFp(this.configuration).postOrdersBulk(inlineObject9, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets an order to be expired. You must have the correct priviledges to perform this action. Once an order is expired, it will no longer appear in results unless performed by an admin or in the hub.
     * @summary Expire an Order
     * @param {string} orderId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    postOrdersOrderIdExpire(orderId, options) {
        return exports.OrdersApiFp(this.configuration).postOrdersOrderIdExpire(orderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Processes an order on the API
     * @param {InlineObject8} [inlineObject8]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    postOrdersProcess(inlineObject8, options) {
        return exports.OrdersApiFp(this.configuration).postOrdersProcess(inlineObject8, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add contact details to an order
     * @summary Add contact details
     * @param {string} orderId
     * @param {InlineObject11} [inlineObject11]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    putOrdersIdContact(orderId, inlineObject11, options) {
        return exports.OrdersApiFp(this.configuration).putOrdersIdContact(orderId, inlineObject11, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds an order line to an order
     * @summary Add order line
     * @param {string} orderId
     * @param {InlineObject12} [inlineObject12]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    putOrdersIdLines(orderId, inlineObject12, options) {
        return exports.OrdersApiFp(this.configuration).putOrdersIdLines(orderId, inlineObject12, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an orders shipping address
     * @summary Update shipping address
     * @param {string} orderId
     * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    putOrdersIdShippingAddress(orderId, address, options) {
        return exports.OrdersApiFp(this.configuration).putOrdersIdShippingAddress(orderId, address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds a shipping cost to an Order
     * @summary Add shipping cost
     * @param {string} orderId
     * @param {string} [include] Related resources to include in response
     * @param {InlineObject10} [inlineObject10]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    putOrdersIdShippingCost(orderId, include, inlineObject10, options) {
        return exports.OrdersApiFp(this.configuration).putOrdersIdShippingCost(orderId, include, inlineObject10, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an Order
     * @summary Update Order
     * @param {string} orderId
     * @param {string} [include]
     * @param {InlineObject7} [inlineObject7]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    putOrdersOrderId(orderId, include, inlineObject7, options) {
        return exports.OrdersApiFp(this.configuration).putOrdersOrderId(orderId, include, inlineObject7, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update an orders billing address
     * @summary Update billing address
     * @param {string} orderId
     * @param {Address} [address] All fields are required when an &#x60;address_id&#x60; is not present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    putOrdersOrderIdBillingAddress(orderId, address, options) {
        return exports.OrdersApiFp(this.configuration).putOrdersOrderIdBillingAddress(orderId, address, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OrdersApi = OrdersApi;
/**
 * PaymentsApi - axios parameter creator
 * @export
 */
exports.PaymentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets the default, configured payment provider.
         * @summary Get Payment Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsProvider: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/payments/provider`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of available Payment Types in the system
         * @summary Payment types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsTypes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/payments/types`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Validate a ThreeD secure request and process the transaaction, if your payment provider supports it.
         * @summary Threed Secure Payment
         * @param {InlineObject14} [inlineObject14]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPayments3dSecure: (inlineObject14, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/payments/3d-secure`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject14 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject14 !== undefined ? inlineObject14 : {}) : (inlineObject14 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Refund a transaction
         * @summary Refund a payment
         * @param {string} transactionId
         * @param {number} [amount] If left blank, the full amount will be refunded
         * @param {string} [notes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsIdRefund: (transactionId, amount, notes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new base_1.RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling postPaymentsIdRefund.');
            }
            const localVarPath = `/payments/{transactionId}/refund`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (amount !== undefined) {
                localVarFormParams.append('amount', amount);
            }
            if (notes !== undefined) {
                localVarFormParams.append('notes', notes);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Voids a payment in the system.
         * @summary Void a payment
         * @param {string} transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsTransactionIdVoid: (transactionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'transactionId' is not null or undefined
            if (transactionId === null || transactionId === undefined) {
                throw new base_1.RequiredError('transactionId', 'Required parameter transactionId was null or undefined when calling postPaymentsTransactionIdVoid.');
            }
            const localVarPath = `/payments/{transactionId}/void`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * PaymentsApi - functional programming interface
 * @export
 */
exports.PaymentsApiFp = function (configuration) {
    return {
        /**
         * Gets the default, configured payment provider.
         * @summary Get Payment Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsProvider(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.PaymentsApiAxiosParamCreator(configuration).getPaymentsProvider(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a list of available Payment Types in the system
         * @summary Payment types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsTypes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.PaymentsApiAxiosParamCreator(configuration).getPaymentsTypes(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Validate a ThreeD secure request and process the transaaction, if your payment provider supports it.
         * @summary Threed Secure Payment
         * @param {InlineObject14} [inlineObject14]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPayments3dSecure(inlineObject14, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.PaymentsApiAxiosParamCreator(configuration).postPayments3dSecure(inlineObject14, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Refund a transaction
         * @summary Refund a payment
         * @param {string} transactionId
         * @param {number} [amount] If left blank, the full amount will be refunded
         * @param {string} [notes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsIdRefund(transactionId, amount, notes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.PaymentsApiAxiosParamCreator(configuration).postPaymentsIdRefund(transactionId, amount, notes, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Voids a payment in the system.
         * @summary Void a payment
         * @param {string} transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsTransactionIdVoid(transactionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.PaymentsApiAxiosParamCreator(configuration).postPaymentsTransactionIdVoid(transactionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * PaymentsApi - factory interface
 * @export
 */
exports.PaymentsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Gets the default, configured payment provider.
         * @summary Get Payment Provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsProvider(options) {
            return exports.PaymentsApiFp(configuration).getPaymentsProvider(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of available Payment Types in the system
         * @summary Payment types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsTypes(options) {
            return exports.PaymentsApiFp(configuration).getPaymentsTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate a ThreeD secure request and process the transaaction, if your payment provider supports it.
         * @summary Threed Secure Payment
         * @param {InlineObject14} [inlineObject14]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPayments3dSecure(inlineObject14, options) {
            return exports.PaymentsApiFp(configuration).postPayments3dSecure(inlineObject14, options).then((request) => request(axios, basePath));
        },
        /**
         * Refund a transaction
         * @summary Refund a payment
         * @param {string} transactionId
         * @param {number} [amount] If left blank, the full amount will be refunded
         * @param {string} [notes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsIdRefund(transactionId, amount, notes, options) {
            return exports.PaymentsApiFp(configuration).postPaymentsIdRefund(transactionId, amount, notes, options).then((request) => request(axios, basePath));
        },
        /**
         * Voids a payment in the system.
         * @summary Void a payment
         * @param {string} transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postPaymentsTransactionIdVoid(transactionId, options) {
            return exports.PaymentsApiFp(configuration).postPaymentsTransactionIdVoid(transactionId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */
class PaymentsApi extends base_1.BaseAPI {
    /**
     * Gets the default, configured payment provider.
     * @summary Get Payment Provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    getPaymentsProvider(options) {
        return exports.PaymentsApiFp(this.configuration).getPaymentsProvider(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of available Payment Types in the system
     * @summary Payment types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    getPaymentsTypes(options) {
        return exports.PaymentsApiFp(this.configuration).getPaymentsTypes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Validate a ThreeD secure request and process the transaaction, if your payment provider supports it.
     * @summary Threed Secure Payment
     * @param {InlineObject14} [inlineObject14]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    postPayments3dSecure(inlineObject14, options) {
        return exports.PaymentsApiFp(this.configuration).postPayments3dSecure(inlineObject14, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Refund a transaction
     * @summary Refund a payment
     * @param {string} transactionId
     * @param {number} [amount] If left blank, the full amount will be refunded
     * @param {string} [notes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    postPaymentsIdRefund(transactionId, amount, notes, options) {
        return exports.PaymentsApiFp(this.configuration).postPaymentsIdRefund(transactionId, amount, notes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Voids a payment in the system.
     * @summary Void a payment
     * @param {string} transactionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentsApi
     */
    postPaymentsTransactionIdVoid(transactionId, options) {
        return exports.PaymentsApiFp(this.configuration).postPaymentsTransactionIdVoid(transactionId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PaymentsApi = PaymentsApi;
/**
 * ProductFamiliesApi - axios parameter creator
 * @export
 */
exports.ProductFamiliesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Sends a request to delete a product family
         * @summary Delete product family
         * @param {string} productFamilyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFamiliesProductFamilyId: (productFamilyId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productFamilyId' is not null or undefined
            if (productFamilyId === null || productFamilyId === undefined) {
                throw new base_1.RequiredError('productFamilyId', 'Required parameter productFamilyId was null or undefined when calling deleteProductFamiliesProductFamilyId.');
            }
            const localVarPath = `/product-families/{productFamilyId}`
                .replace(`{${"productFamilyId"}}`, encodeURIComponent(String(productFamilyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a paginated list of all product families.
         * @summary Get product families
         * @param {string} [include] Define included relationships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamilies: (include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/product-families`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a single product family based on ID.
         * @summary Get a product family
         * @param {string} productFamilyId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamiliesProductFamilyId: (productFamilyId, includes, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productFamilyId' is not null or undefined
            if (productFamilyId === null || productFamilyId === undefined) {
                throw new base_1.RequiredError('productFamilyId', 'Required parameter productFamilyId was null or undefined when calling getProductFamiliesProductFamilyId.');
            }
            const localVarPath = `/product-families/{productFamilyId}`
                .replace(`{${"productFamilyId"}}`, encodeURIComponent(String(productFamilyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includes !== undefined) {
                localVarQueryParameter['includes'] = includes;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new product family.
         * @summary Create product family
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductFamilies: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/product-families`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a product family
         * @summary Update product family
         * @param {string} productFamilyId
         * @param {InlineObject15} [inlineObject15]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductFamiliesProductFamilyId: (productFamilyId, inlineObject15, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productFamilyId' is not null or undefined
            if (productFamilyId === null || productFamilyId === undefined) {
                throw new base_1.RequiredError('productFamilyId', 'Required parameter productFamilyId was null or undefined when calling putProductFamiliesProductFamilyId.');
            }
            const localVarPath = `/product-families/{productFamilyId}`
                .replace(`{${"productFamilyId"}}`, encodeURIComponent(String(productFamilyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject15 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject15 !== undefined ? inlineObject15 : {}) : (inlineObject15 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProductFamiliesApi - functional programming interface
 * @export
 */
exports.ProductFamiliesApiFp = function (configuration) {
    return {
        /**
         * Sends a request to delete a product family
         * @summary Delete product family
         * @param {string} productFamilyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFamiliesProductFamilyId(productFamilyId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductFamiliesApiAxiosParamCreator(configuration).deleteProductFamiliesProductFamilyId(productFamilyId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a paginated list of all product families.
         * @summary Get product families
         * @param {string} [include] Define included relationships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamilies(include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductFamiliesApiAxiosParamCreator(configuration).getProductFamilies(include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a single product family based on ID.
         * @summary Get a product family
         * @param {string} productFamilyId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamiliesProductFamilyId(productFamilyId, includes, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductFamiliesApiAxiosParamCreator(configuration).getProductFamiliesProductFamilyId(productFamilyId, includes, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new product family.
         * @summary Create product family
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductFamilies(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductFamiliesApiAxiosParamCreator(configuration).postProductFamilies(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a product family
         * @summary Update product family
         * @param {string} productFamilyId
         * @param {InlineObject15} [inlineObject15]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductFamiliesProductFamilyId(productFamilyId, inlineObject15, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductFamiliesApiAxiosParamCreator(configuration).putProductFamiliesProductFamilyId(productFamilyId, inlineObject15, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProductFamiliesApi - factory interface
 * @export
 */
exports.ProductFamiliesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Sends a request to delete a product family
         * @summary Delete product family
         * @param {string} productFamilyId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductFamiliesProductFamilyId(productFamilyId, options) {
            return exports.ProductFamiliesApiFp(configuration).deleteProductFamiliesProductFamilyId(productFamilyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all product families.
         * @summary Get product families
         * @param {string} [include] Define included relationships
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamilies(include, options) {
            return exports.ProductFamiliesApiFp(configuration).getProductFamilies(include, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single product family based on ID.
         * @summary Get a product family
         * @param {string} productFamilyId
         * @param {string} [includes]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductFamiliesProductFamilyId(productFamilyId, includes, options) {
            return exports.ProductFamiliesApiFp(configuration).getProductFamiliesProductFamilyId(productFamilyId, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new product family.
         * @summary Create product family
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductFamilies(options) {
            return exports.ProductFamiliesApiFp(configuration).postProductFamilies(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a product family
         * @summary Update product family
         * @param {string} productFamilyId
         * @param {InlineObject15} [inlineObject15]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductFamiliesProductFamilyId(productFamilyId, inlineObject15, options) {
            return exports.ProductFamiliesApiFp(configuration).putProductFamiliesProductFamilyId(productFamilyId, inlineObject15, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductFamiliesApi - object-oriented interface
 * @export
 * @class ProductFamiliesApi
 * @extends {BaseAPI}
 */
class ProductFamiliesApi extends base_1.BaseAPI {
    /**
     * Sends a request to delete a product family
     * @summary Delete product family
     * @param {string} productFamilyId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    deleteProductFamiliesProductFamilyId(productFamilyId, options) {
        return exports.ProductFamiliesApiFp(this.configuration).deleteProductFamiliesProductFamilyId(productFamilyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a paginated list of all product families.
     * @summary Get product families
     * @param {string} [include] Define included relationships
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    getProductFamilies(include, options) {
        return exports.ProductFamiliesApiFp(this.configuration).getProductFamilies(include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a single product family based on ID.
     * @summary Get a product family
     * @param {string} productFamilyId
     * @param {string} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    getProductFamiliesProductFamilyId(productFamilyId, includes, options) {
        return exports.ProductFamiliesApiFp(this.configuration).getProductFamiliesProductFamilyId(productFamilyId, includes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new product family.
     * @summary Create product family
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    postProductFamilies(options) {
        return exports.ProductFamiliesApiFp(this.configuration).postProductFamilies(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a product family
     * @summary Update product family
     * @param {string} productFamilyId
     * @param {InlineObject15} [inlineObject15]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductFamiliesApi
     */
    putProductFamiliesProductFamilyId(productFamilyId, inlineObject15, options) {
        return exports.ProductFamiliesApiFp(this.configuration).putProductFamiliesProductFamilyId(productFamilyId, inlineObject15, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductFamiliesApi = ProductFamiliesApi;
/**
 * ProductVariantsApi - axios parameter creator
 * @export
 */
exports.ProductVariantsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a paginated list of all product variants in the system
         * @summary Get Product Variants
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariants: (include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/products/variants`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a product variant by it\'s ID
         * @summary Get Product Variant
         * @param {string} productVariantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariantsProductVariantId: (productVariantId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productVariantId' is not null or undefined
            if (productVariantId === null || productVariantId === undefined) {
                throw new base_1.RequiredError('productVariantId', 'Required parameter productVariantId was null or undefined when calling getProductsVariantsProductVariantId.');
            }
            const localVarPath = `/products/variants/{productVariantId}`
                .replace(`{${"productVariantId"}}`, encodeURIComponent(String(productVariantId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Request to update a product variants inventory.
         * @summary Update ProductVariant Inventory
         * @param {string} productVariantId
         * @param {InlineObject16} [inlineObject16]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsVariantsProductVariantIdInventory: (productVariantId, inlineObject16, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productVariantId' is not null or undefined
            if (productVariantId === null || productVariantId === undefined) {
                throw new base_1.RequiredError('productVariantId', 'Required parameter productVariantId was null or undefined when calling putProductsVariantsProductVariantIdInventory.');
            }
            const localVarPath = `/products/variants/{productVariantId}/inventory`
                .replace(`{${"productVariantId"}}`, encodeURIComponent(String(productVariantId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject16 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject16 !== undefined ? inlineObject16 : {}) : (inlineObject16 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProductVariantsApi - functional programming interface
 * @export
 */
exports.ProductVariantsApiFp = function (configuration) {
    return {
        /**
         * Get a paginated list of all product variants in the system
         * @summary Get Product Variants
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariants(include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductVariantsApiAxiosParamCreator(configuration).getProductsVariants(include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a product variant by it\'s ID
         * @summary Get Product Variant
         * @param {string} productVariantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariantsProductVariantId(productVariantId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductVariantsApiAxiosParamCreator(configuration).getProductsVariantsProductVariantId(productVariantId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Request to update a product variants inventory.
         * @summary Update ProductVariant Inventory
         * @param {string} productVariantId
         * @param {InlineObject16} [inlineObject16]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsVariantsProductVariantIdInventory(productVariantId, inlineObject16, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductVariantsApiAxiosParamCreator(configuration).putProductsVariantsProductVariantIdInventory(productVariantId, inlineObject16, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProductVariantsApi - factory interface
 * @export
 */
exports.ProductVariantsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Get a paginated list of all product variants in the system
         * @summary Get Product Variants
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariants(include, options) {
            return exports.ProductVariantsApiFp(configuration).getProductsVariants(include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a product variant by it\'s ID
         * @summary Get Product Variant
         * @param {string} productVariantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsVariantsProductVariantId(productVariantId, options) {
            return exports.ProductVariantsApiFp(configuration).getProductsVariantsProductVariantId(productVariantId, options).then((request) => request(axios, basePath));
        },
        /**
         * Request to update a product variants inventory.
         * @summary Update ProductVariant Inventory
         * @param {string} productVariantId
         * @param {InlineObject16} [inlineObject16]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsVariantsProductVariantIdInventory(productVariantId, inlineObject16, options) {
            return exports.ProductVariantsApiFp(configuration).putProductsVariantsProductVariantIdInventory(productVariantId, inlineObject16, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductVariantsApi - object-oriented interface
 * @export
 * @class ProductVariantsApi
 * @extends {BaseAPI}
 */
class ProductVariantsApi extends base_1.BaseAPI {
    /**
     * Get a paginated list of all product variants in the system
     * @summary Get Product Variants
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductVariantsApi
     */
    getProductsVariants(include, options) {
        return exports.ProductVariantsApiFp(this.configuration).getProductsVariants(include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a product variant by it\'s ID
     * @summary Get Product Variant
     * @param {string} productVariantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductVariantsApi
     */
    getProductsVariantsProductVariantId(productVariantId, options) {
        return exports.ProductVariantsApiFp(this.configuration).getProductsVariantsProductVariantId(productVariantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request to update a product variants inventory.
     * @summary Update ProductVariant Inventory
     * @param {string} productVariantId
     * @param {InlineObject16} [inlineObject16]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductVariantsApi
     */
    putProductsVariantsProductVariantIdInventory(productVariantId, inlineObject16, options) {
        return exports.ProductVariantsApiFp(this.configuration).putProductsVariantsProductVariantIdInventory(productVariantId, inlineObject16, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductVariantsApi = ProductVariantsApi;
/**
 * ProductsApi - axios parameter creator
 * @export
 */
exports.ProductsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory: (productId, categoryId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductCategoriesCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new base_1.RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling deleteProductsProductCategoriesCategory.');
            }
            const localVarPath = `/products/{productId}/categories/{categoryId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach: (productId, collectionId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductCollectionsDetach.');
            }
            // verify required parameter 'collectionId' is not null or undefined
            if (collectionId === null || collectionId === undefined) {
                throw new base_1.RequiredError('collectionId', 'Required parameter collectionId was null or undefined when calling deleteProductsProductCollectionsDetach.');
            }
            const localVarPath = `/products/{productId}/collections/{collectionId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"collectionId"}}`, encodeURIComponent(String(collectionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductCustomerGroups.');
            }
            const localVarPath = `/products/{productId}/customer-groups`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes product associations
         * @summary
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling deleteProductsProductIdAssociations.');
            }
            const localVarPath = `/products/{productId}/associations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: (include, paginated, ids, limit, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (paginated !== undefined) {
                localVarQueryParameter['paginated'] = paginated;
            }
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId: (productId, include, exclTax, fullResponse, optionData, draft, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling getProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (exclTax !== undefined) {
                localVarQueryParameter['excl_tax'] = exclTax;
            }
            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }
            if (optionData !== undefined) {
                localVarQueryParameter['option_data'] = optionData;
            }
            if (draft !== undefined) {
                localVarQueryParameter['draft'] = draft;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling getProductsProductIdDrafts.');
            }
            const localVarPath = `/products/{productId}/drafts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended: (basketId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'basketId' is not null or undefined
            if (basketId === null || basketId === undefined) {
                throw new base_1.RequiredError('basketId', 'Required parameter basketId was null or undefined when calling getProductsRecommended.');
            }
            const localVarPath = `/products/recommended`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (basketId !== undefined) {
                localVarQueryParameter['basket_id'] = basketId;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects: (productId, inlineObject19, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductRedirects.');
            }
            const localVarPath = `/products/{productId}/redirects`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject19 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject19 !== undefined ? inlineObject19 : {}) : (inlineObject19 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls: (productId, inlineObject18, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductUrls.');
            }
            const localVarPath = `/products/{productId}/urls`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject18 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject18 !== undefined ? inlineObject18 : {}) : (inlineObject18 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts: (name, url, stock, familyId, price, sku, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new base_1.RequiredError('name', 'Required parameter name was null or undefined when calling postProducts.');
            }
            // verify required parameter 'url' is not null or undefined
            if (url === null || url === undefined) {
                throw new base_1.RequiredError('url', 'Required parameter url was null or undefined when calling postProducts.');
            }
            // verify required parameter 'stock' is not null or undefined
            if (stock === null || stock === undefined) {
                throw new base_1.RequiredError('stock', 'Required parameter stock was null or undefined when calling postProducts.');
            }
            // verify required parameter 'familyId' is not null or undefined
            if (familyId === null || familyId === undefined) {
                throw new base_1.RequiredError('familyId', 'Required parameter familyId was null or undefined when calling postProducts.');
            }
            // verify required parameter 'price' is not null or undefined
            if (price === null || price === undefined) {
                throw new base_1.RequiredError('price', 'Required parameter price was null or undefined when calling postProducts.');
            }
            // verify required parameter 'sku' is not null or undefined
            if (sku === null || sku === undefined) {
                throw new base_1.RequiredError('sku', 'Required parameter sku was null or undefined when calling postProducts.');
            }
            const localVarPath = `/products`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new FormData();
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (name !== undefined) {
                localVarFormParams.append('name', name);
            }
            if (url !== undefined) {
                localVarFormParams.append('url', url);
            }
            if (stock !== undefined) {
                localVarFormParams.append('stock', stock);
            }
            if (familyId !== undefined) {
                localVarFormParams.append('family_id', familyId);
            }
            if (price !== undefined) {
                localVarFormParams.append('price', price);
            }
            if (sku !== undefined) {
                localVarFormParams.append('sku', sku);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsIdDrafts.');
            }
            const localVarPath = `/products/{productId}/drafts`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish: (productId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsIdPublish.');
            }
            const localVarPath = `/products/{productId}/publish`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations: (productId, inlineObject24, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductAssociations.');
            }
            const localVarPath = `/products/{productId}/associations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject24 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject24 !== undefined ? inlineObject24 : {}) : (inlineObject24 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes: (productId, inlineObject20, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductAttributes.');
            }
            const localVarPath = `/products/{productId}/attributes`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject20 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject20 !== undefined ? inlineObject20 : {}) : (inlineObject20 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories: (productId, inlineObject22, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductCategories.');
            }
            const localVarPath = `/products/{productId}/categories`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject22 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject22 !== undefined ? inlineObject22 : {}) : (inlineObject22 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels: (productId, inlineObject23, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductChannels.');
            }
            const localVarPath = `/products/{productId}/channels`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject23 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject23 !== undefined ? inlineObject23 : {}) : (inlineObject23 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups: (productId, inlineObject25, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductCustomerGroups.');
            }
            const localVarPath = `/products/{productId}/customer-groups`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject25 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject25 !== undefined ? inlineObject25 : {}) : (inlineObject25 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections: (productId, inlineObject21, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductIdCollections.');
            }
            const localVarPath = `/products/{productId}/collections`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject21 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject21 !== undefined ? inlineObject21 : {}) : (inlineObject21 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate: (productId, inlineObject17, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling postProductsProductIdDuplicate.');
            }
            const localVarPath = `/products/{productId}/duplicate`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject17 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject17 !== undefined ? inlineObject17 : {}) : (inlineObject17 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId
         * @param {ProductUpdateBody} [productUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId: (productId, productUpdateBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new base_1.RequiredError('productId', 'Required parameter productId was null or undefined when calling putProductsProductId.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof productUpdateBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(productUpdateBody !== undefined ? productUpdateBody : {}) : (productUpdateBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
exports.ProductsApiFp = function (configuration) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory(productId, categoryId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach(productId, collectionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductCustomerGroups(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductId(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Removes product associations
         * @summary
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).deleteProductsProductIdAssociations(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(include, paginated, ids, limit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProducts(include, paginated, ids, limit, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProductsProductIdDrafts(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended(basketId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).getProductsRecommended(basketId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects(productId, inlineObject19, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductRedirects(productId, inlineObject19, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls(productId, inlineObject18, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductUrls(productId, inlineObject18, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts(name, url, stock, familyId, price, sku, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProducts(name, url, stock, familyId, price, sku, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsIdDrafts(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish(productId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsIdPublish(productId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations(productId, inlineObject24, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductAssociations(productId, inlineObject24, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes(productId, inlineObject20, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductAttributes(productId, inlineObject20, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories(productId, inlineObject22, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductCategories(productId, inlineObject22, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels(productId, inlineObject23, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductChannels(productId, inlineObject23, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups(productId, inlineObject25, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductCustomerGroups(productId, inlineObject25, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections(productId, inlineObject21, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductIdCollections(productId, inlineObject21, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate(productId, inlineObject17, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).postProductsProductIdDuplicate(productId, inlineObject17, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId
         * @param {ProductUpdateBody} [productUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId(productId, productUpdateBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ProductsApiAxiosParamCreator(configuration).putProductsProductId(productId, productUpdateBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ProductsApi - factory interface
 * @export
 */
exports.ProductsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Detaches a category from a product. Does not delete the category.
         * @summary Detach category
         * @param {string} productId
         * @param {string} categoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCategoriesCategory(productId, categoryId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches a collection from a product. Does not delete the collection.
         * @summary Detach collection
         * @param {string} productId
         * @param {string} collectionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCollectionsDetach(productId, collectionId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detaches customer groups from a product
         * @summary Detach customer groups
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductCustomerGroups(productId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductCustomerGroups(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
         * @summary Delete Product
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductId(productId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductId(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes product associations
         * @summary
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductsProductIdAssociations(productId, options) {
            return exports.ProductsApiFp(configuration).deleteProductsProductIdAssociations(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of products.
         * @summary Get Products
         * @param {string} [include]
         * @param {boolean} [paginated]
         * @param {string} [ids] Return only the selected IDs
         * @param {number} [limit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(include, paginated, ids, limit, options) {
            return exports.ProductsApiFp(configuration).getProducts(include, paginated, ids, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a product by it\'s given ID
         * @summary Get Product
         * @param {string} productId
         * @param {string} [include]
         * @param {string} [exclTax] Prices shouldn\&#39;t include tax
         * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
         * @param {string} [optionData] Include option data
         * @param {string} [draft] Show draft if exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options) {
            return exports.ProductsApiFp(configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft for a product.  If a draft already exists, that current draft will be returned.
         * @summary Create draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsProductIdDrafts(productId, options) {
            return exports.ProductsApiFp(configuration).getProductsProductIdDrafts(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
         * @summary Get recommended products
         * @param {string} basketId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsRecommended(basketId, options) {
            return exports.ProductsApiFp(configuration).getProductsRecommended(basketId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product redirect
         * @param {string} productId
         * @param {InlineObject19} [inlineObject19]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductRedirects(productId, inlineObject19, options) {
            return exports.ProductsApiFp(configuration).postProductRedirects(productId, inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and syncs a new product route.
         * @summary Create Product route
         * @param {string} productId
         * @param {InlineObject18} [inlineObject18]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductUrls(productId, inlineObject18, options) {
            return exports.ProductsApiFp(configuration).postProductUrls(productId, inlineObject18, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create Product
         * @param {ShippingShippingMethodIdName} name
         * @param {string} url
         * @param {number} stock
         * @param {string} familyId
         * @param {number} price
         * @param {string} sku
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProducts(name, url, stock, familyId, price, sku, include, options) {
            return exports.ProductsApiFp(configuration).postProducts(name, url, stock, familyId, price, sku, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a draft product from an existing product.
         * @summary Create Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdDrafts(productId, options) {
            return exports.ProductsApiFp(configuration).postProductsIdDrafts(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publish a draft from a Product
         * @summary Publish Draft
         * @param {string} productId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsIdPublish(productId, options) {
            return exports.ProductsApiFp(configuration).postProductsIdPublish(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates product associations
         * @summary Update product associations
         * @param {string} productId
         * @param {InlineObject24} [inlineObject24]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAssociations(productId, inlineObject24, options) {
            return exports.ProductsApiFp(configuration).postProductsProductAssociations(productId, inlineObject24, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows you to sync up the attributes which are directly associated to this product.
         * @summary Update Product attributes
         * @param {string} productId
         * @param {InlineObject20} [inlineObject20]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductAttributes(productId, inlineObject20, options) {
            return exports.ProductsApiFp(configuration).postProductsProductAttributes(productId, inlineObject20, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync product categories
         * @summary Update Product categories
         * @param {string} productId
         * @param {InlineObject22} [inlineObject22]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCategories(productId, inlineObject22, options) {
            return exports.ProductsApiFp(configuration).postProductsProductCategories(productId, inlineObject22, options).then((request) => request(axios, basePath));
        },
        /**
         * Sync product Channels
         * @summary Update Product channels
         * @param {string} productId
         * @param {InlineObject23} [inlineObject23]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductChannels(productId, inlineObject23, options) {
            return exports.ProductsApiFp(configuration).postProductsProductChannels(productId, inlineObject23, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a products customer groups
         * @summary Update customer groups
         * @param {string} productId
         * @param {InlineObject25} [inlineObject25]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductCustomerGroups(productId, inlineObject25, options) {
            return exports.ProductsApiFp(configuration).postProductsProductCustomerGroups(productId, inlineObject25, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a products collections.
         * @summary Update Product collections
         * @param {string} productId
         * @param {InlineObject21} [inlineObject21]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdCollections(productId, inlineObject21, options) {
            return exports.ProductsApiFp(configuration).postProductsProductIdCollections(productId, inlineObject21, options).then((request) => request(axios, basePath));
        },
        /**
         * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
         * @summary Duplicate Product
         * @param {string} productId
         * @param {InlineObject17} [inlineObject17]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProductsProductIdDuplicate(productId, inlineObject17, options) {
            return exports.ProductsApiFp(configuration).postProductsProductIdDuplicate(productId, inlineObject17, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a product by it\'s ID
         * @summary Update Product
         * @param {string} productId
         * @param {ProductUpdateBody} [productUpdateBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProductsProductId(productId, productUpdateBody, options) {
            return exports.ProductsApiFp(configuration).putProductsProductId(productId, productUpdateBody, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
class ProductsApi extends base_1.BaseAPI {
    /**
     * Detaches a category from a product. Does not delete the category.
     * @summary Detach category
     * @param {string} productId
     * @param {string} categoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductCategoriesCategory(productId, categoryId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductCategoriesCategory(productId, categoryId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detaches a collection from a product. Does not delete the collection.
     * @summary Detach collection
     * @param {string} productId
     * @param {string} collectionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductCollectionsDetach(productId, collectionId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductCollectionsDetach(productId, collectionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detaches customer groups from a product
     * @summary Detach customer groups
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductCustomerGroups(productId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductCustomerGroups(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a product by it\'s ID  > This will only soft delete the product. It will then be available to restore at a later time.
     * @summary Delete Product
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductId(productId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductId(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes product associations
     * @summary
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    deleteProductsProductIdAssociations(productId, options) {
        return exports.ProductsApiFp(this.configuration).deleteProductsProductIdAssociations(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a paginated list of products.
     * @summary Get Products
     * @param {string} [include]
     * @param {boolean} [paginated]
     * @param {string} [ids] Return only the selected IDs
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProducts(include, paginated, ids, limit, options) {
        return exports.ProductsApiFp(this.configuration).getProducts(include, paginated, ids, limit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a product by it\'s given ID
     * @summary Get Product
     * @param {string} productId
     * @param {string} [include]
     * @param {string} [exclTax] Prices shouldn\&#39;t include tax
     * @param {string} [fullResponse] Returns full &#x60;attribute_data&#x60; in response
     * @param {string} [optionData] Include option data
     * @param {string} [draft] Show draft if exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options) {
        return exports.ProductsApiFp(this.configuration).getProductsProductId(productId, include, exclTax, fullResponse, optionData, draft, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a draft for a product.  If a draft already exists, that current draft will be returned.
     * @summary Create draft
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProductsProductIdDrafts(productId, options) {
        return exports.ProductsApiFp(this.configuration).getProductsProductIdDrafts(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will return recommended products based on a basket.  Using product associations, the API will find products in the basket and display any relations that have been defined.
     * @summary Get recommended products
     * @param {string} basketId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    getProductsRecommended(basketId, options) {
        return exports.ProductsApiFp(this.configuration).getProductsRecommended(basketId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and syncs a new product route.
     * @summary Create Product redirect
     * @param {string} productId
     * @param {InlineObject19} [inlineObject19]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductRedirects(productId, inlineObject19, options) {
        return exports.ProductsApiFp(this.configuration).postProductRedirects(productId, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates and syncs a new product route.
     * @summary Create Product route
     * @param {string} productId
     * @param {InlineObject18} [inlineObject18]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductUrls(productId, inlineObject18, options) {
        return exports.ProductsApiFp(this.configuration).postProductUrls(productId, inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create Product
     * @param {ShippingShippingMethodIdName} name
     * @param {string} url
     * @param {number} stock
     * @param {string} familyId
     * @param {number} price
     * @param {string} sku
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProducts(name, url, stock, familyId, price, sku, include, options) {
        return exports.ProductsApiFp(this.configuration).postProducts(name, url, stock, familyId, price, sku, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a draft product from an existing product.
     * @summary Create Draft
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsIdDrafts(productId, options) {
        return exports.ProductsApiFp(this.configuration).postProductsIdDrafts(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Publish a draft from a Product
     * @summary Publish Draft
     * @param {string} productId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsIdPublish(productId, options) {
        return exports.ProductsApiFp(this.configuration).postProductsIdPublish(productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates product associations
     * @summary Update product associations
     * @param {string} productId
     * @param {InlineObject24} [inlineObject24]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductAssociations(productId, inlineObject24, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductAssociations(productId, inlineObject24, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows you to sync up the attributes which are directly associated to this product.
     * @summary Update Product attributes
     * @param {string} productId
     * @param {InlineObject20} [inlineObject20]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductAttributes(productId, inlineObject20, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductAttributes(productId, inlineObject20, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sync product categories
     * @summary Update Product categories
     * @param {string} productId
     * @param {InlineObject22} [inlineObject22]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductCategories(productId, inlineObject22, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductCategories(productId, inlineObject22, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sync product Channels
     * @summary Update Product channels
     * @param {string} productId
     * @param {InlineObject23} [inlineObject23]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductChannels(productId, inlineObject23, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductChannels(productId, inlineObject23, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a products customer groups
     * @summary Update customer groups
     * @param {string} productId
     * @param {InlineObject25} [inlineObject25]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductCustomerGroups(productId, inlineObject25, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductCustomerGroups(productId, inlineObject25, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a products collections.
     * @summary Update Product collections
     * @param {string} productId
     * @param {InlineObject21} [inlineObject21]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductIdCollections(productId, inlineObject21, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductIdCollections(productId, inlineObject21, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Duplicates a product, requires you to specify new slugs and SKU\'s.  > Duplicated product will not immediately be active.
     * @summary Duplicate Product
     * @param {string} productId
     * @param {InlineObject17} [inlineObject17]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    postProductsProductIdDuplicate(productId, inlineObject17, options) {
        return exports.ProductsApiFp(this.configuration).postProductsProductIdDuplicate(productId, inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a product by it\'s ID
     * @summary Update Product
     * @param {string} productId
     * @param {ProductUpdateBody} [productUpdateBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    putProductsProductId(productId, productUpdateBody, options) {
        return exports.ProductsApiFp(this.configuration).putProductsProductId(productId, productUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ProductsApi = ProductsApi;
/**
 * RecycleBinApi - axios parameter creator
 * @export
 */
exports.RecycleBinApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Remove a recycle bin item  > This will also hard delete the model associated with the recycle bin item, this action is not reversable and will cause loss of data.
         * @summary Delete item
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecycleBinItemId: (itemId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new base_1.RequiredError('itemId', 'Required parameter itemId was null or undefined when calling deleteRecycleBinItemId.');
            }
            const localVarPath = `/recycle-bin/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a paginated list of all recycle bin items.
         * @summary Get records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBin: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/recycle-bin`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieves a recycle bin item.
         * @summary Get item
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBinItemId: (itemId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'itemId' is not null or undefined
            if (itemId === null || itemId === undefined) {
                throw new base_1.RequiredError('itemId', 'Required parameter itemId was null or undefined when calling getRecycleBinItemId.');
            }
            const localVarPath = `/recycle-bin/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * RecycleBinApi - functional programming interface
 * @export
 */
exports.RecycleBinApiFp = function (configuration) {
    return {
        /**
         * Remove a recycle bin item  > This will also hard delete the model associated with the recycle bin item, this action is not reversable and will cause loss of data.
         * @summary Delete item
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecycleBinItemId(itemId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RecycleBinApiAxiosParamCreator(configuration).deleteRecycleBinItemId(itemId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a paginated list of all recycle bin items.
         * @summary Get records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBin(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RecycleBinApiAxiosParamCreator(configuration).getRecycleBin(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Retrieves a recycle bin item.
         * @summary Get item
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBinItemId(itemId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RecycleBinApiAxiosParamCreator(configuration).getRecycleBinItemId(itemId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * RecycleBinApi - factory interface
 * @export
 */
exports.RecycleBinApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Remove a recycle bin item  > This will also hard delete the model associated with the recycle bin item, this action is not reversable and will cause loss of data.
         * @summary Delete item
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecycleBinItemId(itemId, options) {
            return exports.RecycleBinApiFp(configuration).deleteRecycleBinItemId(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all recycle bin items.
         * @summary Get records
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBin(options) {
            return exports.RecycleBinApiFp(configuration).getRecycleBin(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a recycle bin item.
         * @summary Get item
         * @param {string} itemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecycleBinItemId(itemId, options) {
            return exports.RecycleBinApiFp(configuration).getRecycleBinItemId(itemId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RecycleBinApi - object-oriented interface
 * @export
 * @class RecycleBinApi
 * @extends {BaseAPI}
 */
class RecycleBinApi extends base_1.BaseAPI {
    /**
     * Remove a recycle bin item  > This will also hard delete the model associated with the recycle bin item, this action is not reversable and will cause loss of data.
     * @summary Delete item
     * @param {string} itemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecycleBinApi
     */
    deleteRecycleBinItemId(itemId, options) {
        return exports.RecycleBinApiFp(this.configuration).deleteRecycleBinItemId(itemId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a paginated list of all recycle bin items.
     * @summary Get records
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecycleBinApi
     */
    getRecycleBin(options) {
        return exports.RecycleBinApiFp(this.configuration).getRecycleBin(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a recycle bin item.
     * @summary Get item
     * @param {string} itemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecycleBinApi
     */
    getRecycleBinItemId(itemId, options) {
        return exports.RecycleBinApiFp(this.configuration).getRecycleBinItemId(itemId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RecycleBinApi = RecycleBinApi;
/**
 * ReportsApi - axios parameter creator
 * @export
 */
exports.ReportsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets best selling products grouped by month.
         * @summary Get best selling products
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsBestSellers: (from, to, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/reports/products/best-sellers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns metric (KPI) data for either sales or orders.
         * @summary Get metric data
         * @param {'sales' | 'orders'} subject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsMetricsSubject: (subject, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'subject' is not null or undefined
            if (subject === null || subject === undefined) {
                throw new base_1.RequiredError('subject', 'Required parameter subject was null or undefined when calling getReportsMetricsSubject.');
            }
            const localVarPath = `/reports/metrics/{subject}`
                .replace(`{${"subject"}}`, encodeURIComponent(String(subject)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a report for orders between a given date range
         * @summary Get sales report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrders: (from, to, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/reports/orders`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an array of order averages between a given date range.
         * @summary Get order averages
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'daily' | 'yearly' | 'monthly'} [mode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersAverages: (from, to, mode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/reports/orders/averages`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a monthly grouped list of new/returning and total customers.
         * @summary Get Customer Report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersCustomers: (from, to, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/reports/orders/customers`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoints returns sales report figures.  > Currently this provides data suitable for chartjs.org but this is subject to change and be more decoupled in a future release.
         * @summary Get sales report
         * @param {string} from The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'monthly' | 'daily'} [mode] The dataset mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsSales: (from, to, mode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'from' is not null or undefined
            if (from === null || from === undefined) {
                throw new base_1.RequiredError('from', 'Required parameter from was null or undefined when calling getReportsSales.');
            }
            const localVarPath = `/reports/sales`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }
            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ReportsApi - functional programming interface
 * @export
 */
exports.ReportsApiFp = function (configuration) {
    return {
        /**
         * Gets best selling products grouped by month.
         * @summary Get best selling products
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsBestSellers(from, to, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReportsApiAxiosParamCreator(configuration).getProductsBestSellers(from, to, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns metric (KPI) data for either sales or orders.
         * @summary Get metric data
         * @param {'sales' | 'orders'} subject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsMetricsSubject(subject, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReportsApiAxiosParamCreator(configuration).getReportsMetricsSubject(subject, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a report for orders between a given date range
         * @summary Get sales report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrders(from, to, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReportsApiAxiosParamCreator(configuration).getReportsOrders(from, to, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns an array of order averages between a given date range.
         * @summary Get order averages
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'daily' | 'yearly' | 'monthly'} [mode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersAverages(from, to, mode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReportsApiAxiosParamCreator(configuration).getReportsOrdersAverages(from, to, mode, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a monthly grouped list of new/returning and total customers.
         * @summary Get Customer Report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersCustomers(from, to, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReportsApiAxiosParamCreator(configuration).getReportsOrdersCustomers(from, to, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * This endpoints returns sales report figures.  > Currently this provides data suitable for chartjs.org but this is subject to change and be more decoupled in a future release.
         * @summary Get sales report
         * @param {string} from The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'monthly' | 'daily'} [mode] The dataset mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsSales(from, to, mode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ReportsApiAxiosParamCreator(configuration).getReportsSales(from, to, mode, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ReportsApi - factory interface
 * @export
 */
exports.ReportsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Gets best selling products grouped by month.
         * @summary Get best selling products
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsBestSellers(from, to, options) {
            return exports.ReportsApiFp(configuration).getProductsBestSellers(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns metric (KPI) data for either sales or orders.
         * @summary Get metric data
         * @param {'sales' | 'orders'} subject
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsMetricsSubject(subject, options) {
            return exports.ReportsApiFp(configuration).getReportsMetricsSubject(subject, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a report for orders between a given date range
         * @summary Get sales report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrders(from, to, options) {
            return exports.ReportsApiFp(configuration).getReportsOrders(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of order averages between a given date range.
         * @summary Get order averages
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'daily' | 'yearly' | 'monthly'} [mode]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersAverages(from, to, mode, options) {
            return exports.ReportsApiFp(configuration).getReportsOrdersAverages(from, to, mode, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a monthly grouped list of new/returning and total customers.
         * @summary Get Customer Report
         * @param {string} [from] The from date
         * @param {string} [to] The to date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsOrdersCustomers(from, to, options) {
            return exports.ReportsApiFp(configuration).getReportsOrdersCustomers(from, to, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoints returns sales report figures.  > Currently this provides data suitable for chartjs.org but this is subject to change and be more decoupled in a future release.
         * @summary Get sales report
         * @param {string} from The from date
         * @param {string} [to] The to date
         * @param {'weekly' | 'monthly' | 'daily'} [mode] The dataset mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReportsSales(from, to, mode, options) {
            return exports.ReportsApiFp(configuration).getReportsSales(from, to, mode, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
class ReportsApi extends base_1.BaseAPI {
    /**
     * Gets best selling products grouped by month.
     * @summary Get best selling products
     * @param {string} [from] The from date
     * @param {string} [to] The to date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    getProductsBestSellers(from, to, options) {
        return exports.ReportsApiFp(this.configuration).getProductsBestSellers(from, to, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns metric (KPI) data for either sales or orders.
     * @summary Get metric data
     * @param {'sales' | 'orders'} subject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    getReportsMetricsSubject(subject, options) {
        return exports.ReportsApiFp(this.configuration).getReportsMetricsSubject(subject, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a report for orders between a given date range
     * @summary Get sales report
     * @param {string} [from] The from date
     * @param {string} [to] The to date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    getReportsOrders(from, to, options) {
        return exports.ReportsApiFp(this.configuration).getReportsOrders(from, to, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of order averages between a given date range.
     * @summary Get order averages
     * @param {string} [from] The from date
     * @param {string} [to] The to date
     * @param {'weekly' | 'daily' | 'yearly' | 'monthly'} [mode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    getReportsOrdersAverages(from, to, mode, options) {
        return exports.ReportsApiFp(this.configuration).getReportsOrdersAverages(from, to, mode, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a monthly grouped list of new/returning and total customers.
     * @summary Get Customer Report
     * @param {string} [from] The from date
     * @param {string} [to] The to date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    getReportsOrdersCustomers(from, to, options) {
        return exports.ReportsApiFp(this.configuration).getReportsOrdersCustomers(from, to, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoints returns sales report figures.  > Currently this provides data suitable for chartjs.org but this is subject to change and be more decoupled in a future release.
     * @summary Get sales report
     * @param {string} from The from date
     * @param {string} [to] The to date
     * @param {'weekly' | 'monthly' | 'daily'} [mode] The dataset mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    getReportsSales(from, to, mode, options) {
        return exports.ReportsApiFp(this.configuration).getReportsSales(from, to, mode, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ReportsApi = ReportsApi;
/**
 * RootApi - axios parameter creator
 * @export
 */
exports.RootApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns information about the API
         * @summary Get root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * RootApi - functional programming interface
 * @export
 */
exports.RootApiFp = function (configuration) {
    return {
        /**
         * Returns information about the API
         * @summary Get root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RootApiAxiosParamCreator(configuration).get(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * RootApi - factory interface
 * @export
 */
exports.RootApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns information about the API
         * @summary Get root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options) {
            return exports.RootApiFp(configuration).get(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
class RootApi extends base_1.BaseAPI {
    /**
     * Returns information about the API
     * @summary Get root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    get(options) {
        return exports.RootApiFp(this.configuration).get(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RootApi = RootApi;
/**
 * RoutesApi - axios parameter creator
 * @export
 */
exports.RoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a Router by its ID
         * @summary Delete Route
         * @param {string} routeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoutesRouteId: (routeId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new base_1.RequiredError('routeId', 'Required parameter routeId was null or undefined when calling deleteRoutesRouteId.');
            }
            const localVarPath = `/routes/{routeId}`
                .replace(`{${"routeId"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a paginated list of Routes
         * @summary Get Routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/routes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Route by ID
         * @summary Get Route
         * @param {string} routeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesRouteId: (routeId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new base_1.RequiredError('routeId', 'Required parameter routeId was null or undefined when calling getRoutesRouteId.');
            }
            const localVarPath = `/routes/{routeId}`
                .replace(`{${"routeId"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a Route by searching via slug or path
         * @summary Search for Route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesSearch: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/routes/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a Route using it\'s ID
         * @summary Update Route
         * @param {string} routeId
         * @param {Route} [route]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRoutesRouteId: (routeId, route, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'routeId' is not null or undefined
            if (routeId === null || routeId === undefined) {
                throw new base_1.RequiredError('routeId', 'Required parameter routeId was null or undefined when calling putRoutesRouteId.');
            }
            const localVarPath = `/routes/{routeId}`
                .replace(`{${"routeId"}}`, encodeURIComponent(String(routeId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof route !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(route !== undefined ? route : {}) : (route || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * RoutesApi - functional programming interface
 * @export
 */
exports.RoutesApiFp = function (configuration) {
    return {
        /**
         * Delete a Router by its ID
         * @summary Delete Route
         * @param {string} routeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoutesRouteId(routeId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RoutesApiAxiosParamCreator(configuration).deleteRoutesRouteId(routeId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a paginated list of Routes
         * @summary Get Routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RoutesApiAxiosParamCreator(configuration).getRoutes(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Route by ID
         * @summary Get Route
         * @param {string} routeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesRouteId(routeId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RoutesApiAxiosParamCreator(configuration).getRoutesRouteId(routeId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a Route by searching via slug or path
         * @summary Search for Route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesSearch(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RoutesApiAxiosParamCreator(configuration).getRoutesSearch(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a Route using it\'s ID
         * @summary Update Route
         * @param {string} routeId
         * @param {Route} [route]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRoutesRouteId(routeId, route, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.RoutesApiAxiosParamCreator(configuration).putRoutesRouteId(routeId, route, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * RoutesApi - factory interface
 * @export
 */
exports.RoutesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete a Router by its ID
         * @summary Delete Route
         * @param {string} routeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoutesRouteId(routeId, options) {
            return exports.RoutesApiFp(configuration).deleteRoutesRouteId(routeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of Routes
         * @summary Get Routes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutes(options) {
            return exports.RoutesApiFp(configuration).getRoutes(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Route by ID
         * @summary Get Route
         * @param {string} routeId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesRouteId(routeId, options) {
            return exports.RoutesApiFp(configuration).getRoutesRouteId(routeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Route by searching via slug or path
         * @summary Search for Route
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesSearch(options) {
            return exports.RoutesApiFp(configuration).getRoutesSearch(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Route using it\'s ID
         * @summary Update Route
         * @param {string} routeId
         * @param {Route} [route]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putRoutesRouteId(routeId, route, options) {
            return exports.RoutesApiFp(configuration).putRoutesRouteId(routeId, route, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
class RoutesApi extends base_1.BaseAPI {
    /**
     * Delete a Router by its ID
     * @summary Delete Route
     * @param {string} routeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    deleteRoutesRouteId(routeId, options) {
        return exports.RoutesApiFp(this.configuration).deleteRoutesRouteId(routeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a paginated list of Routes
     * @summary Get Routes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    getRoutes(options) {
        return exports.RoutesApiFp(this.configuration).getRoutes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Route by ID
     * @summary Get Route
     * @param {string} routeId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    getRoutesRouteId(routeId, options) {
        return exports.RoutesApiFp(this.configuration).getRoutesRouteId(routeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a Route by searching via slug or path
     * @summary Search for Route
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    getRoutesSearch(options) {
        return exports.RoutesApiFp(this.configuration).getRoutesSearch(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a Route using it\'s ID
     * @summary Update Route
     * @param {string} routeId
     * @param {Route} [route]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    putRoutesRouteId(routeId, route, options) {
        return exports.RoutesApiFp(this.configuration).putRoutesRouteId(routeId, route, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.RoutesApi = RoutesApi;
/**
 * SearchApi - axios parameter creator
 * @export
 */
exports.SearchApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a saved search entry by ID.
         * @summary Delete saved search
         * @param {string} savedSearchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchesSavedSearchId: (savedSearchId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'savedSearchId' is not null or undefined
            if (savedSearchId === null || savedSearchId === undefined) {
                throw new base_1.RequiredError('savedSearchId', 'Required parameter savedSearchId was null or undefined when calling deleteSavedSearchesSavedSearchId.');
            }
            const localVarPath = `/saved-searches/{savedSearchId}`
                .replace(`{${"savedSearchId"}}`, encodeURIComponent(String(savedSearchId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of current saved searches for products
         * @summary Get saved searches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearches: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/saved-searches/product`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search across products or categories  You can filter across attributes by adding key=value to the search query, for filtering multiple values use key=value1:value2
         * @summary Search GetCandy
         * @param {string} [channel]
         * @param {string} [category]
         * @param {number} [page]
         * @param {'categories' | 'products'} [searchType]
         * @param {string} [term]
         * @param {boolean} [rank] Whether to rank results based on config
         * @param {boolean} [idsOnly] Will only return result ID\&#39;s, good for performance
         * @param {string} [include]
         * @param {string} [sort]
         * @param {boolean} [fullResponse]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch: (channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/search`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (channel !== undefined) {
                localVarQueryParameter['channel'] = channel;
            }
            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (searchType !== undefined) {
                localVarQueryParameter['search_type'] = searchType;
            }
            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }
            if (rank !== undefined) {
                localVarQueryParameter['rank'] = rank;
            }
            if (idsOnly !== undefined) {
                localVarQueryParameter['ids_only'] = idsOnly;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (fullResponse !== undefined) {
                localVarQueryParameter['full_response'] = fullResponse;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get saved search
         * @param {string} savedSearchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchesSavedSearchIdGet: (savedSearchId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'savedSearchId' is not null or undefined
            if (savedSearchId === null || savedSearchId === undefined) {
                throw new base_1.RequiredError('savedSearchId', 'Required parameter savedSearchId was null or undefined when calling savedSearchesSavedSearchIdGet.');
            }
            const localVarPath = `/saved-searches/{savedSearchId}`
                .replace(`{${"savedSearchId"}}`, encodeURIComponent(String(savedSearchId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SearchApi - functional programming interface
 * @export
 */
exports.SearchApiFp = function (configuration) {
    return {
        /**
         * Delete a saved search entry by ID.
         * @summary Delete saved search
         * @param {string} savedSearchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchesSavedSearchId(savedSearchId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SearchApiAxiosParamCreator(configuration).deleteSavedSearchesSavedSearchId(savedSearchId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a list of current saved searches for products
         * @summary Get saved searches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearches(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SearchApiAxiosParamCreator(configuration).getSavedSearches(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Search across products or categories  You can filter across attributes by adding key=value to the search query, for filtering multiple values use key=value1:value2
         * @summary Search GetCandy
         * @param {string} [channel]
         * @param {string} [category]
         * @param {number} [page]
         * @param {'categories' | 'products'} [searchType]
         * @param {string} [term]
         * @param {boolean} [rank] Whether to rank results based on config
         * @param {boolean} [idsOnly] Will only return result ID\&#39;s, good for performance
         * @param {string} [include]
         * @param {string} [sort]
         * @param {boolean} [fullResponse]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SearchApiAxiosParamCreator(configuration).getSearch(channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         *
         * @summary Get saved search
         * @param {string} savedSearchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchesSavedSearchIdGet(savedSearchId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SearchApiAxiosParamCreator(configuration).savedSearchesSavedSearchIdGet(savedSearchId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * SearchApi - factory interface
 * @export
 */
exports.SearchApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete a saved search entry by ID.
         * @summary Delete saved search
         * @param {string} savedSearchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearchesSavedSearchId(savedSearchId, options) {
            return exports.SearchApiFp(configuration).deleteSavedSearchesSavedSearchId(savedSearchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of current saved searches for products
         * @summary Get saved searches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSavedSearches(options) {
            return exports.SearchApiFp(configuration).getSavedSearches(options).then((request) => request(axios, basePath));
        },
        /**
         * Search across products or categories  You can filter across attributes by adding key=value to the search query, for filtering multiple values use key=value1:value2
         * @summary Search GetCandy
         * @param {string} [channel]
         * @param {string} [category]
         * @param {number} [page]
         * @param {'categories' | 'products'} [searchType]
         * @param {string} [term]
         * @param {boolean} [rank] Whether to rank results based on config
         * @param {boolean} [idsOnly] Will only return result ID\&#39;s, good for performance
         * @param {string} [include]
         * @param {string} [sort]
         * @param {boolean} [fullResponse]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSearch(channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options) {
            return exports.SearchApiFp(configuration).getSearch(channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get saved search
         * @param {string} savedSearchId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        savedSearchesSavedSearchIdGet(savedSearchId, options) {
            return exports.SearchApiFp(configuration).savedSearchesSavedSearchIdGet(savedSearchId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
class SearchApi extends base_1.BaseAPI {
    /**
     * Delete a saved search entry by ID.
     * @summary Delete saved search
     * @param {string} savedSearchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    deleteSavedSearchesSavedSearchId(savedSearchId, options) {
        return exports.SearchApiFp(this.configuration).deleteSavedSearchesSavedSearchId(savedSearchId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of current saved searches for products
     * @summary Get saved searches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    getSavedSearches(options) {
        return exports.SearchApiFp(this.configuration).getSavedSearches(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search across products or categories  You can filter across attributes by adding key=value to the search query, for filtering multiple values use key=value1:value2
     * @summary Search GetCandy
     * @param {string} [channel]
     * @param {string} [category]
     * @param {number} [page]
     * @param {'categories' | 'products'} [searchType]
     * @param {string} [term]
     * @param {boolean} [rank] Whether to rank results based on config
     * @param {boolean} [idsOnly] Will only return result ID\&#39;s, good for performance
     * @param {string} [include]
     * @param {string} [sort]
     * @param {boolean} [fullResponse]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    getSearch(channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options) {
        return exports.SearchApiFp(this.configuration).getSearch(channel, category, page, searchType, term, rank, idsOnly, include, sort, fullResponse, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get saved search
     * @param {string} savedSearchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    savedSearchesSavedSearchIdGet(savedSearchId, options) {
        return exports.SearchApiFp(this.configuration).savedSearchesSavedSearchIdGet(savedSearchId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SearchApi = SearchApi;
/**
 * SettingsApi - axios parameter creator
 * @export
 */
exports.SettingsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves settings that have been defined in the database.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get specific settings.
         * @summary Get setting
         * @param {string} handle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsHandle: (handle, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'handle' is not null or undefined
            if (handle === null || handle === undefined) {
                throw new base_1.RequiredError('handle', 'Required parameter handle was null or undefined when calling getSettingsHandle.');
            }
            const localVarPath = `/settings/{handle}`
                .replace(`{${"handle"}}`, encodeURIComponent(String(handle)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * SettingsApi - functional programming interface
 * @export
 */
exports.SettingsApiFp = function (configuration) {
    return {
        /**
         * Retrieves settings that have been defined in the database.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SettingsApiAxiosParamCreator(configuration).getSettings(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get specific settings.
         * @summary Get setting
         * @param {string} handle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsHandle(handle, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.SettingsApiAxiosParamCreator(configuration).getSettingsHandle(handle, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * SettingsApi - factory interface
 * @export
 */
exports.SettingsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Retrieves settings that have been defined in the database.
         * @summary Get settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettings(options) {
            return exports.SettingsApiFp(configuration).getSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Get specific settings.
         * @summary Get setting
         * @param {string} handle
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingsHandle(handle, options) {
            return exports.SettingsApiFp(configuration).getSettingsHandle(handle, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
class SettingsApi extends base_1.BaseAPI {
    /**
     * Retrieves settings that have been defined in the database.
     * @summary Get settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    getSettings(options) {
        return exports.SettingsApiFp(this.configuration).getSettings(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get specific settings.
     * @summary Get setting
     * @param {string} handle
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    getSettingsHandle(handle, options) {
        return exports.SettingsApiFp(this.configuration).getSettingsHandle(handle, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SettingsApi = SettingsApi;
/**
 * ShippingApi - axios parameter creator
 * @export
 */
exports.ShippingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes a shipping method.
         * @summary Delete shipping method
         * @param {string} shippingMethodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingShippingMethodId: (shippingMethodId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new base_1.RequiredError('shippingMethodId', 'Required parameter shippingMethodId was null or undefined when calling deleteShippingShippingMethodId.');
            }
            const localVarPath = `/shipping/{shippingMethodId}`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a paginated list of shipping methods
         * @summary Get shipping methods
         * @param {number} [perPage]
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipping: (perPage, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/shipping`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a shipping method by it\'s ID.
         * @summary Get shipping methods
         * @param {string} shippingMethodId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingShippingMethodId: (shippingMethodId, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new base_1.RequiredError('shippingMethodId', 'Required parameter shippingMethodId was null or undefined when calling getShippingShippingMethodId.');
            }
            const localVarPath = `/shipping/{shippingMethodId}`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a paginated list of shipping zones.
         * @summary Get Shipping Zones
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZones: (include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/shipping/zones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a shipping zone by it\'s ID.
         * @summary Get Shipping Zone
         * @param {string} shippingZoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZonesShippingZoneId: (shippingZoneId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shippingZoneId' is not null or undefined
            if (shippingZoneId === null || shippingZoneId === undefined) {
                throw new base_1.RequiredError('shippingZoneId', 'Required parameter shippingZoneId was null or undefined when calling getShippingZonesShippingZoneId.');
            }
            const localVarPath = `/shipping/zones/{shippingZoneId}`
                .replace(`{${"shippingZoneId"}}`, encodeURIComponent(String(shippingZoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new shipping method.
         * @summary Create shipping method
         * @param {InlineObject26} [inlineObject26]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShipping: (inlineObject26, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/shipping`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject26 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject26 !== undefined ? inlineObject26 : {}) : (inlineObject26 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Add a price to a shipping method.
         * @summary Add shipping price
         * @param {string} shippingMethodId
         * @param {InlineObject29} [inlineObject29]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingIdPrices: (shippingMethodId, inlineObject29, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new base_1.RequiredError('shippingMethodId', 'Required parameter shippingMethodId was null or undefined when calling postShippingIdPrices.');
            }
            const localVarPath = `/shipping/{shippingMethodId}/prices`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject29 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject29 !== undefined ? inlineObject29 : {}) : (inlineObject29 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new shipping zone
         * @summary Create Shipping Zone
         * @param {InlineObject28} [inlineObject28]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingZones: (inlineObject28, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/shipping/zones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject28 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject28 !== undefined ? inlineObject28 : {}) : (inlineObject28 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update shipping method users
         * @summary Update shipping method users
         * @param {string} id
         * @param {InlineObject32} [inlineObject32]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingIdUsers: (id, inlineObject32, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new base_1.RequiredError('id', 'Required parameter id was null or undefined when calling putShippingIdUsers.');
            }
            const localVarPath = `/shipping/{id}/users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject32 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject32 !== undefined ? inlineObject32 : {}) : (inlineObject32 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a shipping price
         * @summary Update shipping price
         * @param {string} shippingPriceId
         * @param {InlineObject30} [inlineObject30]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingPricesShippingPriceId: (shippingPriceId, inlineObject30, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shippingPriceId' is not null or undefined
            if (shippingPriceId === null || shippingPriceId === undefined) {
                throw new base_1.RequiredError('shippingPriceId', 'Required parameter shippingPriceId was null or undefined when calling putShippingPricesShippingPriceId.');
            }
            const localVarPath = `/shipping/prices/{shippingPriceId}`
                .replace(`{${"shippingPriceId"}}`, encodeURIComponent(String(shippingPriceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject30 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject30 !== undefined ? inlineObject30 : {}) : (inlineObject30 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update shipping method by it\'s ID
         * @summary Update shipping method
         * @param {string} shippingMethodId
         * @param {InlineObject27} [inlineObject27]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodId: (shippingMethodId, inlineObject27, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new base_1.RequiredError('shippingMethodId', 'Required parameter shippingMethodId was null or undefined when calling putShippingShippingMethodId.');
            }
            const localVarPath = `/shipping/{shippingMethodId}`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject27 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject27 !== undefined ? inlineObject27 : {}) : (inlineObject27 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a shipping method\'s zones.
         * @summary Update shipping method zones
         * @param {string} shippingMethodId
         * @param {InlineObject31} [inlineObject31]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodIdZones: (shippingMethodId, inlineObject31, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'shippingMethodId' is not null or undefined
            if (shippingMethodId === null || shippingMethodId === undefined) {
                throw new base_1.RequiredError('shippingMethodId', 'Required parameter shippingMethodId was null or undefined when calling putShippingShippingMethodIdZones.');
            }
            const localVarPath = `/shipping/{shippingMethodId}/zones`
                .replace(`{${"shippingMethodId"}}`, encodeURIComponent(String(shippingMethodId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject31 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject31 !== undefined ? inlineObject31 : {}) : (inlineObject31 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ShippingApi - functional programming interface
 * @export
 */
exports.ShippingApiFp = function (configuration) {
    return {
        /**
         * Deletes a shipping method.
         * @summary Delete shipping method
         * @param {string} shippingMethodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingShippingMethodId(shippingMethodId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).deleteShippingShippingMethodId(shippingMethodId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a paginated list of shipping methods
         * @summary Get shipping methods
         * @param {number} [perPage]
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipping(perPage, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).getShipping(perPage, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a shipping method by it\'s ID.
         * @summary Get shipping methods
         * @param {string} shippingMethodId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingShippingMethodId(shippingMethodId, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).getShippingShippingMethodId(shippingMethodId, include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns a paginated list of shipping zones.
         * @summary Get Shipping Zones
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZones(include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).getShippingZones(include, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a shipping zone by it\'s ID.
         * @summary Get Shipping Zone
         * @param {string} shippingZoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZonesShippingZoneId(shippingZoneId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).getShippingZonesShippingZoneId(shippingZoneId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new shipping method.
         * @summary Create shipping method
         * @param {InlineObject26} [inlineObject26]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShipping(inlineObject26, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).postShipping(inlineObject26, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Add a price to a shipping method.
         * @summary Add shipping price
         * @param {string} shippingMethodId
         * @param {InlineObject29} [inlineObject29]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingIdPrices(shippingMethodId, inlineObject29, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).postShippingIdPrices(shippingMethodId, inlineObject29, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new shipping zone
         * @summary Create Shipping Zone
         * @param {InlineObject28} [inlineObject28]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingZones(inlineObject28, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).postShippingZones(inlineObject28, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update shipping method users
         * @summary Update shipping method users
         * @param {string} id
         * @param {InlineObject32} [inlineObject32]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingIdUsers(id, inlineObject32, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).putShippingIdUsers(id, inlineObject32, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a shipping price
         * @summary Update shipping price
         * @param {string} shippingPriceId
         * @param {InlineObject30} [inlineObject30]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingPricesShippingPriceId(shippingPriceId, inlineObject30, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).putShippingPricesShippingPriceId(shippingPriceId, inlineObject30, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update shipping method by it\'s ID
         * @summary Update shipping method
         * @param {string} shippingMethodId
         * @param {InlineObject27} [inlineObject27]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodId(shippingMethodId, inlineObject27, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).putShippingShippingMethodId(shippingMethodId, inlineObject27, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a shipping method\'s zones.
         * @summary Update shipping method zones
         * @param {string} shippingMethodId
         * @param {InlineObject31} [inlineObject31]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodIdZones(shippingMethodId, inlineObject31, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.ShippingApiAxiosParamCreator(configuration).putShippingShippingMethodIdZones(shippingMethodId, inlineObject31, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * ShippingApi - factory interface
 * @export
 */
exports.ShippingApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Deletes a shipping method.
         * @summary Delete shipping method
         * @param {string} shippingMethodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingShippingMethodId(shippingMethodId, options) {
            return exports.ShippingApiFp(configuration).deleteShippingShippingMethodId(shippingMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of shipping methods
         * @summary Get shipping methods
         * @param {number} [perPage]
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShipping(perPage, include, options) {
            return exports.ShippingApiFp(configuration).getShipping(perPage, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a shipping method by it\'s ID.
         * @summary Get shipping methods
         * @param {string} shippingMethodId
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingShippingMethodId(shippingMethodId, include, options) {
            return exports.ShippingApiFp(configuration).getShippingShippingMethodId(shippingMethodId, include, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of shipping zones.
         * @summary Get Shipping Zones
         * @param {string} [include]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZones(include, options) {
            return exports.ShippingApiFp(configuration).getShippingZones(include, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a shipping zone by it\'s ID.
         * @summary Get Shipping Zone
         * @param {string} shippingZoneId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingZonesShippingZoneId(shippingZoneId, options) {
            return exports.ShippingApiFp(configuration).getShippingZonesShippingZoneId(shippingZoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shipping method.
         * @summary Create shipping method
         * @param {InlineObject26} [inlineObject26]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShipping(inlineObject26, options) {
            return exports.ShippingApiFp(configuration).postShipping(inlineObject26, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a price to a shipping method.
         * @summary Add shipping price
         * @param {string} shippingMethodId
         * @param {InlineObject29} [inlineObject29]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingIdPrices(shippingMethodId, inlineObject29, options) {
            return exports.ShippingApiFp(configuration).postShippingIdPrices(shippingMethodId, inlineObject29, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new shipping zone
         * @summary Create Shipping Zone
         * @param {InlineObject28} [inlineObject28]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShippingZones(inlineObject28, options) {
            return exports.ShippingApiFp(configuration).postShippingZones(inlineObject28, options).then((request) => request(axios, basePath));
        },
        /**
         * Update shipping method users
         * @summary Update shipping method users
         * @param {string} id
         * @param {InlineObject32} [inlineObject32]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingIdUsers(id, inlineObject32, options) {
            return exports.ShippingApiFp(configuration).putShippingIdUsers(id, inlineObject32, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a shipping price
         * @summary Update shipping price
         * @param {string} shippingPriceId
         * @param {InlineObject30} [inlineObject30]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingPricesShippingPriceId(shippingPriceId, inlineObject30, options) {
            return exports.ShippingApiFp(configuration).putShippingPricesShippingPriceId(shippingPriceId, inlineObject30, options).then((request) => request(axios, basePath));
        },
        /**
         * Update shipping method by it\'s ID
         * @summary Update shipping method
         * @param {string} shippingMethodId
         * @param {InlineObject27} [inlineObject27]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodId(shippingMethodId, inlineObject27, options) {
            return exports.ShippingApiFp(configuration).putShippingShippingMethodId(shippingMethodId, inlineObject27, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a shipping method\'s zones.
         * @summary Update shipping method zones
         * @param {string} shippingMethodId
         * @param {InlineObject31} [inlineObject31]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putShippingShippingMethodIdZones(shippingMethodId, inlineObject31, options) {
            return exports.ShippingApiFp(configuration).putShippingShippingMethodIdZones(shippingMethodId, inlineObject31, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ShippingApi - object-oriented interface
 * @export
 * @class ShippingApi
 * @extends {BaseAPI}
 */
class ShippingApi extends base_1.BaseAPI {
    /**
     * Deletes a shipping method.
     * @summary Delete shipping method
     * @param {string} shippingMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    deleteShippingShippingMethodId(shippingMethodId, options) {
        return exports.ShippingApiFp(this.configuration).deleteShippingShippingMethodId(shippingMethodId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a paginated list of shipping methods
     * @summary Get shipping methods
     * @param {number} [perPage]
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    getShipping(perPage, include, options) {
        return exports.ShippingApiFp(this.configuration).getShipping(perPage, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a shipping method by it\'s ID.
     * @summary Get shipping methods
     * @param {string} shippingMethodId
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    getShippingShippingMethodId(shippingMethodId, include, options) {
        return exports.ShippingApiFp(this.configuration).getShippingShippingMethodId(shippingMethodId, include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a paginated list of shipping zones.
     * @summary Get Shipping Zones
     * @param {string} [include]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    getShippingZones(include, options) {
        return exports.ShippingApiFp(this.configuration).getShippingZones(include, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a shipping zone by it\'s ID.
     * @summary Get Shipping Zone
     * @param {string} shippingZoneId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    getShippingZonesShippingZoneId(shippingZoneId, options) {
        return exports.ShippingApiFp(this.configuration).getShippingZonesShippingZoneId(shippingZoneId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new shipping method.
     * @summary Create shipping method
     * @param {InlineObject26} [inlineObject26]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    postShipping(inlineObject26, options) {
        return exports.ShippingApiFp(this.configuration).postShipping(inlineObject26, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Add a price to a shipping method.
     * @summary Add shipping price
     * @param {string} shippingMethodId
     * @param {InlineObject29} [inlineObject29]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    postShippingIdPrices(shippingMethodId, inlineObject29, options) {
        return exports.ShippingApiFp(this.configuration).postShippingIdPrices(shippingMethodId, inlineObject29, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new shipping zone
     * @summary Create Shipping Zone
     * @param {InlineObject28} [inlineObject28]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    postShippingZones(inlineObject28, options) {
        return exports.ShippingApiFp(this.configuration).postShippingZones(inlineObject28, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update shipping method users
     * @summary Update shipping method users
     * @param {string} id
     * @param {InlineObject32} [inlineObject32]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    putShippingIdUsers(id, inlineObject32, options) {
        return exports.ShippingApiFp(this.configuration).putShippingIdUsers(id, inlineObject32, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a shipping price
     * @summary Update shipping price
     * @param {string} shippingPriceId
     * @param {InlineObject30} [inlineObject30]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    putShippingPricesShippingPriceId(shippingPriceId, inlineObject30, options) {
        return exports.ShippingApiFp(this.configuration).putShippingPricesShippingPriceId(shippingPriceId, inlineObject30, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update shipping method by it\'s ID
     * @summary Update shipping method
     * @param {string} shippingMethodId
     * @param {InlineObject27} [inlineObject27]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    putShippingShippingMethodId(shippingMethodId, inlineObject27, options) {
        return exports.ShippingApiFp(this.configuration).putShippingShippingMethodId(shippingMethodId, inlineObject27, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a shipping method\'s zones.
     * @summary Update shipping method zones
     * @param {string} shippingMethodId
     * @param {InlineObject31} [inlineObject31]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShippingApi
     */
    putShippingShippingMethodIdZones(shippingMethodId, inlineObject31, options) {
        return exports.ShippingApiFp(this.configuration).putShippingShippingMethodIdZones(shippingMethodId, inlineObject31, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ShippingApi = ShippingApi;
/**
 * TagsApi - axios parameter creator
 * @export
 */
exports.TagsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes a tag by it\'s ID
         * @summary Delete a tag
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsTagId: (tagId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling deleteTagsTagId.');
            }
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get paginated list of tags
         * @summary Get all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a tag by it\'s ID
         * @summary Get a tag
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsTagId: (tagId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling getTagsTagId.');
            }
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new tag
         * @summary
         * @param {InlineObject33} [inlineObject33]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTags: (inlineObject33, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tags`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject33 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject33 !== undefined ? inlineObject33 : {}) : (inlineObject33 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates a tag by it\'s ID
         * @summary Update a tag
         * @param {string} tagId
         * @param {InlineObject34} [inlineObject34]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTagsTagId: (tagId, inlineObject34, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new base_1.RequiredError('tagId', 'Required parameter tagId was null or undefined when calling putTagsTagId.');
            }
            const localVarPath = `/tags/{tagId}`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject34 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject34 !== undefined ? inlineObject34 : {}) : (inlineObject34 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TagsApi - functional programming interface
 * @export
 */
exports.TagsApiFp = function (configuration) {
    return {
        /**
         * Deletes a tag by it\'s ID
         * @summary Delete a tag
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsTagId(tagId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).deleteTagsTagId(tagId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get paginated list of tags
         * @summary Get all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).getTags(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Gets a tag by it\'s ID
         * @summary Get a tag
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsTagId(tagId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).getTagsTagId(tagId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new tag
         * @summary
         * @param {InlineObject33} [inlineObject33]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTags(inlineObject33, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).postTags(inlineObject33, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates a tag by it\'s ID
         * @summary Update a tag
         * @param {string} tagId
         * @param {InlineObject34} [inlineObject34]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTagsTagId(tagId, inlineObject34, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TagsApiAxiosParamCreator(configuration).putTagsTagId(tagId, inlineObject34, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TagsApi - factory interface
 * @export
 */
exports.TagsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Deletes a tag by it\'s ID
         * @summary Delete a tag
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagsTagId(tagId, options) {
            return exports.TagsApiFp(configuration).deleteTagsTagId(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get paginated list of tags
         * @summary Get all tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(options) {
            return exports.TagsApiFp(configuration).getTags(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a tag by it\'s ID
         * @summary Get a tag
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagsTagId(tagId, options) {
            return exports.TagsApiFp(configuration).getTagsTagId(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tag
         * @summary
         * @param {InlineObject33} [inlineObject33]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTags(inlineObject33, options) {
            return exports.TagsApiFp(configuration).postTags(inlineObject33, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a tag by it\'s ID
         * @summary Update a tag
         * @param {string} tagId
         * @param {InlineObject34} [inlineObject34]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTagsTagId(tagId, inlineObject34, options) {
            return exports.TagsApiFp(configuration).putTagsTagId(tagId, inlineObject34, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
class TagsApi extends base_1.BaseAPI {
    /**
     * Deletes a tag by it\'s ID
     * @summary Delete a tag
     * @param {string} tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    deleteTagsTagId(tagId, options) {
        return exports.TagsApiFp(this.configuration).deleteTagsTagId(tagId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get paginated list of tags
     * @summary Get all tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    getTags(options) {
        return exports.TagsApiFp(this.configuration).getTags(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a tag by it\'s ID
     * @summary Get a tag
     * @param {string} tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    getTagsTagId(tagId, options) {
        return exports.TagsApiFp(this.configuration).getTagsTagId(tagId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new tag
     * @summary
     * @param {InlineObject33} [inlineObject33]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    postTags(inlineObject33, options) {
        return exports.TagsApiFp(this.configuration).postTags(inlineObject33, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a tag by it\'s ID
     * @summary Update a tag
     * @param {string} tagId
     * @param {InlineObject34} [inlineObject34]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    putTagsTagId(tagId, inlineObject34, options) {
        return exports.TagsApiFp(this.configuration).putTagsTagId(tagId, inlineObject34, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TagsApi = TagsApi;
/**
 * TaxesApi - axios parameter creator
 * @export
 */
exports.TaxesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a tax record by it\'s ID.
         * @summary Delete tax record
         * @param {string} taxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxesTaxId: (taxId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'taxId' is not null or undefined
            if (taxId === null || taxId === undefined) {
                throw new base_1.RequiredError('taxId', 'Required parameter taxId was null or undefined when calling deleteTaxesTaxId.');
            }
            const localVarPath = `/taxes/{taxId}`
                .replace(`{${"taxId"}}`, encodeURIComponent(String(taxId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a paginated list of taxes
         * @summary Get taxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/taxes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a tax record by it\'s ID
         * @summary Get tax record
         * @param {string} taxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxesTaxId: (taxId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'taxId' is not null or undefined
            if (taxId === null || taxId === undefined) {
                throw new base_1.RequiredError('taxId', 'Required parameter taxId was null or undefined when calling getTaxesTaxId.');
            }
            const localVarPath = `/taxes/{taxId}`
                .replace(`{${"taxId"}}`, encodeURIComponent(String(taxId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new tax resource.
         * @summary Create tax
         * @param {InlineObject35} [inlineObject35]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxes: (inlineObject35, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/taxes`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject35 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject35 !== undefined ? inlineObject35 : {}) : (inlineObject35 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update a tax record by it\'s ID
         * @summary Update tax record
         * @param {string} taxId
         * @param {InlineObject36} [inlineObject36]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaxesTaxId: (taxId, inlineObject36, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'taxId' is not null or undefined
            if (taxId === null || taxId === undefined) {
                throw new base_1.RequiredError('taxId', 'Required parameter taxId was null or undefined when calling putTaxesTaxId.');
            }
            const localVarPath = `/taxes/{taxId}`
                .replace(`{${"taxId"}}`, encodeURIComponent(String(taxId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject36 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject36 !== undefined ? inlineObject36 : {}) : (inlineObject36 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * TaxesApi - functional programming interface
 * @export
 */
exports.TaxesApiFp = function (configuration) {
    return {
        /**
         * Delete a tax record by it\'s ID.
         * @summary Delete tax record
         * @param {string} taxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxesTaxId(taxId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TaxesApiAxiosParamCreator(configuration).deleteTaxesTaxId(taxId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a paginated list of taxes
         * @summary Get taxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TaxesApiAxiosParamCreator(configuration).getTaxes(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a tax record by it\'s ID
         * @summary Get tax record
         * @param {string} taxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxesTaxId(taxId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TaxesApiAxiosParamCreator(configuration).getTaxesTaxId(taxId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new tax resource.
         * @summary Create tax
         * @param {InlineObject35} [inlineObject35]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxes(inlineObject35, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TaxesApiAxiosParamCreator(configuration).postTaxes(inlineObject35, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Update a tax record by it\'s ID
         * @summary Update tax record
         * @param {string} taxId
         * @param {InlineObject36} [inlineObject36]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaxesTaxId(taxId, inlineObject36, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.TaxesApiAxiosParamCreator(configuration).putTaxesTaxId(taxId, inlineObject36, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * TaxesApi - factory interface
 * @export
 */
exports.TaxesApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete a tax record by it\'s ID.
         * @summary Delete tax record
         * @param {string} taxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxesTaxId(taxId, options) {
            return exports.TaxesApiFp(configuration).deleteTaxesTaxId(taxId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a paginated list of taxes
         * @summary Get taxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxes(options) {
            return exports.TaxesApiFp(configuration).getTaxes(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a tax record by it\'s ID
         * @summary Get tax record
         * @param {string} taxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxesTaxId(taxId, options) {
            return exports.TaxesApiFp(configuration).getTaxesTaxId(taxId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tax resource.
         * @summary Create tax
         * @param {InlineObject35} [inlineObject35]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTaxes(inlineObject35, options) {
            return exports.TaxesApiFp(configuration).postTaxes(inlineObject35, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tax record by it\'s ID
         * @summary Update tax record
         * @param {string} taxId
         * @param {InlineObject36} [inlineObject36]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaxesTaxId(taxId, inlineObject36, options) {
            return exports.TaxesApiFp(configuration).putTaxesTaxId(taxId, inlineObject36, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TaxesApi - object-oriented interface
 * @export
 * @class TaxesApi
 * @extends {BaseAPI}
 */
class TaxesApi extends base_1.BaseAPI {
    /**
     * Delete a tax record by it\'s ID.
     * @summary Delete tax record
     * @param {string} taxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    deleteTaxesTaxId(taxId, options) {
        return exports.TaxesApiFp(this.configuration).deleteTaxesTaxId(taxId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a paginated list of taxes
     * @summary Get taxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    getTaxes(options) {
        return exports.TaxesApiFp(this.configuration).getTaxes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a tax record by it\'s ID
     * @summary Get tax record
     * @param {string} taxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    getTaxesTaxId(taxId, options) {
        return exports.TaxesApiFp(this.configuration).getTaxesTaxId(taxId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new tax resource.
     * @summary Create tax
     * @param {InlineObject35} [inlineObject35]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    postTaxes(inlineObject35, options) {
        return exports.TaxesApiFp(this.configuration).postTaxes(inlineObject35, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a tax record by it\'s ID
     * @summary Update tax record
     * @param {string} taxId
     * @param {InlineObject36} [inlineObject36]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxesApi
     */
    putTaxesTaxId(taxId, inlineObject36, options) {
        return exports.TaxesApiFp(this.configuration).putTaxesTaxId(taxId, inlineObject36, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TaxesApi = TaxesApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
exports.UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Delete a user by their given ID.
         * @summary
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserId: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling deleteUsersUserId.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Gets a paginated list of all users
         * @summary Get all users
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: (include, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (include !== undefined) {
                localVarQueryParameter['include'] = include;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the user associated to the access token.
         * @summary Get the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCurrent: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/users/current`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a user by their given ID.
         * @summary Get user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserId: (userId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling getUsersUserId.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new user resource
         * @summary Create a new user
         * @param {CreateUserBody} [createUserBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers: (createUserBody, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/users`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof createUserBody !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(createUserBody !== undefined ? createUserBody : {}) : (createUserBody || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates a user record from their ID.
         * @summary
         * @param {string} userId
         * @param {InlineObject37} [inlineObject37]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserId: (userId, inlineObject37, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new base_1.RequiredError('userId', 'Required parameter userId was null or undefined when calling putUsersUserId.');
            }
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            const needsSerialization = (typeof inlineObject37 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data = needsSerialization ? JSON.stringify(inlineObject37 !== undefined ? inlineObject37 : {}) : (inlineObject37 || "");
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UsersApi - functional programming interface
 * @export
 */
exports.UsersApiFp = function (configuration) {
    return {
        /**
         * Delete a user by their given ID.
         * @summary
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserId(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).deleteUsersUserId(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Gets a paginated list of all users
         * @summary Get all users
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(include, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).getUsers(include, perPage, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Returns the user associated to the access token.
         * @summary Get the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCurrent(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).getUsersCurrent(options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Get a user by their given ID.
         * @summary Get user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserId(userId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).getUsersUserId(userId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Create a new user resource
         * @summary Create a new user
         * @param {CreateUserBody} [createUserBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(createUserBody, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).postUsers(createUserBody, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
        /**
         * Updates a user record from their ID.
         * @summary
         * @param {string} userId
         * @param {InlineObject37} [inlineObject37]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserId(userId, inlineObject37, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.UsersApiAxiosParamCreator(configuration).putUsersUserId(userId, inlineObject37, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * UsersApi - factory interface
 * @export
 */
exports.UsersApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Delete a user by their given ID.
         * @summary
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserId(userId, options) {
            return exports.UsersApiFp(configuration).deleteUsersUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a paginated list of all users
         * @summary Get all users
         * @param {string} [include] Comma separated includes for the resource
         * @param {number} [perPage] How many results per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(include, perPage, options) {
            return exports.UsersApiFp(configuration).getUsers(include, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the user associated to the access token.
         * @summary Get the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersCurrent(options) {
            return exports.UsersApiFp(configuration).getUsersCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user by their given ID.
         * @summary Get user
         * @param {string} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserId(userId, options) {
            return exports.UsersApiFp(configuration).getUsersUserId(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user resource
         * @summary Create a new user
         * @param {CreateUserBody} [createUserBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsers(createUserBody, options) {
            return exports.UsersApiFp(configuration).postUsers(createUserBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a user record from their ID.
         * @summary
         * @param {string} userId
         * @param {InlineObject37} [inlineObject37]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserId(userId, inlineObject37, options) {
            return exports.UsersApiFp(configuration).putUsersUserId(userId, inlineObject37, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     * Delete a user by their given ID.
     * @summary
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    deleteUsersUserId(userId, options) {
        return exports.UsersApiFp(this.configuration).deleteUsersUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets a paginated list of all users
     * @summary Get all users
     * @param {string} [include] Comma separated includes for the resource
     * @param {number} [perPage] How many results per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsers(include, perPage, options) {
        return exports.UsersApiFp(this.configuration).getUsers(include, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the user associated to the access token.
     * @summary Get the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersCurrent(options) {
        return exports.UsersApiFp(this.configuration).getUsersCurrent(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a user by their given ID.
     * @summary Get user
     * @param {string} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getUsersUserId(userId, options) {
        return exports.UsersApiFp(this.configuration).getUsersUserId(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new user resource
     * @summary Create a new user
     * @param {CreateUserBody} [createUserBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    postUsers(createUserBody, options) {
        return exports.UsersApiFp(this.configuration).postUsers(createUserBody, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a user record from their ID.
     * @summary
     * @param {string} userId
     * @param {InlineObject37} [inlineObject37]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    putUsersUserId(userId, inlineObject37, options) {
        return exports.UsersApiFp(this.configuration).putUsersUserId(userId, inlineObject37, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
/**
 * VersioningApi - axios parameter creator
 * @export
 */
exports.VersioningApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Restores a model version
         * @summary Restore model
         * @param {string} modelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVersionsModelIdRestore: (modelId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'modelId' is not null or undefined
            if (modelId === null || modelId === undefined) {
                throw new base_1.RequiredError('modelId', 'Required parameter modelId was null or undefined when calling postVersionsModelIdRestore.');
            }
            const localVarPath = `/versions/{modelId}/restore`
                .replace(`{${"modelId"}}`, encodeURIComponent(String(modelId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign(Object.assign(Object.assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * VersioningApi - functional programming interface
 * @export
 */
exports.VersioningApiFp = function (configuration) {
    return {
        /**
         * Restores a model version
         * @summary Restore model
         * @param {string} modelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVersionsModelIdRestore(modelId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield exports.VersioningApiAxiosParamCreator(configuration).postVersionsModelIdRestore(modelId, options);
                return (axios = axios_1.default, basePath = base_1.BASE_PATH) => {
                    const axiosRequestArgs = Object.assign(Object.assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                    return axios.request(axiosRequestArgs);
                };
            });
        },
    };
};
/**
 * VersioningApi - factory interface
 * @export
 */
exports.VersioningApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Restores a model version
         * @summary Restore model
         * @param {string} modelId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVersionsModelIdRestore(modelId, options) {
            return exports.VersioningApiFp(configuration).postVersionsModelIdRestore(modelId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VersioningApi - object-oriented interface
 * @export
 * @class VersioningApi
 * @extends {BaseAPI}
 */
class VersioningApi extends base_1.BaseAPI {
    /**
     * Restores a model version
     * @summary Restore model
     * @param {string} modelId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersioningApi
     */
    postVersionsModelIdRestore(modelId, options) {
        return exports.VersioningApiFp(this.configuration).postVersionsModelIdRestore(modelId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.VersioningApi = VersioningApi;
